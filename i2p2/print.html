<!DOCTYPE HTML>
<html lang="zh-TW" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Introduction to Programming (II)</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="程式設計(二)教材">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
                <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Course Introduction</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> VS Code Tutorial</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="vscode_tutorial/lab_1_vscode_315.html"><strong aria-hidden="true">2.1.</strong> VS Code Tutorial (315 classroom)</a></li><li class="chapter-item expanded "><a href="vscode_tutorial/lab_1_vscode.html"><strong aria-hidden="true">2.2.</strong> VS Code Tutorial (Linux/macOS/code server)</a></li><li class="chapter-item expanded "><a href="vscode_tutorial/lab_1_vscode_win.html"><strong aria-hidden="true">2.3.</strong> VS Code Tutorial (WSL/windows + mingw)</a></li></ol></li><li class="chapter-item expanded "><a href="class/lecture1.html"><strong aria-hidden="true">3.</strong> Lecture 1: Sturcture and Class</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="class/lab/lab1.html"><strong aria-hidden="true">3.1.</strong> Lab 1: Hello Class</a></li></ol></li><li class="chapter-item expanded "><a href="class/lecture2.html"><strong aria-hidden="true">4.</strong> Lecture 2: Class Design 101</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="class/lecture2_ex1.html"><strong aria-hidden="true">4.1.</strong> Example 1: Triangle</a></li><li class="chapter-item expanded "><a href="class/lecture2_ex2.html"><strong aria-hidden="true">4.2.</strong> Example 2: Vector</a></li></ol></li><li class="chapter-item expanded "><a href="class/lecture3.html"><strong aria-hidden="true">5.</strong> Lecture 3: Class Data Members &amp; Member Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="class/lecture3_ex1.html"><strong aria-hidden="true">5.1.</strong> Example 1: Triangle (again)</a></li><li class="chapter-item expanded "><a href="class/lecture3_ex2.html"><strong aria-hidden="true">5.2.</strong> Example 2: Vector (again)</a></li><li class="chapter-item expanded "><a href="class/lecture3_ex3.html"><strong aria-hidden="true">5.3.</strong> Example 3: Integer Calculator</a></li></ol></li><li class="chapter-item expanded "><a href="class/lecture4.html"><strong aria-hidden="true">6.</strong> Lecture 4: Class Constructor &amp; Modifer</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="class/lecture4_ex1.html"><strong aria-hidden="true">6.1.</strong> Example 1: Triangle (again)</a></li><li class="chapter-item expanded "><a href="class/lecture4_ex2.html"><strong aria-hidden="true">6.2.</strong> Example 2: Vector (again)</a></li><li class="chapter-item expanded "><a href="class/lecture4_ex3.html"><strong aria-hidden="true">6.3.</strong> Example 3: Integer Calculator (again)</a></li><li class="chapter-item expanded "><a href="class/lab/lab4-1.html"><strong aria-hidden="true">6.4.</strong> Lab 4-1: Complex Numbers (50%)</a></li><li class="chapter-item expanded "><a href="class/lab/lab4-2.html"><strong aria-hidden="true">6.5.</strong> Lab 4-2: Complex Number Calculation (35%)</a></li><li class="chapter-item expanded "><a href="class/lab/lab4-3.html"><strong aria-hidden="true">6.6.</strong> Lab 4-3: Advance Complex Number Calculation (15%)</a></li></ol></li><li class="chapter-item expanded "><a href="class/lecture5.html"><strong aria-hidden="true">7.</strong> Lecture 5: Collaborate with Other Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="class/lecture5_ex1.html"><strong aria-hidden="true">7.1.</strong> Example 1: Triangle (again)</a></li><li class="chapter-item expanded "><a href="class/lecture5_ex2.html"><strong aria-hidden="true">7.2.</strong> Example 2: Vector (again)</a></li><li class="chapter-item expanded "><a href="class/lecture5_ex3.html"><strong aria-hidden="true">7.3.</strong> Example 3: Fixed Point Number &amp; Fixed Point Number Calculator</a></li></ol></li><li class="chapter-item expanded "><a href="class/lecture6.html"><strong aria-hidden="true">8.</strong> Lecture 6: Operator &amp; Operator Overloading</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="class/lecture6_ex1.html"><strong aria-hidden="true">8.1.</strong> Example 1: Triangle (again)</a></li><li class="chapter-item expanded "><a href="class/lecture6_ex2.html"><strong aria-hidden="true">8.2.</strong> Example 2: Vector (again)</a></li><li class="chapter-item expanded "><a href="class/lecture6_ex3.html"><strong aria-hidden="true">8.3.</strong> Example 3: Fixed Point Number &amp; Fixed Point Number Calculator (again)</a></li><li class="chapter-item expanded "><a href="class/lab/lab6-1.html"><strong aria-hidden="true">8.4.</strong> Lab 6-1: Enhanced Complex Numbers (40%)</a></li><li class="chapter-item expanded "><a href="class/lab/lab6-2.html"><strong aria-hidden="true">8.5.</strong> Lab 6-2: Simple Complex Number Calculator (40%)</a></li><li class="chapter-item expanded "><a href="class/lab/lab6-3.html"><strong aria-hidden="true">8.6.</strong> Lab 6-3: Enhanced Complex Number Calculator (20%)</a></li></ol></li><li class="chapter-item expanded "><a href="oop/lecture7.html"><strong aria-hidden="true">9.</strong> Lecture 7: Introduction to Object Oriented Programming &amp; Design</a></li><li class="chapter-item expanded "><a href="oop/lecture8.html"><strong aria-hidden="true">10.</strong> Lecture 8: OOP: Inheritance (1)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="oop/lecture8_ex1.html"><strong aria-hidden="true">10.1.</strong> Example 1: Integer &amp; Real</a></li><li class="chapter-item expanded "><a href="oop/lecture8_ex2.html"><strong aria-hidden="true">10.2.</strong> Example 2: Complex Number</a></li><li class="chapter-item expanded "><a href="oop/lecture8_ex3.html"><strong aria-hidden="true">10.3.</strong> Example 3: Integer &amp; Real &amp; Complex Number</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> Midterm Project: Big Positive Real Number Calculator</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="midterm-1.html"><strong aria-hidden="true">11.1.</strong> Midterm-1: Big Positive Real Number in Decimal Point Format</a></li><li class="chapter-item expanded "><a href="midterm-2.html"><strong aria-hidden="true">11.2.</strong> Midterm-2: Simple Big Positive Real Number Calculator</a></li><li class="chapter-item expanded "><a href="midterm-3.html"><strong aria-hidden="true">11.3.</strong> Midterm-3: Enhanced Big Positive Real Number Calculator</a></li></ol></li><li class="chapter-item expanded "><a href="oop/lecture10.html"><strong aria-hidden="true">12.</strong> Lecture 10: OOP: Inheritance (2)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="oop/lecture10_ex1.html"><strong aria-hidden="true">12.1.</strong> Example 1: Integer &amp; Real &amp; Complex Number Calculator</a></li><li class="chapter-item expanded "><a href="oop/lecture10_ex2.html"><strong aria-hidden="true">12.2.</strong> Example 2: Complex Number &amp; Triangle</a></li><li class="chapter-item expanded "><a href="oop/lecture10_ex3.html"><strong aria-hidden="true">12.3.</strong> Example 3: Complex Number &amp; Triangles</a></li></ol></li><li class="chapter-item expanded "><a href="oop/lecture11.html"><strong aria-hidden="true">13.</strong> Lecture 11: OOP: Polymorphism (1)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="oop/lecture11_ex1.html"><strong aria-hidden="true">13.1.</strong> Example 1: Integer &amp; Real</a></li><li class="chapter-item expanded "><a href="oop/lecture11_ex2.html"><strong aria-hidden="true">13.2.</strong> Example 2: Complex Number</a></li><li class="chapter-item expanded "><a href="oop/lecture11_ex3.html"><strong aria-hidden="true">13.3.</strong> Example 3: Integer &amp; Real &amp; Complex Number</a></li></ol></li><li class="chapter-item expanded "><a href="oop/lecture12.html"><strong aria-hidden="true">14.</strong> Lecture 12: OOP: Polymorphism (2)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="oop/lecture12_ex1.html"><strong aria-hidden="true">14.1.</strong> Example 1: Integer &amp; Real &amp; Complex Number Calculator</a></li><li class="chapter-item expanded "><a href="oop/lecture12_ex2.html"><strong aria-hidden="true">14.2.</strong> Example 2: Complex Number &amp; Triangles</a></li><li class="chapter-item expanded "><a href="oop/lab/lab12-1.html"><strong aria-hidden="true">14.3.</strong> Lab 12-1: Complex Number's Geometry (40%)</a></li><li class="chapter-item expanded "><a href="oop/lab/lab12-2.html"><strong aria-hidden="true">14.4.</strong> Lab 12-2: Simple Complex Number Geometry Transformation (40%)</a></li><li class="chapter-item expanded "><a href="oop/lab/lab12-3.html"><strong aria-hidden="true">14.5.</strong> Lab 12-3: Enhanced Complex Number Geometry Transformation (20%)</a></li></ol></li><li class="chapter-item expanded "><a href="file/lecture13.html"><strong aria-hidden="true">15.</strong> Lecture 13: File Processing (1)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="file/lecture13_ex1.html"><strong aria-hidden="true">15.1.</strong> Example 1: Big Real Number in Text File</a></li><li class="chapter-item expanded "><a href="file/lecture13_ex2.html"><strong aria-hidden="true">15.2.</strong> Example 2: Point &amp; Triangle in Text File (function ver.)</a></li><li class="chapter-item expanded "><a href="file/lecture13_ex3.html"><strong aria-hidden="true">15.3.</strong> Example 3: Vector &amp; Matrix in Binary File (function ver.)</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Introduction to Programming (II)</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!---
marp: true
author: Yi-Wen Hung
theme: default
headingDivider: 2
paginate: true
--->
<h1 id="course-introduction"><a class="header" href="#course-introduction">Course Introduction</a></h1>
<blockquote>
<p>Slides version: <a href="./intro_slides.html">intro_slides.html</a>
Website version: <a href="./intro.html">intro.html</a></p>
</blockquote>
<h2 id="課程說明-course-description"><a class="header" href="#課程說明-course-description">課程說明 (Course Description)</a></h2>
<p>本課程之內容包括：物件導向程式設計 (OOP)、C/C++ OOP 寫法、程式寫作技巧與觀念及實作範例。透過課堂解釋實作範例搭配作業練習各主題的語法或技巧。</p>
<p>The course will introduce the Object-Oriented Programming (OOP), the writing of OOP in C/C++ and the concepts and skills of programming.
Each theme will be instructed with examples and hands-on labs in-class or off-class.</p>
<h2 id="指定用書-text-books"><a class="header" href="#指定用書-text-books">指定用書 (Text Books)</a></h2>
<ul>
<li>課程講義，公布於課程網站上。 (Lecture notes, published on the course website.)</li>
</ul>
<h2 id="參考書籍-references"><a class="header" href="#參考書籍-references">參考書籍 (References)</a></h2>
<ul>
<li>
<p><a href="https://deitel.com/c-plus-plus-how-to-program-10-e/">Paul Deitel, and Harvey Deitel, C++ How to Program, 10/e</a> (主要參考, Primary reference)</p>
</li>
<li>
<p><a href="https://www.mheducation.com/highered/product/object-oriented-classical-software-engineering-schach/M9780073376189.html">Stephen Schach, Object-Oriented and Classical Software Engineering, 8/e</a></p>
</li>
<li>
<p><a href="https://ocw.nthu.edu.tw/ocw/index.php?page=course&amp;cid=138">國立清華大學開放式課程OpenCourseWare(NTHU, OCW) - 計算機程式設計二</a></p>
</li>
<li>
<p><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-096-introduction-to-c-january-iap-2011/">Introduction to C++ | Electrical Engineering and Computer Science | MIT OpenCourseWare</a></p>
</li>
<li>
<p><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-s096-introduction-to-c-and-c-january-iap-2013/">Introduction to C and C++ | Electrical Engineering and Computer Science | MIT OpenCourseWare</a></p>
</li>
<li>
<p><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-s096-effective-programming-in-c-and-c-january-iap-2014/index.htm">Effective Programming in C and C++ | Electrical Engineering and Computer Science | MIT OpenCourseWare</a></p>
</li>
</ul>
<h2 id="教學方式-teaching-method"><a class="header" href="#教學方式-teaching-method">教學方式 (Teaching Method)</a></h2>
<p>透過講義解說各主題的實作技巧，由學生練習、測試與完成相關之課堂實作或作業。
課堂會採用實體及線上混合教學，學生可在滿足防疫規定下參加現場授課，同時於線上平台直播，同學也可同步於線上平台留言發問。
學生課後可透過 eeclass 討論區及預約時段與授課老師及助教討論。</p>
<p>The course will introduce each theme with lecture notes.
Students will practice each theme with Homeworks and hands-on labs in-class or off-class.
The course will hold both physically and online.
Students can attend class physically under Taiwan CDC COVID-19 guideline.
Also, the course will stream on online streaming platform(s).
Students can discuss in real-time on the online streaming platform(s).
After class, students can use the discussion forum in the NTHU eeclass or make a reservation with instructor or TA.</p>
<h2 id="教學進度-syllabus-project-version"><a class="header" href="#教學進度-syllabus-project-version">教學進度 (Syllabus) (Project Version)</a></h2>
<p>(5/15 updated) 週次皆為暫定安排，會依實際授課情形調整。</p>
<table><thead><tr><th align="center">課程 (Lecture)</th><th align="left">主題 (Theme)</th></tr></thead><tbody>
<tr><td align="center"><a href="class/lecture1.html">Lecture 1 (2/17)</a></td><td align="left">Course Introduction</td></tr>
<tr><td align="center"></td><td align="left">Sturcture and Class</td></tr>
<tr><td align="center"><a href="class/lab/lab1.html">Lab 1 (2/17)</a></td><td align="left">Programming Environment &amp; Class Helloworld</td></tr>
<tr><td align="center"><a href="class/lecture2.html">Lecture 2 (2/24)</a></td><td align="left">Class Design 101</td></tr>
<tr><td align="center"><a href="class/lecture3.html">Lecture 3 (3/3)</a></td><td align="left">Class Members &amp; Methods</td></tr>
<tr><td align="center"><a href="class/lecture4.html">Lecture 4 (3/10)</a></td><td align="left">Class Constructor &amp; Modifer</td></tr>
<tr><td align="center"><a href="class/lab/lab4-1.html">Lab 4 (3/10)</a></td><td align="left">Complex Number</td></tr>
<tr><td align="center"><a href="class/lecture5.html">Lecture 5 (3/24)</a></td><td align="left">Collaborate with Other Classes</td></tr>
<tr><td align="center"><a href="class/lecture6.html">Lecture 6 (3/31)</a></td><td align="left">Operator &amp; Operator Overloading</td></tr>
<tr><td align="center"><a href="class/lab/lab6-1.html">Lab 6 (3/31)</a></td><td align="left">Complex Number Calculator</td></tr>
<tr><td align="center"><a href="oop/lecture7.html">Lecture 7 (4/7)</a></td><td align="left">Introduction to Object Oriented Programming &amp; Design</td></tr>
<tr><td align="center"><a href="oop/lecture8.html">Lecture 8 (4/14)</a></td><td align="left">OOP: Inheritance (1)</td></tr>
<tr><td align="center"><a href="midterm-1.html">Project 8 (4/14)</a></td><td align="left">Midterm Project Announcement</td></tr>
<tr><td align="center">Demo 9 (4/21)</td><td align="left">Midterm Project Demo</td></tr>
<tr><td align="center"><a href="oop/lecture10.html">Lecture 10 (4/28)</a></td><td align="left">OOP: Inheritance (2)</td></tr>
<tr><td align="center"><a href="oop/lecture11.html">Lecture 11 (5/5)</a></td><td align="left">OOP: Polymorphism (1)</td></tr>
<tr><td align="center"><a href="oop/lecture12.html">Lecture 12 (5/12)</a></td><td align="left">OOP: Polymorphism (2)</td></tr>
<tr><td align="center"><a href="oop/lab/lab12-1.html">Lab 12 (5/12)</a></td><td align="left">Complex Number's Geometry &amp; Operations</td></tr>
<tr><td align="center"><a href="file/lecture13.html">Lecture 13 (5/19)</a></td><td align="left">File Processing (1)</td></tr>
<tr><td align="center">Lecture 14 (5/26)</td><td align="left">File Processing (2)</td></tr>
<tr><td align="center">Lab 14 (5/26)</td><td align="left">File Export of Complex Number's Geometry</td></tr>
<tr><td align="center">Lecture 15 (6/2)</td><td align="left">Advanced I/O &amp; Exception Handling</td></tr>
<tr><td align="center">Lecture 16 (6/9)</td><td align="left">(Extra) C++ Image Export &amp; Matplot++</td></tr>
<tr><td align="center">Project 16 (6/9)</td><td align="left">Final Project Announcment</td></tr>
<tr><td align="center">Demo 17 (6/16)</td><td align="left">Final Project Demo</td></tr>
<tr><td align="center">Lecture 18 (online)</td><td align="left">(Extra) Google Test for Class</td></tr>
</tbody></table>
<h2 id="成績考核-evaluation"><a class="header" href="#成績考核-evaluation">成績考核 (Evaluation)</a></h2>
<p>(4/7 updated) 暫定，會依實際授課情形調整。 (Tentative, will change during the course)</p>
<p>學期成績 (Grade) ＝ 作業/實作 (Homework/Lab), 50% ＋ 期中 Project (Midterm Project), 25% ＋ 期末 Project (Midterm Project), 25% + Bonus, 15%</p>
<h2 id="相關網頁personal-website"><a class="header" href="#相關網頁personal-website">相關網頁(Personal Website)</a></h2>
<p>課程網頁 (Course website): <a href="https://stevenokm.github.io/i2p-nthu-math/i2p2">https://stevenokm.github.io/i2p-nthu-math/i2p2</a>
<img src="qrcode_stevenokm.github.io.png" alt="bg right fit" /></p>
<h2 id="課程資訊"><a class="header" href="#課程資訊">課程資訊</a></h2>
<h3 id="課程上課時間"><a class="header" href="#課程上課時間">課程上課時間</a></h3>
<ul>
<li>每週四 15:30 - 18:10
<ul>
<li>前 1 - 1.5 小時講解今日主題</li>
<li>之後時間開放同學於現場或線上即時提問</li>
</ul>
</li>
</ul>
<h3 id="課程上課地點實體教室"><a class="header" href="#課程上課地點實體教室">課程上課地點(實體教室)</a></h3>
<ul>
<li>綜三館 315 電腦教室 (座位47人，可出席人數 <strong>47</strong> 人)
<ul>
<li>實體上課出席登記: <a href="https://docs.google.com/spreadsheets/d/1U2Dlp3O_LZSHzowlplPGk_7m03Y4vcQKjtO2P1ctjQk/edit#gid=538727748">出席 (不計分)</a> </li>
<li>實體上課出席座位表: <a href="https://docs.google.com/spreadsheets/d/1U2Dlp3O_LZSHzowlplPGk_7m03Y4vcQKjtO2P1ctjQk/edit#gid=0">座位表</a></li>
</ul>
</li>
</ul>
<p><img src="qrcode_docs.google.com.png" alt="bg right fit" /></p>
<hr />
<h3 id="課程上課地點網路"><a class="header" href="#課程上課地點網路">課程上課地點(網路)</a></h3>
<ul>
<li>Youtube (Link: <a href="https://youtube.com/playlist?list=PLEpArVdL-rlK5YMN7m6QuuyrnH88N7RfG">110 程式設計二 上課錄影 - YouTube</a>)</li>
</ul>
<ul>
<li>Teams (Link: <a href="https://teams.microsoft.com/l/team/19%3aH19zZss1ePwnH8nZ_gaAsqMG1PosSj1uMiFL9blDMOw1%40thread.tacv2/conversations?groupId=145776ff-8b4a-4119-bab0-2d3896331e18&amp;tenantId=6c3bc511-43c7-4596-baeb-2335c69c41f1">110 程式設計二</a>)
<ul>
<li>申請方式: <a href="https://learning.site.nthu.edu.tw/p/412-1319-12292.php?Lang=zh-tw">Office 365 服務 (nthu.edu.tw)</a></li>
<li>外校同學可提供 office 365 帳號給助教協助加入團隊。
<img src="qrcode_www.youtube.com.png" alt="bg right fit" /></li>
</ul>
</li>
</ul>
<hr />
<h3 id="加簽規則"><a class="header" href="#加簽規則">加簽規則</a></h3>
<ul>
<li>本課程開放加簽，原則上限制人數為 47 人，且參加實體課程需配合防疫規定。
<ul>
<li>請使用電子加簽系統加簽。</li>
<li>目前選課系統上限為本系大一生 37 人，並另有 10 人須審核加簽名額。</li>
<li>外系同學可線上加簽系統加選課程。</li>
</ul>
</li>
</ul>
<h2 id="作業"><a class="header" href="#作業">作業</a></h2>
<ul>
<li>作業會公布在課程網頁上，並使用 eeclass 平台繳交作業。
<ul>
<li>eeclass 連結: <a href="https://eeclass.nthu.edu.tw/course/8073">https://eeclass.nthu.edu.tw/course/8073</a></li>
<li>同學可多加利用 eeclass 的討論區進行討論。</li>
</ul>
</li>
</ul>
<ul>
<li>作業會使用自動化工具檢查，若有批改上有問題可與助教詢問。</li>
<li>作業抄襲一律 0 分計算，並且不計入繳交次數。</li>
<li>作業須準時繳交，遲交則得到原始成績 80% 的分數。</li>
</ul>
<p><img src="qrcode_eeclass.nthu.edu.tw.png" alt="bg right fit" /></p>
<h2 id="期中--期末-project--demo"><a class="header" href="#期中--期末-project--demo">期中 / 期末 Project + Demo</a></h2>
<ul>
<li>題型: 1-2 題基本題 + 1-2 題進階題 (與上學期期中/期末評量題型相同)</li>
</ul>
<ul>
<li>繳交期限: 公布後次週三 23:59:59
<ul>
<li>可遲交，遲交則得到原始成績 80% 的分數</li>
<li>未 Demo 則該次 Project 成績為 0 分</li>
</ul>
</li>
<li>Demo 時間: 公布後次週四 15:30 - 18:30 (與上學期期中/期末評量時間相同)
<ul>
<li>Demo 時間表 (連結待補)</li>
<li>每位同學 8 分鐘 Demo 時間，請務必準時參加</li>
<li>遲交的同學仍須另外約 Demo 時間，最晚不得超過該次 Demo 時間後的次週四 18:30
<ul>
<li>e.g. 該 Project 4/14 公布後，同學遲交的話，需於 4/25 18:30 前約 Demo</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>Demo 地點: 綜三館 315 電腦教室
<ul>
<li>若改為遠距教學時，則使用 Teams 進行 Demo</li>
</ul>
</li>
</ul>
<ul>
<li>Demo 流程:
<ol>
<li>從 eeclass 上下載最新版本的 Project 程式碼</li>
<li>使用 <a href="vscode_tutorial/lab_1_vscode_win.html#%E8%A8%AD%E5%AE%9A-vscode-%E7%92%B0%E5%A2%83-windows--mingw">windows + mingw 環境</a>下的 g++ 編譯程式碼</li>
<li>簡述如何實作</li>
<li>助教會隨機挑選一個擬定好的問題，請同學試著解出問題 (白板題)
<ol>
<li>部分程式碼/member function的運作邏輯？</li>
<li>部分程式碼/member function的用途？</li>
<li>輸入至輸出的程式碼運作流程？</li>
<li>調整部分程式碼/member function後，部分程式碼的運作流程/結果會如何改變？</li>
</ol>
</li>
<li>範例題目會於 Demo 前公布於課程網站，供同學參考題型，實際題目以 Demo 為主。
<ul>
<li>公布時間不晚於 Demo 前一日 18:00，並會於 eeclass 上公布。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="老師資訊"><a class="header" href="#老師資訊">老師資訊</a></h2>
<p>洪奕文 E-mail: <a href="mailto:s106062802@m106.nthu.edu.tw">s106062802@m106.nthu.edu.tw</a></p>
<p>Office Hours: Every Mon. 14:00 - 15:00</p>
<p>Office Room: R2341, 2F, EECS Building</p>
<p><strong>Note:</strong> 若要來研究室詢問問題，請 <strong>一定要預約時間</strong> ，臨時來研究室詢問 <strong>不保證</strong> 能夠當下開放詢問。
若要約 teams 詢問也可以約 Office Hour 時段詢問。</p>
<h2 id="ta-infos"><a class="header" href="#ta-infos">TA infos</a></h2>
<p>許廷碩 E-mail: <a href="mailto:tim890727@gmail.com">tim890727@gmail.com</a></p>
<p>TA Hours: 寫信詢問</p>
<h2 id="bonus"><a class="header" href="#bonus">Bonus</a></h2>
<ul>
<li>課程內容如果有錯誤，可以在每頁的右上方 &quot;Suggest an edit&quot; 使用 Github 進行修改，修改完畢後利用 Pull Request 的方式提交。
<ul>
<li>提交時註明學號以及姓名，並且每提交一次可以增加學期分數，配分依據修改幅度而訂。</li>
<li>Github Commit 提交教學請參考 <a href="https://stevenokm.github.io/i2p-nthu-math/i2p1/github/lecture_15.html#making-and-committing-changes">Lecture 15: Github Tutorial - Introduction to Programming (I)</a></li>
</ul>
</li>
</ul>
<ul>
<li>於 eeclass 討論區參與討論，每提交一次可以增加學期分數，配分依據提交次數而訂。</li>
<li>每人總增加分數不超過 15 分</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visual-studio-code-tutorial-315-classroom"><a class="header" href="#visual-studio-code-tutorial-315-classroom">Visual Studio Code Tutorial (315 classroom)</a></h1>
<h2 id="使用-vscode-環境"><a class="header" href="#使用-vscode-環境">使用 VSCode 環境</a></h2>
<p>點擊兩下，打開桌面上的 <code>Visual Studio Code</code>。</p>
<p><img src="vscode_tutorial/img/launch_vscode.png" alt="launch vscode" /></p>
<p><img src="vscode_tutorial/img/vscode_wellcome.png" alt="vscode welcome" /></p>
<p>在文字輸入區輸入以下程式碼</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

using namespace std;

int main()
{
    vector&lt;string&gt; msg {&quot;Hello&quot;, &quot;C++&quot;, &quot;World&quot;, &quot;from&quot;, &quot;VS Code&quot;, &quot;and the C++ extension!&quot;};

    for (const string&amp; word : msg)
    {
        cout &lt;&lt; word &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
}
</code></pre>
<p><img src="vscode_tutorial/img/input_cpp.png" alt="input cpp code" /></p>
<h3 id="編譯--執行-hello-world"><a class="header" href="#編譯--執行-hello-world">編譯 &amp; 執行 Hello world!</a></h3>
<p>In VSCode: <code>Terminal -&gt; New Terminal</code></p>
<p><img src="vscode_tutorial/img/create_terminal.png" alt="create terminal" /></p>
<p>In VSCode Terminal:</p>
<pre><code class="language-console">$ g++ test.cpp
$ ./a.out
Hello C++ World from VS Code and the C++ extension! 
$ 
</code></pre>
<h3 id="測試編譯以及除錯"><a class="header" href="#測試編譯以及除錯">測試編譯以及除錯</a></h3>
<h4 id="測試編譯"><a class="header" href="#測試編譯">測試編譯</a></h4>
<ol>
<li>點擊左方test.cpp檔案後，在要中斷的程式碼行號左邊點一下，會出現紅點，如下圖示範：</li>
</ol>
<p><img src="vscode_tutorial/img/insert_breakpoint.png" alt="insert breakpoint" /></p>
<ol>
<li>按下<code>ctrl+shift+B</code>按鍵，或上方<code>terminal -&gt; Run Build Task</code>，如下圖示範：</li>
</ol>
<p><img src="vscode_tutorial/./img/fig_08-run_build_task.png" alt="run_build_task" /></p>
<ol start="3">
<li>此時上方會出現以下畫面，選擇中間選項使用 <strong>g++</strong> 編譯檔案，如下圖示範：</li>
</ol>
<p><img src="vscode_tutorial/./img/fig_09-build_hint.png" alt="build_hint" /></p>
<ol start="4">
<li>設置正確的話，此時下方會出現編譯成功完成的提示，如下圖示範：</li>
</ol>
<p><img src="vscode_tutorial/./img/fig_10-build_successfully.png" alt="build_successfully" /></p>
<h4 id="測試除錯"><a class="header" href="#測試除錯">測試除錯</a></h4>
<ol>
<li>
<p>完成前項<code>測試編譯</code>的所有流程</p>
</li>
<li>
<p>按下左方三角形按鈕後選擇<code>Run and Debug</code>，如下圖示範：</p>
</li>
</ol>
<p><img src="vscode_tutorial/./img/fig_11-open_debugger.png" alt="open_debugger" /></p>
<ol start="3">
<li>此時上方會依序出現相關提示，選擇預設的即可，如下圖示範：</li>
</ol>
<p><img src="vscode_tutorial/./img/fig_12-debuger_hint-1.png" alt="debuger_hint-1" />
<img src="vscode_tutorial/./img/fig_13-debuger_hint-2.png" alt="debuger_hint-2" /></p>
<ol start="4">
<li>若設定正確的話，會看到程式停留在選取的那一行，如下圖示範：</li>
</ol>
<p><img src="vscode_tutorial/img/run_gdb.png" alt="run gdb" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visual-studio-code-tutorial"><a class="header" href="#visual-studio-code-tutorial">Visual Studio Code Tutorial</a></h1>
<h2 id="設定-vscode-環境-linux"><a class="header" href="#設定-vscode-環境-linux">設定 VSCode 環境 (Linux)</a></h2>
<h3 id="安裝-gcc"><a class="header" href="#安裝-gcc">安裝 GCC</a></h3>
<p>打開 <strong>終端機</strong> 輸入以下指令：</p>
<pre><code class="language-bash">sudo apt update
sudo apt install -y build-essential g++ gdb
g++ -v
</code></pre>
<p>Wrong:</p>
<p><img src="vscode_tutorial/img/g++_wrong.png" alt="g++ wrong" /></p>
<p>Correct:</p>
<p><img src="vscode_tutorial/img/g++_correct.png" alt="g++ correct" /></p>
<h3 id="安裝-vscode--c-plugin"><a class="header" href="#安裝-vscode--c-plugin">安裝 VSCode &amp; C++ plugin</a></h3>
<p>Install VSCode: <a href="https://code.visualstudio.com/docs/setup/linux">https://code.visualstudio.com/docs/setup/linux</a></p>
<p>Install the C++ extension for VSCode: <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools</a></p>
<h3 id="新增專案-hello-world"><a class="header" href="#新增專案-hello-world">新增專案 (Hello world!)</a></h3>
<p>在 <strong>終端機</strong> 輸入以下指令：</p>
<pre><code class="language-console">$ mkdir projects
$ cd projects
$ code .
</code></pre>
<p>In VSCode: <code>Exploer -&gt; New File</code></p>
<p>輸入 <code>test.cpp</code></p>
<p><img src="vscode_tutorial/img/new_file.png" alt="new file icon" /></p>
<p>在文字輸入區輸入以下程式碼</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

using namespace std;

int main(void)
{
    vector&lt;string&gt; msg {&quot;Hello&quot;, &quot;C++&quot;, &quot;World&quot;, &quot;from&quot;, &quot;VS Code&quot;, &quot;and the C++ extension!&quot;};

    for (const string&amp; word : msg)
    {
        cout &lt;&lt; word &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
    return 0;
}
</code></pre>
<p><img src="vscode_tutorial/img/input_cpp.png" alt="input cpp code" /></p>
<h3 id="編譯--執行-hello-world-1"><a class="header" href="#編譯--執行-hello-world-1">編譯 &amp; 執行 Hello world!</a></h3>
<p>In VSCode: <code>Terminal -&gt; New Terminal</code></p>
<p><img src="vscode_tutorial/img/create_terminal.png" alt="create terminal" /></p>
<p>In VSCode Terminal:</p>
<pre><code class="language-console">$ g++ test.cpp
$ ./a.out
Hello C++ World from VS Code and the C++ extension! 
$ 
</code></pre>
<h3 id="debugger"><a class="header" href="#debugger">Debugger</a></h3>
<p>可以設置中斷點，方便程式除錯。</p>
<h4 id="launchjson"><a class="header" href="#launchjson"><code>launch.json</code></a></h4>
<p>In VSCode: <code>Exploer -&gt; New Folder</code></p>
<p>輸入 <code>.vscode</code></p>
<p><img src="vscode_tutorial/img/new_folder.png" alt="new folder icon" /></p>
<p>In VSCode: <code>Exploer -&gt; New File</code></p>
<p>輸入 <code>launch.json</code></p>
<p>在文字輸入區輸入以下設定檔</p>
<pre><code class="language-json">{
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;name&quot;: &quot;(gdb) Launch&quot;,
            &quot;type&quot;: &quot;cppdbg&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;program&quot;: &quot;${workspaceFolder}/a.out&quot;,
            &quot;args&quot;: [],
            &quot;stopAtEntry&quot;: false,
            &quot;cwd&quot;: &quot;${workspaceFolder}&quot;,
            &quot;environment&quot;: [],
            &quot;externalConsole&quot;: false,
            &quot;MIMode&quot;: &quot;gdb&quot;,
            &quot;setupCommands&quot;: [
                {
                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,
                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,
                    &quot;ignoreFailures&quot;: true
                }
            ]
        }
    ]
}
</code></pre>
<h4 id="編譯--執行-debugger"><a class="header" href="#編譯--執行-debugger">編譯 &amp; 執行 Debugger</a></h4>
<p>In VSCode Terminal:</p>
<pre><code class="language-console">$ g++ -g test.cpp
$ 
</code></pre>
<p>插入中斷點</p>
<p>在要中斷的程式碼行號左邊點一下</p>
<p><img src="vscode_tutorial/img/insert_breakpoint.png" alt="insert breakpoint" /></p>
<p>In VSCode: <code>Run -&gt; Start Debugging F5</code></p>
<p><img src="vscode_tutorial/img/start_gdb.png" alt="start debugging" /></p>
<p><img src="vscode_tutorial/img/run_gdb.png" alt="run gdb" /></p>
<p>NOTE: 安裝完後可以在 <code>File -&gt; Oper Recent</code> 開啟 WSL 的工作區 (後綴有 <code>WSL:Ubuntu</code>)</p>
<h2 id="設定-vscode-環境-macos"><a class="header" href="#設定-vscode-環境-macos">設定 VSCode 環境 (macOS)</a></h2>
<h3 id="安裝-g"><a class="header" href="#安裝-g">安裝 g++</a></h3>
<p>打開 <strong>終端機</strong> 輸入以下指令：</p>
<pre><code class="language-bash">xcode-select --install
g++ -v
</code></pre>
<p>Wrong:</p>
<p><img src="vscode_tutorial/img/g++_wrong.png" alt="g++ wrong" /></p>
<p>Correct:</p>
<p><img src="vscode_tutorial/img/clang_correct.png" alt="g++ correct" /></p>
<h3 id="安裝-vscode--c-plugin-1"><a class="header" href="#安裝-vscode--c-plugin-1">安裝 VSCode &amp; C++ plugin</a></h3>
<p>Install VSCode: <a href="https://code.visualstudio.com/docs/setup/mac">https://code.visualstudio.com/docs/setup/mac</a></p>
<p>Install the C++ extension for VSCode: <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools</a></p>
<p>Note: 要加入 <code>code</code> 到環境變數 <code>PATH</code> 內。</p>
<ol>
<li>打開 <strong>Command Palette</strong> (<kbd>⌘</kbd> <kbd>Shift</kbd> <kbd>P</kbd>) 後輸入 <code>shell command</code>，就可以找到 <strong>Shell Command: Install 'code' command in PATH</strong></li>
</ol>
<p><img src="vscode_tutorial/img/mac_install_code_path.png" alt="mac_install_code_path" /></p>
<ol start="2">
<li>重新啟動 <strong>終端機</strong></li>
</ol>
<h3 id="新增專案-hello-world-1"><a class="header" href="#新增專案-hello-world-1">新增專案 (Hello world!)</a></h3>
<p>在 <strong>終端機</strong> 輸入以下指令：</p>
<pre><code class="language-console">$ mkdir projects
$ cd projects
$ code .
</code></pre>
<p>In VSCode: <code>Exploer -&gt; New File</code></p>
<p>輸入 <code>test.cpp</code></p>
<p><img src="vscode_tutorial/img/new_file.png" alt="new file icon" /></p>
<p>在文字輸入區輸入以下程式碼</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

using namespace std;

int main(void)
{
    vector&lt;string&gt; msg {&quot;Hello&quot;, &quot;C++&quot;, &quot;World&quot;, &quot;from&quot;, &quot;VS Code&quot;, &quot;and the C++ extension!&quot;};

    for (const string&amp; word : msg)
    {
        cout &lt;&lt; word &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
    return 0;
}
</code></pre>
<p><img src="vscode_tutorial/img/input_cpp.png" alt="input cpp code" /></p>
<h4 id="settingsjson"><a class="header" href="#settingsjson"><code>settings.json</code></a></h4>
<p>In VSCode: <code>Exploer -&gt; New Folder</code></p>
<p>輸入 <code>.vscode</code></p>
<p><img src="vscode_tutorial/img/new_folder.png" alt="new folder icon" /></p>
<p>In VSCode: <code>Exploer -&gt; New File</code></p>
<p>輸入 <code>settings.json</code></p>
<p><img src="vscode_tutorial/img/new_file_settings.png" alt="new file icon" /></p>
<p>在文字輸入區輸入以下設定檔</p>
<pre><code class="language-json">{
    &quot;C_Cpp.default.cppStandard&quot;: &quot;c++17&quot;
}
</code></pre>
<h3 id="編譯--執行-hello-world-2"><a class="header" href="#編譯--執行-hello-world-2">編譯 &amp; 執行 Hello world!</a></h3>
<p>In VSCode: <code>Terminal -&gt; New Terminal</code></p>
<p><img src="vscode_tutorial/img/create_terminal.png" alt="create terminal" /></p>
<p>In VSCode Terminal:</p>
<pre><code class="language-console">$ g++ -std=c++17 -stdlib=libc++ test.cpp
$ ./a.out
Hello C++ World from VS Code and the C++ extension! 
$ 
</code></pre>
<h3 id="debugger-1"><a class="header" href="#debugger-1">Debugger</a></h3>
<p>可以設置中斷點，方便程式除錯。</p>
<h4 id="安裝-codelldb-plugin"><a class="header" href="#安裝-codelldb-plugin">安裝 CodeLLDB plugin</a></h4>
<p>Install the CodeLLDB extension for VSCode: <a href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb">https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb</a></p>
<h4 id="launchjson-1"><a class="header" href="#launchjson-1"><code>launch.json</code></a></h4>
<p>In VSCode:</p>
<p>選擇 <code>.vscode</code></p>
<p>In VSCode: <code>Exploer -&gt; New File</code></p>
<p>輸入 <code>launch.json</code></p>
<p>在文字輸入區輸入以下設定檔</p>
<pre><code class="language-json">{
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;name&quot;: &quot;(gdb) Launch&quot;,
            &quot;type&quot;: &quot;lldb&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;program&quot;: &quot;${workspaceFolder}/a.out&quot;,
            &quot;args&quot;: [&quot;-arg1&quot;, &quot;-arg2&quot;],
            &quot;stopAtEntry&quot;: false,
            &quot;cwd&quot;: &quot;${workspaceFolder}&quot;,
            &quot;environment&quot;: [],
            &quot;externalConsole&quot;: false,
            &quot;MIMode&quot;: &quot;lldb&quot;,
            &quot;setupCommands&quot;: [
                {
                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,
                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,
                    &quot;ignoreFailures&quot;: true
                }
            ]
        }
    ]
}
</code></pre>
<h4 id="編譯--執行-debugger-1"><a class="header" href="#編譯--執行-debugger-1">編譯 &amp; 執行 Debugger</a></h4>
<p>In VSCode Terminal:</p>
<pre><code class="language-console">$ g++ -std=c++17 -stdlib=libc++ -g test.cpp
$ 
</code></pre>
<p>插入中斷點</p>
<p>在要中斷的程式碼行號左邊點一下</p>
<p><img src="vscode_tutorial/img/insert_breakpoint.png" alt="insert breakpoint" /></p>
<p>In VSCode: <code>Run -&gt; Start Debugging F5</code></p>
<p><img src="vscode_tutorial/img/run_gdb.png" alt="run gdb" /></p>
<h2 id="del使用-vscode-serverdel"><a class="header" href="#del使用-vscode-serverdel"><del>使用 VSCode server</del></a></h2>
<h2 id="使用-web-ide"><a class="header" href="#使用-web-ide">使用 web IDE</a></h2>
<p>Notice: 僅提供方便使用的網站，與 VSCode 環境不同，需自己學習使用。</p>
<ul>
<li><a href="https://replit.com/">https://replit.com/</a>
<ul>
<li>需註冊帳號，有部分功能需付費。</li>
</ul>
</li>
<li><a href="https://www.onlinegdb.com/">https://www.onlinegdb.com/</a>
<ul>
<li>無須註冊帳號，僅有基本功能。</li>
</ul>
</li>
<li><a href="https://www.online-ide.com/">https://www.online-ide.com/</a>
<ul>
<li>無須註冊帳號，僅有基本功能。</li>
</ul>
</li>
</ul>
<p>Reference: </p>
<ul>
<li><a href="https://code.visualstudio.com/docs/cpp/config-linux">Get Started with C++ on Linux in Visual Studio Code</a></li>
<li><a href="https://code.visualstudio.com/docs/cpp/config-clang-mac">Configure VS Code for Clang/LLVM on macOS</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visual-studio-code-tutorial-wslwindows--mingw"><a class="header" href="#visual-studio-code-tutorial-wslwindows--mingw">Visual Studio Code Tutorial (WSL/windows + mingw)</a></h1>
<h2 id="設定-vscode-環境-wsl"><a class="header" href="#設定-vscode-環境-wsl">設定 VSCode 環境 (WSL)</a></h2>
<p>NOTE: 安裝教學影片 <a href="https://youtu.be/5HDa-unVCc4">WSL Tutorial</a></p>
<h3 id="安裝-wsl--gcc"><a class="header" href="#安裝-wsl--gcc">安裝 WSL &amp; GCC</a></h3>
<p>Install WSL: <a href="https://docs.microsoft.com/en-us/windows/wsl/install">https://docs.microsoft.com/en-us/windows/wsl/install</a></p>
<h4 id="啟動-wsl-ubuntu"><a class="header" href="#啟動-wsl-ubuntu">啟動 WSL Ubuntu</a></h4>
<p><img src="vscode_tutorial/img/start-ubuntu.png" alt="start ubuntu" /></p>
<p>在 <strong>WSL Ubuntu</strong> 輸入以下指令：</p>
<pre><code class="language-bash">sudo apt update
sudo apt install -y build-essential g++ gdb
g++ -v
</code></pre>
<p>Wrong:</p>
<p><img src="vscode_tutorial/img/g++_wrong.png" alt="g++ wrong" /></p>
<p>Correct:</p>
<p><img src="vscode_tutorial/img/g++_correct.png" alt="g++ correct" /></p>
<h3 id="安裝-vscode--remote---wsl-plugin"><a class="header" href="#安裝-vscode--remote---wsl-plugin">安裝 VSCode &amp; Remote - WSL plugin</a></h3>
<p>Install VSCode: <a href="https://code.visualstudio.com/docs/setup/windows">https://code.visualstudio.com/docs/setup/windows</a></p>
<p>Install the Remote - WSL extension for VSCode: <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-wsl">https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-wsl</a></p>
<h3 id="新增專案-hello-world-2"><a class="header" href="#新增專案-hello-world-2">新增專案 (Hello world!)</a></h3>
<p>重新打開 <strong>WSL Ubuntu</strong> 並輸入以下指令：</p>
<pre><code class="language-console">$ mkdir projects
$ cd projects
$ code .
</code></pre>
<p>Correct:</p>
<p><img src="vscode_tutorial/img/wsl-status-bar.png" alt="wsl correct 2" /></p>
<h3 id="安裝-wsl-c-plugin"><a class="header" href="#安裝-wsl-c-plugin">安裝 WSL C++ plugin</a></h3>
<p>Install the C++ extension for VSCode: <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools</a></p>
<p>Correct:</p>
<p><img src="vscode_tutorial/img/install-in-wsl.png" alt="c++ in wsl" /></p>
<p>In VSCode: <code>Exploer -&gt; New File</code></p>
<p>輸入 <code>test.cpp</code></p>
<p><img src="vscode_tutorial/img/new_file.png" alt="new file icon" /></p>
<p>在文字輸入區輸入以下程式碼</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

using namespace std;

int main()
{
    vector&lt;string&gt; msg {&quot;Hello&quot;, &quot;C++&quot;, &quot;World&quot;, &quot;from&quot;, &quot;VS Code&quot;, &quot;and the C++ extension!&quot;};

    for (const string&amp; word : msg)
    {
        cout &lt;&lt; word &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
}
</code></pre>
<p><img src="vscode_tutorial/img/input_cpp.png" alt="input cpp code" /></p>
<h3 id="編譯--執行-hello-world-3"><a class="header" href="#編譯--執行-hello-world-3">編譯 &amp; 執行 Hello world!</a></h3>
<p>In VSCode: <code>Terminal -&gt; New Terminal</code></p>
<p><img src="vscode_tutorial/img/create_terminal.png" alt="create terminal" /></p>
<p>In VSCode Terminal:</p>
<pre><code class="language-console">$ g++ test.cpp
$ ./a.out
Hello C++ World from VS Code and the C++ extension! 
$ 
</code></pre>
<h3 id="debugger-2"><a class="header" href="#debugger-2">Debugger</a></h3>
<p>可以設置中斷點，方便程式除錯。</p>
<h4 id="launchjson-2"><a class="header" href="#launchjson-2"><code>launch.json</code></a></h4>
<p>In VSCode: <code>Exploer -&gt; New Folder</code></p>
<p>輸入 <code>.vscode</code></p>
<p><img src="vscode_tutorial/img/new_folder.png" alt="new folder icon" /></p>
<p>In VSCode: <code>Exploer -&gt; New File</code></p>
<p>輸入 <code>launch.json</code></p>
<p>在文字輸入區輸入以下設定檔</p>
<pre><code class="language-json">{
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;name&quot;: &quot;(gdb) Launch&quot;,
            &quot;type&quot;: &quot;cppdbg&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;program&quot;: &quot;${workspaceFolder}/a.out&quot;,
            &quot;args&quot;: [],
            &quot;stopAtEntry&quot;: false,
            &quot;cwd&quot;: &quot;${workspaceFolder}&quot;,
            &quot;environment&quot;: [],
            &quot;externalConsole&quot;: false,
            &quot;MIMode&quot;: &quot;gdb&quot;,
            &quot;setupCommands&quot;: [
                {
                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,
                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,
                    &quot;ignoreFailures&quot;: true
                }
            ]
        }
    ]
}
</code></pre>
<h4 id="編譯--執行-debugger-2"><a class="header" href="#編譯--執行-debugger-2">編譯 &amp; 執行 Debugger</a></h4>
<p>In VSCode Terminal:</p>
<pre><code class="language-console">$ g++ -g test.cpp
$ 
</code></pre>
<p>插入中斷點</p>
<p>在要中斷的程式碼行號左邊點一下</p>
<p><img src="vscode_tutorial/img/insert_breakpoint.png" alt="insert breakpoint" /></p>
<p>In VSCode: <code>Run -&gt; Start Debugging F5</code></p>
<p><img src="vscode_tutorial/img/start_gdb.png" alt="start debugging" /></p>
<p><img src="vscode_tutorial/img/run_gdb.png" alt="run gdb" /></p>
<h2 id="設定-vscode-環境-windows--mingw"><a class="header" href="#設定-vscode-環境-windows--mingw">設定 VSCode 環境 (Windows + mingw)</a></h2>
<p>Modified from: <a href="https://github.com/CNOCycle/cpp_tutorial">CNOCycle/cpp_tutorial by E. Chen</a></p>
<h3 id="安裝步驟"><a class="header" href="#安裝步驟">安裝步驟</a></h3>
<ol>
<li>安裝 <a href="https://www.scoop.sh/">Scoop.sh</a></li>
<li>安裝 <code>mingw cmake</code></li>
<li>重新開啟 VSCode</li>
</ol>
<h3 id="圖解說明"><a class="header" href="#圖解說明">圖解說明</a></h3>
<h4 id="安裝-a-hrefhttpswwwscoopshscoopsha"><a class="header" href="#安裝-a-hrefhttpswwwscoopshscoopsha">安裝 <a href="https://www.scoop.sh/">Scoop.sh</a></a></h4>
<p>In VSCode: <code>Terminal -&gt; New Terminal</code></p>
<p><img src="vscode_tutorial/img/create_terminal.png" alt="create terminal" /></p>
<p>在 VSCode Terminal 中輸入:</p>
<pre><code class="language-powershell">Invoke-Expression (New-Object System.Net.WebClient).DownloadString('https://get.scoop.sh')
</code></pre>
<p>或簡易版指令</p>
<pre><code class="language-powershell">iwr -useb get.scoop.sh | iex
</code></pre>
<p><strong>Note:</strong> </p>
<p>如果遇到錯誤 (execution policy)，可能需要使用以下指令更改執行策略後重新執行安裝指令:</p>
<pre><code class="language-powershell">Set-ExecutionPolicy RemoteSigned -scope CurrentUser
</code></pre>
<p>如果遇到 &quot;無法建立 SSL/TLS 的安全通道。&quot; 問題，可能需要使用以下指令更改系統的 SSL 設定:</p>
<pre><code class="language-powershell">[System.Net.ServicePointManager]::SecurityProtocol = &quot;tls12, tls11&quot;
</code></pre>
<p>如果遇到 7zip 安裝失敗，可以先安裝 7zip 再安裝 mingw，以下是指令:</p>
<pre><code class="language-powershell">scoop install 7zip
scoop install mingw
</code></pre>
<h4 id="安裝-mingw-cmake"><a class="header" href="#安裝-mingw-cmake">安裝 <code>mingw cmake</code></a></h4>
<p>在 VSCode Terminal 中輸入:</p>
<pre><code class="language-powershell">scoop install mingw cmake
</code></pre>
<p><strong>Note:</strong> 安裝完成後須重新啟動 VSCode 才能生效</p>
<h3 id="測試編譯以及除錯-1"><a class="header" href="#測試編譯以及除錯-1">測試編譯以及除錯</a></h3>
<h4 id="測試編譯-1"><a class="header" href="#測試編譯-1">測試編譯</a></h4>
<ol>
<li>在 <code>%USERPROFILE%</code> 中新增一個資料夾，名稱可以自由取 (如 <code>test</code>)。</li>
</ol>
<p><strong>Note:</strong> 所有的路徑 (包含 <code>%USERPROFILE%</code>) 都不能有非英文的字元，否則 Debugger 會無法執行。
也可以在 <code>%USERPROFILE%</code> 外的資料夾中新增資料夾，如 <code>D:\test</code>。</p>
<p><img src="vscode_tutorial/img/fig_01-win-var.png" alt="create folder" /></p>
<ol>
<li>用 <code>vscode</code> 編輯器選擇開啟新增的資料夾 (以 <code>test</code> 為例)，如下圖示範：</li>
</ol>
<p><img src="vscode_tutorial/img/fig_05-open_vscode.png" alt="open folder 1" />
<img src="vscode_tutorial/img/fig_02-extract_files.png" alt="open folder 2" /></p>
<ol start="3">
<li>信任開啟檔案，選擇<code>Yes, I trust</code>，如下圖示範：</li>
</ol>
<p><img src="vscode_tutorial/./img/fig_06-trust_vscode.png" alt="trust_vscode" /></p>
<ol start="4">
<li>新增文件 <code>test.cpp</code>，如下圖示範：</li>
</ol>
<p>In VSCode: <code>Exploer -&gt; New File</code></p>
<p>輸入 <code>test.cpp</code></p>
<p><img src="vscode_tutorial/img/new_file.png" alt="new file icon" /></p>
<p>在文字輸入區輸入以下程式碼</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

using namespace std;

int main()
{
    vector&lt;string&gt; msg {&quot;Hello&quot;, &quot;C++&quot;, &quot;World&quot;, &quot;from&quot;, &quot;VS Code&quot;, &quot;and the C++ extension!&quot;};

    for (const string&amp; word : msg)
    {
        cout &lt;&lt; word &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
}
</code></pre>
<p><img src="vscode_tutorial/img/input_cpp.png" alt="input cpp code" /></p>
<ol start="5">
<li>在第 9 行左側按下去，會出現紅點，如下圖示範：</li>
</ol>
<p><img src="vscode_tutorial/img/insert_breakpoint.png" alt="insert breakpoint" /></p>
<ol start="6">
<li>按下<code>ctrl+shift+B</code>按鍵，或上方<code>terminal -&gt; Run Build Task</code>，如下圖示範：</li>
</ol>
<p><img src="vscode_tutorial/./img/fig_08-run_build_task.png" alt="run_build_task" /></p>
<ol start="7">
<li>此時上方會出現以下畫面，選擇中間選項使用 <strong>g++</strong> 編譯檔案，如下圖示範：</li>
</ol>
<p><img src="vscode_tutorial/./img/fig_09-build_hint.png" alt="build_hint" /></p>
<ol start="8">
<li>設置正確的話，此時下方會出現編譯成功完成的提示，如下圖示範：</li>
</ol>
<p><img src="vscode_tutorial/./img/fig_10-build_successfully.png" alt="build_successfully" /></p>
<h4 id="測試除錯-1"><a class="header" href="#測試除錯-1">測試除錯</a></h4>
<ol>
<li>
<p>完成前項<code>測試編譯</code>的所有流程</p>
</li>
<li>
<p>按下左方三角形按鈕後選擇<code>Run and Debug</code>，如下圖示範：</p>
</li>
</ol>
<p><img src="vscode_tutorial/./img/fig_11-open_debugger.png" alt="open_debugger" /></p>
<ol start="3">
<li>此時上方會依序出現相關提示，選擇預設的即可，如下圖示範：</li>
</ol>
<p><img src="vscode_tutorial/./img/fig_12-debuger_hint-1.png" alt="debuger_hint-1" />
<img src="vscode_tutorial/./img/fig_13-debuger_hint-2.png" alt="debuger_hint-2" /></p>
<ol start="4">
<li>若設定正確的話，會看到程式停留在選取的第 9 行，如下圖示範：</li>
</ol>
<p><img src="vscode_tutorial/img/run_gdb.png" alt="run gdb" /></p>
<p>Reference: </p>
<ul>
<li><a href="https://github.com/CNOCycle/cpp_tutorial">CNOCycle/cpp_tutorial by E. Chen</a></li>
<li><a href="https://code.visualstudio.com/docs/cpp/config-wsl">Get Started with C++ and Windows Subsystem for Linux in Visual Studio Code</a></li>
<li><a href="https://code.visualstudio.com/docs/cpp/config-mingw">Get Started with C++ and Mingw-w64 in Visual Studio Code</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
marp: true
author: Yi-Wen Hung
theme: default
headingDivider: 2
paginate: true
-->
<h1 id="sturcture-and-class"><a class="header" href="#sturcture-and-class">Sturcture and Class</a></h1>
<blockquote>
<p>Slides version: <a href="class/./lecture1_slides.html">lecture1_slides.html</a>
Website version: <a href="class/./lecture1.html">lecture1.html</a></p>
</blockquote>
<ul>
<li>Recap: Structure</li>
<li>What is a <em>Class</em>?</li>
<li>Difference between Class and Structure</li>
<li>VSCode Tutorial</li>
<li>Lab 1: Hello Class</li>
</ul>
<h2 id="recap-structure"><a class="header" href="#recap-structure">Recap: Structure</a></h2>
<p>Example: <a href="https://www.geeksforgeeks.org/structures-c/">Structures in C - GeeksforGeeks</a></p>
<pre><code class="language-c++">// A variable declaration with structure declaration.
struct Point
{
    int x, y;
} p1; // The variable p1 is declared with 'Point'

// A variable declaration like basic data types
struct Point
{
    int x, y;
};

int main()
{
    struct Point p1; // The variable p1 is declared like a normal variable
}
</code></pre>
<h2 id="how-to-initializemodify-a-structure"><a class="header" href="#how-to-initializemodify-a-structure">How to Initialize/Modify a Structure</a></h2>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

// A variable declaration like basic data types
struct Point
{
    int x, y;
};

void init_point(struct Point &amp;p);
void print_point(const struct Point &amp;p);
void modify_point(struct Point &amp;p);
</code></pre>
<hr />
<pre><code class="language-c++">int main()
{
    struct Point p1; // The variable p1 is declared like a normal variable

    init_point(p1);

    print_point(p1);

    modify_point(p1);

    print_point(p1);

    return 0;
}
</code></pre>
<hr />
<pre><code class="language-c++">void init_point(struct Point &amp;p)
{
    p.x = 10;
    p.y = 20;
}

void print_point(const struct Point &amp;p)
{
    std::cout &lt;&lt; &quot;(&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
}

void modify_point(struct Point &amp;p)
{
    p.x = 100;
    p.y = 200;
}
</code></pre>
<p>Output (in console):</p>
<pre><code class="language-console">$ ./a.out
(10, 20)
(100, 200)
</code></pre>
<h2 id="what-is-a-class"><a class="header" href="#what-is-a-class">What is a <em>Class</em>?</a></h2>
<blockquote>
<p>A user-defined datatype which groups together related pieces of information. </p>
</blockquote>
<p>-- <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-096-introduction-to-c-january-iap-2011/">Introduction to C++ | Electrical Engineering and Computer Science | MIT OpenCourseWare</a></p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<ul>
<li>Point on a 2D plane
<ul>
<li>x-coordinate</li>
<li>y-coordinate</li>
</ul>
</li>
</ul>
<h2 id="definition-of-class"><a class="header" href="#definition-of-class">Definition of Class</a></h2>
<pre><code class="language-c++">class Point
{
public:
    // Data members
    int x;
    int y;

    // Member functions
    void init();
    void print();
    void modify();
};
</code></pre>
<h2 id="difference-between-class-and-structure"><a class="header" href="#difference-between-class-and-structure">Difference between Class and Structure</a></h2>
<h3 id="definition"><a class="header" href="#definition">Definition</a></h3>
<pre><code class="language-c++">class Point                         struct Point
{                                   {
public:
    // Data members                 // Data members
    int x;                              int x;
    int y;                              int y;

    // Member functions                 // No Member functions
    void init();
    void print();
    void modify();
};                                  };
// Class usuallay don't use         // Structure usuallay use
// functions to manipulate          // functions to manipulate
// the data members                 // the data members
                                    void init_point(struct Point &amp;p);
                                    void print_point(const struct Point &amp;p);
                                    void modify_point(struct Point &amp;p);
</code></pre>
<hr />
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<pre><code class="language-c++">int main()                          int main()  
{                                   {
    Point p1;                           struct Point p1;

    p1.init();                          init_point(p1);

    p1.print();                         print_point(p1);

    p1.modify();                        modify_point(p1);

    p1.print();                         print_point(p1);

    return 0;                           return 0;
}                                   }
</code></pre>
<h1 id="a-hrefclassvscode_tutoriallab_1_vscode_315htmlvscode-tutoriala"><a class="header" href="#a-hrefclassvscode_tutoriallab_1_vscode_315htmlvscode-tutoriala"><a href="class/../vscode_tutorial/lab_1_vscode_315.html">VSCode Tutorial</a></a></h1>
<h1 id="lab-1-a-hrefclasslablab1htmlhello-classa"><a class="header" href="#lab-1-a-hrefclasslablab1htmlhello-classa">Lab 1: <a href="class/./lab/lab1.html">Hello Class</a></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-1-class-helloworld"><a class="header" href="#lab-1-class-helloworld">Lab 1: Class Helloworld</a></h1>
<h2 id="顯示-complex-class-的數字"><a class="header" href="#顯示-complex-class-的數字">顯示 Complex Class 的數字</a></h2>
<ul>
<li>輸入：無</li>
<li>輸出：顯示 Complex Class 的數字</li>
<li>檔名：<code>lab1_&lt;學號&gt;.cpp</code> (e.g. <code>lab1_106062802.cpp</code>)</li>
</ul>
<p>程式僅需輸出兩 complex 數字 a 及 b 以及 c = a + b 的結果。</p>
<h2 id="format"><a class="header" href="#format">Format</a></h2>
<pre><code class="language-text">(a) = a1 + a2 i
(b) = b1 + b2 i
(c) = a + b = c1 + c2 i
</code></pre>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<pre><code class="language-console">$ ./a.out
(a) = 1 + 2 i
(b) = 3 + -4 i
(c) = (a) + (b) = 4 + -2 i
</code></pre>
<h2 id="pseudo-code"><a class="header" href="#pseudo-code">Pseudo Code</a></h2>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Complex
{
public:
    int real;
    int imag;
    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Complex &amp;c)
    {
        os &lt;&lt; c.real &lt;&lt; &quot; + &quot; &lt;&lt; c.imag &lt;&lt; &quot; i&quot;;
        return os;
    }
    void print() const
    {
        // TODO: implement this function
        // Hint: use cout to print the complex number.
        // use 'real' and 'imag' as the real and imaginary part
        // of the complex number.
    }
    Complex &amp;operator+(const Complex &amp;c)
    {
        real += c.real;
        imag += c.imag;
        return *this;
    }
};

int main()
{
    Complex a, b, c;

    a.real = 1;
    a.imag = 2;
    cout &lt;&lt; &quot;(a) = &quot; &lt;&lt; a &lt;&lt; endl;

    b.real = 3;
    b.imag = -4;
    cout &lt;&lt; &quot;(b) = &quot;;
    b.print();
    cout &lt;&lt; endl;

    c = a + b;
    cout &lt;&lt; &quot;(c) = (a) + (b) = &quot; &lt;&lt; c &lt;&lt; endl;

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
marp: true
author: Yi-Wen Hung
theme: default
headingDivider: 2
paginate: true
-->
<h1 id="class-design-101"><a class="header" href="#class-design-101">Class Design 101</a></h1>
<blockquote>
<p>Slides version: <a href="class/./lecture2_slides.html">lecture2_slides.html</a>
Website version: <a href="class/./lecture2.html">lecture2.html</a></p>
</blockquote>
<ul>
<li>Recap: Hello Class</li>
<li>Class Definition</li>
<li>Class Instance</li>
<li>Class Usage/Member Function</li>
<li>Example: Triangle</li>
<li>Example: Vector</li>
</ul>
<h2 id="recap-hello-class"><a class="header" href="#recap-hello-class">Recap: Hello Class</a></h2>
<pre><code class="language-c++">class Point
{
public:
    // Data members
    int x;
    int y;

    // Member functions
    void init();
    void print();
    void modify();
};

int main()                          
{                                   
    Point p1;                       
    p1.init();                      
    p1.print();                     
    p1.modify();                    
    p1.print();                     

    return 0;                       
}
</code></pre>
<h2 id="class-definition"><a class="header" href="#class-definition">Class Definition</a></h2>
<p>Syntax:</p>
<pre><code class="language-c++">class Point // the class name
{
public: // public data members and member functions
        // Note: there is also private: and protected: sections.
        // we will discuss them in following lectures

    // Data members
    // as like as the data in a 'struct', you can have multiple 
    // variables in different types
    int x;
    int y;
};
</code></pre>
<h2 id="class-instance"><a class="header" href="#class-instance">Class Instance</a></h2>
<pre><code class="language-c++">int main()      
{               
    Point p1, p2;   
    // init 2 instances of Point
    p1.x = 0; p1.y = 0;
    p2.x = 0; p2.y = 0;

    // print 2 instances of Point
    cout &lt;&lt; &quot;p1: (&quot; &lt;&lt; p1.x &lt;&lt; &quot;, &quot; &lt;&lt; p1.y &lt;&lt; &quot;)&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;p2: (&quot; &lt;&lt; p2.x &lt;&lt; &quot;, &quot; &lt;&lt; p2.y &lt;&lt; &quot;)&quot; &lt;&lt; endl;

    // modify each instance
    // p1 and p2 are the same class, but they are different instances
    // so they can have different values
    p1.x = 1; p1.y = 2;
    p2.x = 3; p2.y = 4;
    
    // you can see the change in p1 and p2
    cout &lt;&lt; &quot;p1: (&quot; &lt;&lt; p1.x &lt;&lt; &quot;, &quot; &lt;&lt; p1.y &lt;&lt; &quot;)&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;p2: (&quot; &lt;&lt; p2.x &lt;&lt; &quot;, &quot; &lt;&lt; p2.y &lt;&lt; &quot;)&quot; &lt;&lt; endl;

    return 0;   
}               
</code></pre>
<hr />
<pre><code class="language-console">$ ./a.out
p1: (0, 0)
p2: (0, 0)
p1: (1, 2)
p2: (3, 4)
</code></pre>
<h2 id="class-usagemember-function"><a class="header" href="#class-usagemember-function">Class Usage/Member Function</a></h2>
<h3 id="class-as-a-argument"><a class="header" href="#class-as-a-argument">Class as a argument</a></h3>
<p>As like as struct, you can use a class instance as a argument to a function.</p>
<pre><code class="language-c++">void init_point(Point &amp;p)
{
    p.x = 0;
    p.y = 0;
}
void print_point(const Point &amp;p)
{
    cout &lt;&lt; &quot;(&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;;
}
void modify_point(Point &amp;p, const int&amp; arg_x, const int&amp; arg_y)
{
    p.x = arg_x;
    p.y = arg_y;
}
</code></pre>
<hr />
<pre><code class="language-c++">int main()      
{               
    Point p1, p2;   
    // init 2 instances of Point
    init_point(p1);
    init_point(p2);

    // print 2 instances of Point
    cout &lt;&lt; &quot;p1: &quot;; print_point(p1); cout &lt;&lt; endl;
    cout &lt;&lt; &quot;p2: &quot;; print_point(p2); cout &lt;&lt; endl;

    // modify each instance
    modify_point(p1, 1, 2);
    modify_point(p2, 3, 4);
    
    // you can see the change in p1 and p2
    cout &lt;&lt; &quot;p1: &quot;; print_point(p1); cout &lt;&lt; endl;
    cout &lt;&lt; &quot;p2: &quot;; print_point(p2); cout &lt;&lt; endl;

    return 0;   
}   
</code></pre>
<hr />
<h3 id="use-class-member-function"><a class="header" href="#use-class-member-function">Use class member function</a></h3>
<p>Instead of using extra functions, you can use member functions to manipulate the data.</p>
<hr />
<pre><code class="language-c++">class Point // the class name
{
public: // public data members and functions
        // Note: there is also private: and protected: sections.
        // we will discuss them in following lectures

    // Data members
    // as like as the data in a 'struct', you can have multiple 
    // variables in different types
    int x;
    int y;

    // Member functions
    // different from a 'struct', you can have multiple functions
    // in a class that related to the class
    void init() { x = 0; y = 0; }
    void print() { cout &lt;&lt; &quot;(&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;)&quot;; }
    void modify(const int&amp; arg_x, const int&amp; arg_y) { x = arg_x; y = arg_y; }
};
</code></pre>
<hr />
<pre><code class="language-c++">int main()      
{               
    Point p1, p2;   
    // init 2 instances of Point
    p1.init(); p2.init();

    // print 2 instances of Point
    p1.print(); p2.print();

    // modify each instance
    p1.modify(1, 2); p2.modify(3, 4); 

    // you can see the change in p1 and p2
    p1.print(); p2.print();

    return 0;   
}  
</code></pre>
<h2 id="example-triangle-a-hrefclasslecture2_ex1htmlsourcea"><a class="header" href="#example-triangle-a-hrefclasslecture2_ex1htmlsourcea">Example: Triangle [<a href="class/./lecture2_ex1.html">Source</a>]</a></h2>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Triangle
{
public:
    double x1, y1, x2, y2, x3, y3;

    void init();
    void print();
    void modify(double, double, double, double, double, double);
    double area();
};
</code></pre>
<hr />
<pre><code class="language-c++">void Triangle::init()
{
    x1 = 0;
    y1 = 0;
    x2 = 0;
    y2 = 0;
    x3 = 0;
    y3 = 0;
}

void Triangle::print()
{
    cout &lt;&lt; &quot;Triangle: &quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;(&quot; &lt;&lt; x1 &lt;&lt; &quot;, &quot; &lt;&lt; y1 &lt;&lt; &quot;)&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;(&quot; &lt;&lt; x2 &lt;&lt; &quot;, &quot; &lt;&lt; y2 &lt;&lt; &quot;)&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;(&quot; &lt;&lt; x3 &lt;&lt; &quot;, &quot; &lt;&lt; y3 &lt;&lt; &quot;)&quot; &lt;&lt; endl;
}
</code></pre>
<hr />
<pre><code class="language-c++">void Triangle::modify(double arg_x1, double arg_y1, double arg_x2,
                      double arg_y2, double arg_x3, double arg_y3)
{
    x1 = arg_x1;
    y1 = arg_y1;
    x2 = arg_x2;
    y2 = arg_y2;
    x3 = arg_x3;
    y3 = arg_y3;
}

double Triangle::area()
{
    return (x1 * y2 + x2 * y3 + x3 * y1 - x1 * y3 - x2 * y1 - x3 * y2) / 2;
}
</code></pre>
<hr />
<pre><code class="language-c++">int main()
{
    Triangle t;
    t.init();
    t.print();
    t.modify(1, 1, 2, 2, 0, 3);
    t.print();
    cout &lt;&lt; &quot;Area: &quot; &lt;&lt; t.area() &lt;&lt; endl;
    return 0;
}
</code></pre>
<hr />
<p>Output:</p>
<pre><code class="language-console">$ ./a.out
Triangle: 
(0, 0)
(0, 0)
(0, 0)
Triangle: 
(1, 1)
(2, 2)
(0, 3)
Area: 1.5
</code></pre>
<h2 id="example-vector-a-hrefclasslecture2_ex2htmlsourcea"><a class="header" href="#example-vector-a-hrefclasslecture2_ex2htmlsourcea">Example: Vector [<a href="class/./lecture2_ex2.html">Source</a>]</a></h2>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Vector
{
public:
    int x, y, z;

    void init();
    void print();
    void modify(int, int, int);
    int dot(const Vector &amp;);
    Vector cross(const Vector &amp;);
};
</code></pre>
<hr />
<pre><code class="language-c++">void Vector::init()
{
    x = 0;
    y = 0;
    z = 0;
}

void Vector::print()
{
    cout &lt;&lt; &quot;Vector: &quot;
         &lt;&lt; &quot;(&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;, &quot; &lt;&lt; z &lt;&lt; &quot;)&quot;;
}

void Vector::modify(int arg_x, int arg_y, int arg_z)
{
    x = arg_x;
    y = arg_y;
    z = arg_z;
}
</code></pre>
<hr />
<pre><code class="language-c++">int Vector::dot(const Vector &amp;arg_v)
{
    return x * arg_v.x + y * arg_v.y + z * arg_v.z;
}

Vector Vector::cross(const Vector &amp;arg_v)
{
    Vector v;
    v.x = y * arg_v.z - z * arg_v.y;
    v.y = z * arg_v.x - x * arg_v.z;
    v.z = x * arg_v.y - y * arg_v.x;
    return v;
}
</code></pre>
<hr />
<pre><code class="language-c++">int main()
{
    Vector v1, v2;
    v1.init();
    v1.print();
    cout &lt;&lt; endl;
    v1.modify(1, 1, 1);
    v1.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; endl;

    v2.init();
    v2.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; endl;
</code></pre>
<hr />
<pre><code class="language-c++">    v2.modify(2, 3, 4);
    cout &lt;&lt; &quot;v1: &quot;;
    v1.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;v2: &quot;;
    v2.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;Dot: &quot; &lt;&lt; v1.dot(v2) &lt;&lt; endl;
    cout &lt;&lt; endl;
</code></pre>
<hr />
<pre><code class="language-c++">    v2.modify(5, 6, 7);
    Vector v3 = v1.cross(v2);
    cout &lt;&lt; &quot;v1: &quot;;
    v1.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;v2: &quot;;
    v2.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;Cross: &quot;;
    v3.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; endl;

    return 0;
}
</code></pre>
<hr />
<p>Output:</p>
<pre><code class="language-console">Vector: (0, 0, 0)
Vector: (1, 1, 1)

Vector: (0, 0, 0)

v1: Vector: (1, 1, 1)
v2: Vector: (2, 3, 4)
Dot: 9

v1: Vector: (1, 1, 1)
v2: Vector: (5, 6, 7)
Cross: Vector: (1, -2, 1)
</code></pre>
<h2 id="pratices"><a class="header" href="#pratices">Pratices</a></h2>
<ul>
<li>Pratice 1: 參考 <code>Triangle</code> class, 如果四邊形、多邊形要如何設計？</li>
<li>Pratice 2: 參考 <code>Vector</code> class, 如果需要紀錄多維度的座標系上、或是轉換 basis 為其他 vector 要如何設計？</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-1-trangle"><a class="header" href="#example-1-trangle">Example 1: Trangle</a></h1>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Triangle
{
public:
    double x1, y1, x2, y2, x3, y3;

    void init();
    void print();
    void modify(double, double, double, double, double, double);
    double area();
};

void Triangle::init()
{
    x1 = 0;
    y1 = 0;
    x2 = 0;
    y2 = 0;
    x3 = 0;
    y3 = 0;
}

void Triangle::print()
{
    cout &lt;&lt; &quot;Triangle: &quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;(&quot; &lt;&lt; x1 &lt;&lt; &quot;, &quot; &lt;&lt; y1 &lt;&lt; &quot;)&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;(&quot; &lt;&lt; x2 &lt;&lt; &quot;, &quot; &lt;&lt; y2 &lt;&lt; &quot;)&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;(&quot; &lt;&lt; x3 &lt;&lt; &quot;, &quot; &lt;&lt; y3 &lt;&lt; &quot;)&quot; &lt;&lt; endl;
}

void Triangle::modify(double arg_x1, double arg_y1, double arg_x2,
                      double arg_y2, double arg_x3, double arg_y3)
{
    x1 = arg_x1;
    y1 = arg_y1;
    x2 = arg_x2;
    y2 = arg_y2;
    x3 = arg_x3;
    y3 = arg_y3;
}

double Triangle::area()
{
    return (x1 * y2 + x2 * y3 + x3 * y1 - x1 * y3 - x2 * y1 - x3 * y2) / 2;
}

int main()
{
    Triangle t;
    t.init();
    t.print();
    t.modify(1, 1, 2, 2, 0, 3);
    t.print();
    cout &lt;&lt; &quot;Area: &quot; &lt;&lt; t.area() &lt;&lt; endl;
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-2-vector"><a class="header" href="#example-2-vector">Example 2: Vector</a></h1>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Vector
{
public:
    int x, y, z;

    void init();
    void print();
    void modify(int, int, int);
    int dot(const Vector &amp;);
    Vector cross(const Vector &amp;);
};

void Vector::init()
{
    x = 0;
    y = 0;
    z = 0;
}

void Vector::print()
{
    cout &lt;&lt; &quot;Vector: &quot;
         &lt;&lt; &quot;(&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;, &quot; &lt;&lt; z &lt;&lt; &quot;)&quot;;
}

void Vector::modify(int arg_x, int arg_y, int arg_z)
{
    x = arg_x;
    y = arg_y;
    z = arg_z;
}

int Vector::dot(const Vector &amp;arg_v)
{
    return x * arg_v.x + y * arg_v.y + z * arg_v.z;
}

Vector Vector::cross(const Vector &amp;arg_v)
{
    Vector v;
    v.x = y * arg_v.z - z * arg_v.y;
    v.y = z * arg_v.x - x * arg_v.z;
    v.z = x * arg_v.y - y * arg_v.x;
    return v;
}

int main()
{
    Vector v1, v2;
    v1.init();
    v1.print();
    cout &lt;&lt; endl;
    v1.modify(1, 1, 1);
    v1.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; endl;

    v2.init();
    v2.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; endl;

    v2.modify(2, 3, 4);
    cout &lt;&lt; &quot;v1: &quot;;
    v1.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;v2: &quot;;
    v2.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;Dot: &quot; &lt;&lt; v1.dot(v2) &lt;&lt; endl;
    cout &lt;&lt; endl;

    v2.modify(5, 6, 7);
    Vector v3 = v1.cross(v2);
    cout &lt;&lt; &quot;v1: &quot;;
    v1.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;v2: &quot;;
    v2.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;Cross: &quot;;
    v3.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; endl;

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
marp: true
author: Yi-Wen Hung
theme: default
headingDivider: 2
paginate: true
-->
<h1 id="class-data-members--member-functions"><a class="header" href="#class-data-members--member-functions">Class Data Members &amp; Member Functions</a></h1>
<blockquote>
<p>Slides version: <a href="class/./lecture3_slides.html">lecture3_slides.html</a>
Website version: <a href="class/./lecture3.html">lecture3.html</a></p>
</blockquote>
<ul>
<li>Define Class Data Members &amp; Member Functions</li>
<li><code>public</code>, <code>private</code>, <code>protected</code> member
<ul>
<li>Kickstart of getter &amp; setter</li>
</ul>
</li>
<li><code>this</code> member</li>
<li>Variable scope in a class
<ul>
<li><code>::</code> scope resolution operator</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li><code>static</code> data member
<ul>
<li>Kickstart of constructor &amp; destructor </li>
</ul>
</li>
<li>Example 1: Triangle (again)</li>
<li>Example 2: Vector (again)</li>
<li>Example 3: Integer Calculator</li>
</ul>
<h2 id="define-class-data-members--member-functions"><a class="header" href="#define-class-data-members--member-functions">Define Class Data Members &amp; Member Functions</a></h2>
<ul>
<li>Why do we need data members?
<ul>
<li>To store data</li>
<li>Make data accessible</li>
</ul>
</li>
<li>Why do we need member functions?
<ul>
<li>To perform operations</li>
<li>Ease of access to data</li>
</ul>
</li>
</ul>
<hr />
<h3 id="design-data-members"><a class="header" href="#design-data-members">Design data members</a></h3>
<p>Guidelines:</p>
<ul>
<li>each data member should be seen only by its owner
<ul>
<li>if you want to access it, you need to use getter &amp; setter (discussed on next lecture)</li>
</ul>
</li>
<li>if you want a data member to be accessible by other classes, you should handle it carefully</li>
<li>the naming convention of data members should be consistent, meaningful, and easy to understand
<ul>
<li><code>_</code> is used to separate words</li>
<li><code>m_</code> is used to indicate a data member</li>
<li><code>arg_</code> is used to indicate an argument</li>
<li>etc.</li>
</ul>
</li>
</ul>
<hr />
<p>Example: <code>Point_2D</code></p>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Point_2D // the class name
// we use first upper case letter to indicate a class
{
private: // private data members
         // we will discuss it later
    // Data members
    // we use `m_` to indicate a data member

    // record the x coordinate
    int m_x;
    // record the y coordinate
    int m_y;
</code></pre>
<hr />
<pre><code class="language-c++">public: // public member functions
        // we will discuss in the next lecture
    
    // Member functions
    // we use lower case letter to indicate a member function
    // also, we just define the function declaration
    // and leave the definition to the end of the class

    // iniialize the x and y coordinate
    void init();
    // print the x and y coordinate
    void print();
    // modify the x and y coordinate
    // we use `arg_` to indicate the arguments
    void modify(const int &amp;arg_x, const int &amp;arg_y);
};
</code></pre>
<hr />
<pre><code class="language-c++">// function definition

// initialize the x and y coordinate
void Point_2D::init()
{
    m_x = 0;
    m_y = 0;
}
// print the x and y coordinate
void Point_2D::print()
{
    cout &lt;&lt; &quot;(&quot; &lt;&lt; m_x &lt;&lt; &quot;, &quot; &lt;&lt; m_y &lt;&lt; &quot;)&quot;;
}
// modify the x and y coordinate
// we use `arg_` to indicate the arguments
void Point_2D::modify(const int &amp;arg_x, const int &amp;arg_y)
{
    m_x = arg_x;
    m_y = arg_y;
}
</code></pre>
<hr />
<pre><code class="language-c++">// main function

int main()
{
    Point_2D p1, p2;
    // init 2 instances of Point
    p1.init();    p2.init();
    // print 2 instances of Point
    p1.print();   cout &lt;&lt; endl;
    p2.print();   cout &lt;&lt; endl;
    // modify each instance
    p1.modify(1, 2);
    p2.modify(3, 4);
    // you can see the change in p1 and p2
    p1.print();   cout &lt;&lt; endl;
    p2.print();   cout &lt;&lt; endl;
    return 0;
}
</code></pre>
<hr />
<h3 id="design-member-functions--discuss-on-next-lecture"><a class="header" href="#design-member-functions--discuss-on-next-lecture">Design member functions  (discuss on next lecture)</a></h3>
<p>Guidelines:</p>
<ul>
<li>each member function should show it's accessibility explicitly
<ul>
<li>'_' is used to indicate a member function used internally (<code>private</code>)</li>
<li>all other functions are public</li>
</ul>
</li>
<li>essential member functions should be defined in the class
<ul>
<li>getter &amp; setter</li>
<li>constructor &amp; destructor</li>
<li><code>operator=</code> (disscuss on later lecture)</li>
</ul>
</li>
<li>etc.</li>
</ul>
<h2 id="public-private-protected-member"><a class="header" href="#public-private-protected-member"><code>public</code>, <code>private</code>, <code>protected</code> member</a></h2>
<p>To identify the accessibility of a member, we use <code>public</code>, <code>private</code>, and <code>protected</code> keywords.</p>
<ul>
<li><code>public</code> data members is accessible by other classes.</li>
<li><code>private</code> data members is accessible only by its owner.</li>
<li><code>protected</code> data members is accessible by other inherited classes and its owner. (discuss in lecture 8)</li>
</ul>
<hr />
<h3 id="public-member"><a class="header" href="#public-member"><code>public</code> member</a></h3>
<p>Same as <code>struct</code>.</p>
<pre><code class="language-c++">class Point // the class name
{
public: 

    // public data members
    // we can access them directly by use `.` operator
    int m_x;
    int m_y;
};

int main()
{
    Point p1;
    // init p1
    p1.m_x = 1;
    p1.m_y = 2;
    // print p1
    cout &lt;&lt; &quot;(&quot; &lt;&lt; p1.m_x &lt;&lt; &quot;, &quot; &lt;&lt; p1.m_y &lt;&lt; &quot;)&quot; &lt;&lt; endl;
    return 0;
}
</code></pre>
<hr />
<h3 id="private-member"><a class="header" href="#private-member"><code>private</code> member</a></h3>
<p>Different from <code>struct</code>, <code>private</code> member is not accessible by other classes or functions.</p>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

// Point_2D class
class Point_2D
{
private: // private data members
    // record the x coordinate
    int m_x;
    // record the y coordinate
    int m_y;

public: // public member functions
    // iniialize the x and y coordinate
    void init();
    // print the x and y coordinate
    void print();
    // modify the x and y coordinate
    void modify(const int &amp;arg_x, const int &amp;arg_y);
    // modify the point by another point
    void modify(const Point_2D &amp;arg_point);
};
</code></pre>
<hr />
<pre><code class="language-c++">// Point_2D_2 class
class Point_2D_2
{
private: // private data members
    // record the x coordinate
    int m_x;
    // record the y coordinate
    int m_y;

public: // public member functions
    // iniialize the x and y coordinate
    void init();
    // print the x and y coordinate
    void print();
    // modify the x and y coordinate
    void modify(const int &amp;arg_x, const int &amp;arg_y);
    // modify the point by another point
    // NOTE: compile error
    void modify(const Point_2D &amp;arg_point);
};
</code></pre>
<hr />
<pre><code class="language-c++">// function definition

// Point_2D class
// initialize the x and y coordinate
void Point_2D::init()
{
    m_x = 0;
    m_y = 0;
}
// print the x and y coordinate
void Point_2D::print()
{
    cout &lt;&lt; &quot;(&quot; &lt;&lt; m_x &lt;&lt; &quot;, &quot; &lt;&lt; m_y &lt;&lt; &quot;)&quot;;
}
// modify the x and y coordinate
void Point_2D::modify(const int &amp;arg_x, const int &amp;arg_y)
{
    m_x = arg_x;
    m_y = arg_y;
}
// modify the point by another point
void Point_2D::modify(const Point_2D &amp;arg_point)
{
    m_x = arg_point.m_x;
    m_y = arg_point.m_y;
}
</code></pre>
<hr />
<pre><code class="language-c++">// Point_2D_2 class
// initialize the x and y coordinate
void Point_2D_2::init()
{
    m_x = 0;
    m_y = 0;
}
// print the x and y coordinate
void Point_2D_2::print()
{
    cout &lt;&lt; &quot;(&quot; &lt;&lt; m_x &lt;&lt; &quot;, &quot; &lt;&lt; m_y &lt;&lt; &quot;)&quot;;
}
// modify the x and y coordinate
void Point_2D_2::modify(const int &amp;arg_x, const int &amp;arg_y)
{
    m_x = arg_x;
    m_y = arg_y;
}
// modify the point by another point
void Point_2D_2::modify(const Point_2D &amp;arg_point)
{
    // compile error, error: 'm_x' is a private member of 'Point_2D'
    // need to use getter (discuss on the next lecture)
    m_x = arg_point.m_x;
    m_y = arg_point.m_y;
}
</code></pre>
<hr />
<pre><code class="language-c++">// main function

int main()
{
    Point_2D point1;
    Point_2D_2 point2;

    point1.init();
    point2.init();

    point1.print();    cout &lt;&lt; endl;
    point2.print();    cout &lt;&lt; endl;

    point1.modify(1, 2);
    point2.modify(point1);

    point1.print();    cout &lt;&lt; endl;
    point2.print();    cout &lt;&lt; endl;

    return 0;
}
</code></pre>
<h2 id="this-data-member"><a class="header" href="#this-data-member"><code>this</code> data member</a></h2>
<p>To access the data members of current class explicitly, we use <code>this</code> keyword.</p>
<p>Usage: (inside the class definition)</p>
<pre><code class="language-c++">void Point_2D::init()
{
    // access the data members of current class
    this-&gt;m_x = 0;
    this-&gt;m_y = 0;
}
</code></pre>
<hr />
<p>Example: <code>Point_2D</code> (use <code>this</code>)</p>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Point_2D
{
private: // private data members
    // record the x coordinate
    int m_x;
    // record the y coordinate
    int m_y;
public: // public member functions
    // iniialize the x and y coordinate
    void init();
    // print the x and y coordinate
    void print();
    // modify the x and y coordinate
    void modify(const int &amp;arg_x, const int &amp;arg_y);
};
</code></pre>
<hr />
<pre><code class="language-c++">// function definition

// initialize the x and y coordinate
void Point_2D::init()
{
    // initialize the x coordinate
    // NOTE: this is a pointer to the current object
    //       so we can use this-&gt; to access the private data member
    this-&gt;m_x = 0;
    // initialize the y coordinate
    // NOTE: this-&gt; is equivalent to (*this)
    (*this).m_y = 0;
}
// print the x and y coordinate
void Point_2D::print()
{
    cout &lt;&lt; &quot;(&quot; &lt;&lt; this-&gt;m_x &lt;&lt; &quot;, &quot; &lt;&lt; this-&gt;m_y &lt;&lt; &quot;)&quot;;
}
// modify the x and y coordinate
void Point_2D::modify(const int &amp;arg_x, const int &amp;arg_y)
{
    this-&gt;m_x = arg_x;
    this-&gt;m_y = arg_y;
}
</code></pre>
<hr />
<pre><code class="language-c++">// main function

int main()
{
    Point_2D p1, p2;
    // init 2 instances of Point
    p1.init();    p2.init();
    // print 2 instances of Point
    p1.print();   cout &lt;&lt; endl;
    p2.print();   cout &lt;&lt; endl;
    // modify each instance
    p1.modify(1, 2);
    p2.modify(3, 4);
    // you can see the change in p1 and p2
    p1.print();   cout &lt;&lt; endl;
    p2.print();   cout &lt;&lt; endl;
    return 0;
}
</code></pre>
<h2 id="variable-scope-in-a-class"><a class="header" href="#variable-scope-in-a-class">Variable scope in a class</a></h2>
<p>Reference: <a href="https://www.geeksforgeeks.org/scope-resolution-operator-in-c/">Scope resolution operator in C++ - GeeksforGeeks</a></p>
<ul>
<li>Which variables are accessible in a member function?
<ul>
<li>data members</li>
<li>local variables</li>
<li>global variables (Ref: <a href="https://stevenokm.github.io/i2p-nthu-math/i2p1/function/lecture_11.html#variable-scope--lifetime">Lecture 11: Function &amp; Reference (2)</a>)</li>
<li>function arguments</li>
</ul>
</li>
</ul>
<hr />
<p>Example:</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

int a = 1;

class A
{
public:
    int a;
    void f()
    {
        a = a; // how to access global variable a?
    }
};

int main()
{
    A a;
    a.f();
    return 0;
}
</code></pre>
<hr />
<h3 id="-scope-resolution-operator"><a class="header" href="#-scope-resolution-operator"><code>::</code> scope resolution operator</a></h3>
<p>Usage: Global variable</p>
<pre><code class="language-c++">// C++ program to show that we can access a global variable
// using scope resolution operator :: when there is a local
// variable with same name
#include &lt;iostream&gt;
using namespace std;

int x; // Global x

int main()
{
    int x = 10; // Local x
    cout &lt;&lt; &quot;Value of global x is &quot; &lt;&lt; ::x;
    cout &lt;&lt; &quot;\nValue of local x is &quot; &lt;&lt; x;
    return 0;
}
</code></pre>
<hr />
<p>Usage: Function name</p>
<pre><code class="language-c++">// C++ program to show that scope resolution operator :: is used
// to define a function outside a class
#include &lt;iostream&gt;
using namespace std;

class A
{
public:
    // Only declaration
    void fun();
};

// Definition outside class using ::
void A::fun()
{
    cout &lt;&lt; &quot;fun() called&quot;;
}

int main()
{
    A a;
    a.fun();
    return 0;
}
</code></pre>
<hr />
<p>Example: </p>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

int global_a = 1;
// a = 1;

class A
{
public:
    int local_a;
    // int a;
    void f()
    {
        local_a = ::global_a;
        // a = ::a;
    }
};

int main()
{
    A a;
    a.f();
    return 0;
}
</code></pre>
<hr />
<h3 id="case-a-class-in-a-class"><a class="header" href="#case-a-class-in-a-class">Case: a class in a class</a></h3>
<pre><code class="language-c++">// Use of scope resolution class inside another class.
#include &lt;iostream&gt;
using namespace std;

class outside
{
public:
    int x;
    class inside
    {
    public:
        int x;
        static int y; // we talk it later
        int foo();
    };
};
int outside::inside::y = 5;

int main()
{
    outside A;
    outside::inside B;
}
</code></pre>
<h2 id="static-data-member"><a class="header" href="#static-data-member"><code>static</code> data member</a></h2>
<p>Reference: <a href="https://www.geeksforgeeks.org/static-keyword-cpp/">Static Keyword in C++ - GeeksforGeeks</a></p>
<p>To maintain the status of a class or save memory usage, we use <code>static</code> data member.</p>
<p>Note: the value of a <code>static</code> variable is shared during the entire execution of the program and will initialize only once.</p>
<hr />
<pre><code class="language-c++">// C++ program to demonstrate
// the use of static Static
// variables in a Function
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

void demo()
{
    // static variable
    static int count = 0;
    cout &lt;&lt; count &lt;&lt; &quot; &quot;;

    // value is updated and
    // will be carried to next
    // function calls
    count++;
}

int main()
{
    for (int i = 0; i &lt; 5; i++)
        demo();
    return 0;
}
</code></pre>
<hr />
<h3 id="example-static-data-member"><a class="header" href="#example-static-data-member">Example: static data member</a></h3>
<p>Note: <code>static</code> data member will share the same value for all instances of the class.</p>
<pre><code class="language-c++">// C++ program to demonstrate static
// variables inside a class

#include &lt;iostream&gt;
using namespace std;

class GfG
{
public:
    static int i;

    GfG(){
        // Default constructor
        // we will discuss this in the next lecture
    };
};

// static data member should be initialized in global scope
int GfG::i = 1;
  
int main()
{
    GfG obj;
    // prints value of i
    cout &lt;&lt; obj.i; 
}
</code></pre>
<hr />
<h3 id="initialize-static-data-member-is-important"><a class="header" href="#initialize-static-data-member-is-important">Initialize <code>static</code> data member is important</a></h3>
<p>Without initializing <code>static</code> data member, the compiler will not know the value of <code>static</code> data member.</p>
<pre><code class="language-c++">// C++ program to demonstrate static
// variables inside a class

#include &lt;iostream&gt;
using namespace std;

class GfG
{
public:
    static int i;
};

int main()
{
    GfG obj;
    // prints value of i
    cout &lt;&lt; obj.i &lt;&lt; endl;
}
</code></pre>
<h2 id="example-1-triangle-again-a-hrefclasslecture3_ex1htmlsourcea"><a class="header" href="#example-1-triangle-again-a-hrefclasslecture3_ex1htmlsourcea">Example 1: Triangle (again) [<a href="class/./lecture3_ex1.html">Source</a>]</a></h2>
<p>A Triangle:</p>
<ul>
<li>contains 3 points</li>
<li>on the 2D plane</li>
<li>need to be able to calculate the area</li>
<li>need to be initialized, printed, and modified</li>
</ul>
<h2 id="example-2-vector-again-a-hrefclasslecture3_ex2htmlsourcea"><a class="header" href="#example-2-vector-again-a-hrefclasslecture3_ex2htmlsourcea">Example 2: Vector (again) [<a href="class/./lecture3_ex2.html">Source</a>]</a></h2>
<p>A Vector:</p>
<ul>
<li>contains 3 factors of the 3 basis $\bold{i}$, $\bold{j}$, $\bold{k}$</li>
<li>need to be able to calculate the length</li>
<li>need to be able to calculate the dot, cross product</li>
<li>need to be initialized, printed, and modified</li>
</ul>
<h2 id="example-3-integer-calculator-a-hrefclasslecture3_ex3htmlsourcea"><a class="header" href="#example-3-integer-calculator-a-hrefclasslecture3_ex3htmlsourcea">Example 3: Integer Calculator [<a href="class/./lecture3_ex3.html">Source</a>]</a></h2>
<p>A Integer Calculator:</p>
<ul>
<li>contains current value, input value, and operation</li>
<li>neet to be able to set the input value</li>
<li>neet to be able to set the operation</li>
<li>neet to be able to calculate the result</li>
<li>neet to be able to clear the input value</li>
<li>need to be initialized</li>
<li>need to be able to get all information</li>
</ul>
<h2 id="pratices-1"><a class="header" href="#pratices-1">Pratices</a></h2>
<ul>
<li>Pratice 1: 參考 <code>Triangle</code> class, 如果四邊形、多邊形要如何設計要儲存的變數？</li>
<li>Pratice 2: 參考 <code>Vector</code> class, 如果需要支援多維度的座標系上、或是轉換 basis 為其他 vector 要如何設計儲存的變數？</li>
<li>Pratice 3: 參考 <code>Integer Calculator</code> class, 如果需要支援 <code>M+</code> 運算要如何設計相關變數？</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-1-trangle-1"><a class="header" href="#example-1-trangle-1">Example 1: Trangle</a></h1>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

// Triangle class declaration
class Triangle
{
private:
    // define three points of the triangle
    // in x1, y1, x2, y2, x3, y3 format
    double m_x1, m_y1, m_x2, m_y2, m_x3, m_y3;

public:
    // initialize the triangle
    void init();
    // print the triangle
    void print();
    // modify the three points of the triangle
    void modify(double, double, double,
                double, double, double);
    // calculate the area of the triangle
    double area();
};

// Triangle class implementation

// initialize the triangle
void Triangle::init()
{
    // initialize the three points of the triangle
    m_x1 = 0.0;
    m_y1 = 0.0;
    m_x2 = 1.0;
    m_y2 = 0.0;
    m_x3 = 0.0;
    m_y3 = 1.0;
}

// print the triangle
void Triangle::print()
{
    // print the three points of the triangle
    cout &lt;&lt; &quot;Triangle: &quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;(&quot; &lt;&lt; m_x1 &lt;&lt; &quot;, &quot; &lt;&lt; m_y1 &lt;&lt; &quot;)&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;(&quot; &lt;&lt; m_x2 &lt;&lt; &quot;, &quot; &lt;&lt; m_y2 &lt;&lt; &quot;)&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;(&quot; &lt;&lt; m_x3 &lt;&lt; &quot;, &quot; &lt;&lt; m_y3 &lt;&lt; &quot;)&quot; &lt;&lt; endl;
}

// modify the three points of the triangle
void Triangle::modify(double arg_x1, double arg_y1,
                      double arg_x2, double arg_y2,
                      double arg_x3, double arg_y3)
{
    // modify the three points of the triangle
    m_x1 = arg_x1;
    m_y1 = arg_y1;
    m_x2 = arg_x2;
    m_y2 = arg_y2;
    m_x3 = arg_x3;
    m_y3 = arg_y3;
}

// calculate the area of the triangle
double Triangle::area()
{
    // calculate the area of the triangle
    return (m_x1 * (m_y2 - m_y3) + m_x2 * (m_y3 - m_y1) + m_x3 * (m_y1 - m_y2)) / 2.0;
}

// main function

int main()
{
    Triangle t;
    t.init();
    t.print();
    t.modify(1, 1, 2, 2, 0, 3);
    t.print();
    cout &lt;&lt; &quot;Area: &quot; &lt;&lt; t.area() &lt;&lt; endl;
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-2-vector-1"><a class="header" href="#example-2-vector-1">Example 2: Vector</a></h1>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;

// Vector class declaration
class Vector
{
private:
    // define the three factor of the basis vectors
    // on the x, y, z axes
    double m_x, m_y, m_z;

public:
    // initialize the vector
    void init();
    // print the vector
    void print();
    // modify the three factor of the basis vectors
    void modify(double, double, double);
    // calculate the length of the vector
    double length();
    // calculate the dot product of two vectors
    int dot(const Vector &amp;);
    // calculate the cross product of two vectors
    Vector cross(const Vector &amp;);
};

// initialize the vector
void Vector::init()
{
    // initialize the three factor of the basis vectors
    m_x = 0.0;
    m_y = 0.0;
    m_z = 0.0;
}

// print the vector
void Vector::print()
{
    // print the three factor of the basis vectors
    cout &lt;&lt; &quot;Vector: &quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;(&quot; &lt;&lt; m_x &lt;&lt; &quot;, &quot; &lt;&lt; m_y &lt;&lt; &quot;, &quot; &lt;&lt; m_z &lt;&lt; &quot;)&quot; &lt;&lt; endl;
}

// modify the three factor of the basis vectors
void Vector::modify(double arg_x, double arg_y, double arg_z)
{
    // modify the three factor of the basis vectors
    m_x = arg_x;
    m_y = arg_y;
    m_z = arg_z;
}

// calculate the length of the vector
double Vector::length()
{
    // calculate the length of the vector
    return sqrt(m_x * m_x + m_y * m_y + m_z * m_z);
}

// calculate the dot product of two vectors
int Vector::dot(const Vector &amp;arg_v)
{
    // calculate the dot product of two vectors
    return m_x * arg_v.m_x + m_y * arg_v.m_y + m_z * arg_v.m_z;
}

// calculate the cross product of two vectors
Vector Vector::cross(const Vector &amp;arg_v)
{
    // calculate the cross product of two vectors
    Vector v;
    v.m_x = m_y * arg_v.m_z - m_z * arg_v.m_y;
    v.m_y = m_z * arg_v.m_x - m_x * arg_v.m_z;
    v.m_z = m_x * arg_v.m_y - m_y * arg_v.m_x;
    return v;
}

// main function

int main()
{
    Vector v1, v2;
    v1.init();
    v1.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;Length of v1: &quot; &lt;&lt; v1.length() &lt;&lt; endl;
    v1.modify(1, 1, 1);
    v1.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;Length of v1: &quot; &lt;&lt; v1.length() &lt;&lt; endl;
    cout &lt;&lt; endl;

    v2.init();
    v2.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;Length of v2: &quot; &lt;&lt; v2.length() &lt;&lt; endl;
    v2.modify(2, 3, 4);
    v2.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;Length of v2: &quot; &lt;&lt; v2.length() &lt;&lt; endl;
    cout &lt;&lt; endl;

    cout &lt;&lt; &quot;v1: &quot;;
    v1.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;v2: &quot;;
    v2.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;Dot: &quot; &lt;&lt; v1.dot(v2) &lt;&lt; endl;
    cout &lt;&lt; endl;

    v2.modify(5, 6, 7);
    Vector v3 = v1.cross(v2);
    cout &lt;&lt; &quot;v1: &quot;;
    v1.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;v2: &quot;;
    v2.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;Cross: &quot;;
    v3.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; endl;

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-3-integer-calculator"><a class="header" href="#example-3-integer-calculator">Example 3: Integer Calculator</a></h1>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

// Triangle class declaration
class Int_Calc
{
private:
    // define current value
    long m_curr_val;
    // define input value
    long m_input_val;
    // define operation
    // `+`, `-`, `*`, `/`, and ` ` for none
    char m_op;
    // calculate result
    void _calc_result(); // private function, discuss in the next lecture

public:
    // clear the input value
    void clear();
    // clear the entire class
    void init();
    // set the input value
    void set_input(long arg_input);
    // add the input value to the current value
    void add();
    // subtract the input value from the current value
    void sub();
    // multiply the input value with the current value
    void mul();
    // divide the current value by the input value
    void div();
    // assign the input value to the current value
    void assign();
    // get the current value
    long get_curr_val();
    // get the current operation
    char get_op();
    // get the input value
    long get_input_val();
};

// Int_Calc class implementation

// calculate the result
void Int_Calc::_calc_result()
{
    switch (m_op)
    {
    case '+':
        m_curr_val += m_input_val;
        break;
    case '-':
        m_curr_val -= m_input_val;
        break;
    case '*':
        m_curr_val *= m_input_val;
        break;
    case '/':
        m_curr_val /= m_input_val;
        break;
    case ' ':
        m_curr_val = m_input_val;
        break;
    default:
        break;
    }
}

// clear the input value
void Int_Calc::clear()
{
    m_input_val = 0;
}

// clear the entire class
void Int_Calc::init()
{
    m_curr_val = 0;
    m_input_val = 0;
    m_op = ' ';
}

// set the input value
void Int_Calc::set_input(long arg_input)
{
    m_input_val = arg_input;
}

// add the input value to the current value
void Int_Calc::add()
{
    _calc_result();
    m_op = '+';
}

// subtract the input value from the current value
void Int_Calc::sub()
{
    _calc_result();
    m_op = '-';
}

// multiply the input value with the current value
void Int_Calc::mul()
{
    _calc_result();
    m_op = '*';
}

// divide the current value by the input value
void Int_Calc::div()
{
    _calc_result();
    m_op = '/';
}

// assign the input value to the current value
void Int_Calc::assign()
{
    _calc_result();
    m_op = ' ';
}

// get the current value
long Int_Calc::get_curr_val()
{
    return m_curr_val;
}

// get the current operation
char Int_Calc::get_op()
{
    return m_op;
}

// get the input value
long Int_Calc::get_input_val()
{
    return m_input_val;
}

// main function

int main()
{
    // create an instance of the class
    Int_Calc calc;
    // initialize the class
    calc.init();
    // set the input value
    calc.set_input(10);
    // get the input value
    cout &lt;&lt; calc.get_input_val() &lt;&lt; endl;
    // add the input value to the current value
    calc.add();
    // get current op
    cout &lt;&lt; '\'' &lt;&lt; calc.get_op() &lt;&lt; '\'' &lt;&lt; endl;
    // set another input value
    calc.set_input(20);
    // get the input value
    cout &lt;&lt; calc.get_input_val() &lt;&lt; endl;
    // clear the input value
    calc.clear();
    // set the input value
    calc.set_input(30);
    // get the input value
    cout &lt;&lt; calc.get_input_val() &lt;&lt; endl;
    // compute the result
    calc.assign();
    // print the result
    cout &lt;&lt; calc.get_curr_val() &lt;&lt; endl;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
marp: true
author: Yi-Wen Hung
theme: default
headingDivider: 2
paginate: true
-->
<h1 id="class-constructor--modifer"><a class="header" href="#class-constructor--modifer">Class Constructor &amp; Modifer</a></h1>
<blockquote>
<p>Slides version: <a href="class/./lecture4_slides.html">lecture4_slides.html</a>
Website version: <a href="class/./lecture4.html">lecture4.html</a></p>
</blockquote>
<ul>
<li>Define Class Data Members &amp; Member Functions (again)</li>
<li>How to initialize and modify class members?</li>
<li>Class constructor &amp; copy constructor</li>
<li>Class getter &amp; setter
<ul>
<li>Access <code>public</code>, <code>private</code>, members</li>
</ul>
</li>
<li>Class destructor</li>
</ul>
<hr />
<ul>
<li><code>const</code> function &amp; <code>const</code> class instance</li>
<li>Member function &amp; Global function</li>
<li>How to design class interface?
<ul>
<li>Example: Triangle (again)</li>
<li>Example: Vector (again)</li>
<li>Example: Integer Calculator (again)</li>
</ul>
</li>
<li>Lab 4: Complex Number</li>
</ul>
<h2 id="define-class-data-members--member-functions-1"><a class="header" href="#define-class-data-members--member-functions-1">Define Class Data Members &amp; Member Functions</a></h2>
<ul>
<li>Why do we need data members?
<ul>
<li>To store data</li>
<li>Make data accessible</li>
</ul>
</li>
<li><strong>Why do we need member functions?</strong>
<ul>
<li>To perform operations</li>
<li>Ease of access to data</li>
</ul>
</li>
</ul>
<hr />
<h3 id="design-member-functions"><a class="header" href="#design-member-functions">Design member functions</a></h3>
<p>Guidelines:</p>
<ul>
<li>each member function should show it's accessibility explicitly
<ul>
<li>'_' is used to indicate a member function used internally (<code>private</code>)</li>
<li>all other functions are public</li>
</ul>
</li>
<li>essential member functions should be defined in the class
<ul>
<li>getter &amp; setter</li>
<li>constructor &amp; destructor</li>
<li><code>operator=</code> (disscuss on later lecture)</li>
<li>etc.</li>
</ul>
</li>
<li>utility functions are usually for in-class use
<ul>
<li>utility functions are used to help other member functions and make it reusable, readable, and maintainable</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>naming of member functions should be consistent with the class name
<ul>
<li><code>get_</code> for getter</li>
<li><code>set_</code> for setter</li>
<li><code>is_</code> for predicate</li>
<li><code>has_</code> for predicate</li>
<li><code>add_</code> for mutator</li>
<li><code>remove_</code> for mutator</li>
<li><code>clear_</code> for mutator</li>
<li><code>size_</code> for predicate</li>
<li><code>to_string_</code> for predicate</li>
<li><code>from_string_</code> for mutator</li>
<li>etc.</li>
</ul>
</li>
</ul>
<hr />
<p>Example: <code>Point_2D</code></p>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Point_2D // the class name
// we use first upper case letter to indicate a class
{
private: // private data members &amp; member functions
    // Data members
    // we use `m_` to indicate a data member

    // record the x coordinate
    int m_x;
    // record the y coordinate
    int m_y;

    // Member functions
    // we use `_` to indicate a member function

    // check if the point is valid
    void _check_validity();
</code></pre>
<hr />
<pre><code class="language-c++">public: // public member functions
    // Constructor

    // Constructor &amp; Default constructor
    // initialize data members, with default values
    // accessable to const object by default
    Point_2D(const int &amp;arg_x = 0, const int &amp;arg_y = 0);

    // Copy constructor
    // copy the data members from the given object
    // accessable to const object by default
    Point_2D(const Point_2D &amp;arg_point);

    // Destructor
    ~Point_2D() // destructor
    {
        // do nothing, because we don't
        // have any dynamic memory
    }
</code></pre>
<hr />
<pre><code class="language-c++">    // Member functions
    // we use lower case letter to indicate a member function
    // also, we just define the function declaration
    // and leave the definition to the end of the class

    // print the x and y coordinate in format (x, y)
    // accessable to const object
    void print() const;
    // modify the x and y coordinate
    // we use `arg_` to indicate the arguments
    // and re-write with setter
    void set_x(const int &amp;arg_x);
    void set_y(const int &amp;arg_y);
    void set(const int &amp;arg_x, const int &amp;arg_y);
    // get the x coordinate and y coordinate
    // accessable to const object
    int get_x() const;
    int get_y() const;
};
</code></pre>
<hr />
<pre><code class="language-c++">// function definition

// check if the point is valid
void Point_2D::_check_validity()
{
    // check if the x coordinate is valid
    if (m_x &lt; 0)
    {
        // if not, set it to 0
        m_x = 0;
    }
    // check if the y coordinate is valid
    if (m_y &lt; 0)
    {
        // if not, set it to 0
        m_y = 0;
    }
}
</code></pre>
<hr />
<pre><code class="language-c++">// Constructor &amp; Default constructor
// initialize data members, with default values
Point_2D::Point_2D(const int &amp;arg_x, const int &amp;arg_y)
// use `: var_name1(arg_var_name1), var_name2(arg_var_name2)`
// to initialize data members
    : m_x(arg_x),
      m_y(arg_y)
{
    // check if the point is valid
    _check_validity();
}

// Copy constructor
// copy the data members from the given object
Point_2D::Point_2D(const Point_2D &amp;arg_point)
    : m_x(arg_point.m_x),
      m_y(arg_point.m_y)
{
    // check if the point is valid
    _check_validity();
}
</code></pre>
<hr />
<pre><code class="language-c++">// print the x and y coordinate
// accessable to const object
void Point_2D::print() const
{
    cout &lt;&lt; &quot;(&quot; &lt;&lt; m_x &lt;&lt; &quot;, &quot; &lt;&lt; m_y &lt;&lt; &quot;)&quot;;
}

// modify the x and y coordinate
// we use `arg_` to indicate the arguments
// and re-write with setter
void Point_2D::set_x(const int &amp;arg_x)
{
    m_x = arg_x;
    // check if the point is valid
    _check_validity();
}
void Point_2D::set_y(const int &amp;arg_y)
{
    m_y = arg_y;
    // check if the point is valid
    _check_validity();
}
</code></pre>
<hr />
<pre><code class="language-c++">void Point_2D::set(const int &amp;arg_x, const int &amp;arg_y)
{
    m_x = arg_x;
    m_y = arg_y;
    // check if the point is valid
    _check_validity();
}

// get the x coordinate and y coordinate
// accessable to const object
int Point_2D::get_x() const
{
    return m_x;
}
int Point_2D::get_y() const
{
    return m_y;
}
</code></pre>
<hr />
<pre><code class="language-c++">// main function

int main()
{
    // create a Point_2D object with initial values
    Point_2D p1(1, 2);
    // or create with another Point_2D object
    Point_2D p2(p1);
    // print 2 instances of Point
    p1.print();
    cout &lt;&lt; endl;
    // or use getter
    cout &lt;&lt; &quot;(&quot; &lt;&lt; p2.get_x() &lt;&lt; &quot;, &quot;
         &lt;&lt; p2.get_y() &lt;&lt; &quot;)&quot; &lt;&lt; endl;
</code></pre>
<hr />
<pre><code class="language-c++">    // modify each instance with setter
    p1.set(3, 4);
    p2.set_x(5);
    p2.set_y(6);
    // you can see the change in p1 and p2
    p1.print();
    cout &lt;&lt; endl;
    // or use getter
    cout &lt;&lt; &quot;(&quot; &lt;&lt; p2.get_x() &lt;&lt; &quot;, &quot;
         &lt;&lt; p2.get_y() &lt;&lt; &quot;)&quot; &lt;&lt; endl;
    return 0;
}
</code></pre>
<h2 id="how-to-initialize-and-modify-class-members"><a class="header" href="#how-to-initialize-and-modify-class-members">How to initialize and modify class members?</a></h2>
<ul>
<li>To initialize class members, we use constructor.
<ul>
<li>The constructor is a function that is called when an object is created.</li>
</ul>
</li>
<li>To modify class members, we use setter.
<ul>
<li>The setter is a function that is called when we want to modify the value of a class member.</li>
</ul>
</li>
</ul>
<h2 id="class-constructor--copy-constructor"><a class="header" href="#class-constructor--copy-constructor">Class constructor &amp; copy constructor</a></h2>
<ul>
<li>The constructor is a function that is called when an object is created.</li>
<li>3 types of constructor
<ul>
<li>constructor with no arguments
<ul>
<li>usally used to initialize data members with default values</li>
</ul>
</li>
<li>constructor with arguments
<ul>
<li>usally used to initialize data members with given values</li>
</ul>
</li>
<li>constructor with another same-type object (copy constructor)
<ul>
<li>usally used to copy data members from another object</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<p>Syntax:</p>
<pre><code class="language-c++">class class_name
{
  public:
    // default constructor
    class_name();
    // constructor with arguments
    class_name(int arg_x, int arg_y);
    // constructor with arguments that has default value
    // the usage is the same as the default constructor
    class_name(int arg_x = 0, int arg_y = 0);
    // copy constructor
    class_name(const class_name &amp;arg_class_name);
};
</code></pre>
<hr />
<p>Example: <code>Point_2D</code> (partial)</p>
<pre><code class="language-c++">public: // public member functions
    // Constructor

    // Constructor &amp; Default constructor
    // initialize data members, with default values
    // accessable to const object by default
    Point_2D(const int &amp;arg_x = 0, const int &amp;arg_y = 0);

    // Copy constructor
    // copy the data members from the given object
    // accessable to const object by default
    Point_2D(const Point_2D &amp;arg_point);

    // Destructor
    ~Point_2D() // destructor
    {
        // do nothing, because we don't
        // have any dynamic memory
    }
</code></pre>
<hr />
<pre><code class="language-c++">// Constructor &amp; Default constructor
// initialize data members, with default values
Point_2D::Point_2D(const int &amp;arg_x, const int &amp;arg_y)
// use `: var_name1(arg_var_name1), var_name2(arg_var_name2)`
// to initialize data members
    : m_x(arg_x),
      m_y(arg_y)
{
    // check if the point is valid
    _check_validity();
}

// Copy constructor
// copy the data members from the given object
Point_2D::Point_2D(const Point_2D &amp;arg_point)
    : m_x(arg_point.m_x),
      m_y(arg_point.m_y)
{
    // check if the point is valid
    _check_validity();
}
</code></pre>
<h2 id="class-getter--setter"><a class="header" href="#class-getter--setter">Class getter &amp; setter</a></h2>
<ul>
<li>The getter is a function that is called when we want to access the value of a class member.</li>
<li>The setter is a function that is called when we want to modify the value of a class member.</li>
<li>Getter and setter will check if the value is valid.</li>
</ul>
<hr />
<p>Example: <code>Point_2D</code> (partial)</p>
<pre><code class="language-c++">class Point_2D
{
private: // private data members &amp; member functions
    // record the x coordinate
    int m_x;
    // record the y coordinate
    int m_y;

public: // public member functions
    // Setter
    // modify the x and y coordinate
    // we use `arg_` to indicate the arguments
    // and re-write with setter
    void set_x(const int &amp;arg_x);
    void set_y(const int &amp;arg_y);
    void set(const int &amp;arg_x, const int &amp;arg_y);
    // Getter
    // get the x coordinate and y coordinate
    // accessable to const object
    int get_x() const;
    int get_y() const;
};
</code></pre>
<h2 id="class-destructor"><a class="header" href="#class-destructor">Class destructor</a></h2>
<ul>
<li>The destructor is a function that is called when an object is destroyed.</li>
<li>The destructor is usually used to free the memory that is allocated by the constructor.</li>
</ul>
<hr />
<p>Syntax:</p>
<pre><code class="language-c++">class class_name
{
  public:
    // default constructor
    class_name();

    // destructor
    ~class_name();
};
</code></pre>
<h2 id="const-function--const-class-instance"><a class="header" href="#const-function--const-class-instance"><code>const</code> function &amp; <code>const</code> class instance</a></h2>
<ul>
<li>How to access the member of a class that is declared as <code>const</code>?
<ul>
<li>add <code>const</code> to the class declaration</li>
</ul>
</li>
</ul>
<hr />
<p>Example: <code>Point_2D</code> (partial)</p>
<pre><code class="language-c++">class Point_2D
{
private: // private data members &amp; member functions
    // record the x coordinate
    int m_x;
    // record the y coordinate
    int m_y;

public: // public member functions
    // print the x and y coordinate in format (x, y)
    // we add `const` so that it can access the value form a const object
    void print() const;
    // Setter
    // modify the x and y coordinate
    // we don't add `const` because it will modify the value
    void set_x(const int &amp;arg_x);
    void set_y(const int &amp;arg_y);
    void set(const int &amp;arg_x, const int &amp;arg_y);
    // Getter
    // get the x coordinate and y coordinate
    // we add `const` so that it can access the value form a const object
    int get_x() const;
    int get_y() const;
};
</code></pre>
<hr />
<pre><code class="language-c++">// main function

int main()
{
    // create a Point_2D object with initial values
    Point_2D p1(1, 2);
    // also create a `const` Point_2D object
    const Point_2D p2(3, 4);
    // create a `const` with another Point_2D object
    const Point_2D p3(p1);
    // print 3 instances of Point
    p1.print();
    cout &lt;&lt; endl;
    // getter can be used to access the member of a `const` object
    cout &lt;&lt; &quot;(&quot; &lt;&lt; p2.get_x() &lt;&lt; &quot;, &quot;
         &lt;&lt; p2.get_y() &lt;&lt; &quot;)&quot; &lt;&lt; endl;
    // also `print()` can be used to access the member of a `const` object
    p3.print();
    cout &lt;&lt; endl;

    // modify each instance with setter
    p1.set(3, 4);
    p2.set_x(5); // error, cannot modify the member of a `const` object
    p2.set_y(6); // error, cannot modify the member of a `const` object
    return 0;
}
</code></pre>
<h2 id="member-function--global-function"><a class="header" href="#member-function--global-function">Member function &amp; Global function</a></h2>
<p>Rather than design a member function in a class, we can design a global function to process a class instance.</p>
<ul>
<li>Member function usually process the data members of a class.
<ul>
<li>public: getter, setter, constructor, destructor, etc.</li>
<li>private: utility functions, debug functions, etc.</li>
</ul>
</li>
<li>Global function usually process class instances with member functions.
<ul>
<li>like normal function.</li>
<li>but friend function can access the member of a class. (discuss in the next lecture)</li>
</ul>
</li>
</ul>
<hr />
<p>Example: <code>Point_2D</code></p>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Point_2D // the class name
// we use first upper case letter to indicate a class
{
private: // private data members &amp; member functions
    // Data members
    // we use `m_` to indicate a data member

    // record the x coordinate
    int m_x;
    // record the y coordinate
    int m_y;

    // Private member functions
    // we use `_` to indicate a private member function

    // utility: check if the point is valid
    void _check_validity();
</code></pre>
<hr />
<pre><code class="language-c++">public: // public member functions
    // Constructor

    // Constructor &amp; Default constructor
    // initialize data members, with default values
    // accessable to const object by default
    Point_2D(const int &amp;arg_x = 0, const int &amp;arg_y = 0);

    // Copy constructor
    // copy the data members from the given object
    // accessable to const object by default
    Point_2D(const Point_2D &amp;arg_point);

    // Destructor
    ~Point_2D() // destructor
    {
        // do nothing, because we don't
        // have any dynamic memory
    }
</code></pre>
<hr />
<pre><code class="language-c++">    // Member functions
    // we use lower case letter to indicate a member function
    // also, we just define the function declaration
    // and leave the definition to the end of the class

    // print the x and y coordinate in format (x, y)
    // accessable to const object
    void print() const;
    // modify the x and y coordinate
    // we use `arg_` to indicate the arguments
    // and re-write with setter
    void set_x(const int &amp;arg_x);
    void set_y(const int &amp;arg_y);
    void set(const int &amp;arg_x, const int &amp;arg_y);
    // get the x coordinate and y coordinate
    // accessable to const object
    int get_x() const;
    int get_y() const;
};
</code></pre>
<h2 id="how-to-design-class-interface"><a class="header" href="#how-to-design-class-interface">How to design class interface?</a></h2>
<ul>
<li>To design a class interface, we need to know the following:
<ul>
<li>What is the interface of the class?
<ul>
<li>What is the input?</li>
<li>What is the output?</li>
<li>What is the return value?</li>
</ul>
</li>
<li>How to implement the interface?
<ul>
<li>How to use the interface?</li>
<li>How to call the interface?</li>
</ul>
</li>
</ul>
</li>
<li>Usually have guidelines in a team to design the interface.
<ul>
<li>To simplify it, we can use the following guidelines for the course.</li>
</ul>
</li>
</ul>
<hr />
<p>Guidelines: (again)</p>
<ul>
<li>each member function should show it's accessibility explicitly
<ul>
<li>'_' is used to indicate a member function used internally (<code>private</code>)</li>
<li>all other functions are public</li>
</ul>
</li>
<li>essential member functions should be defined in the class
<ul>
<li>getter &amp; setter</li>
<li>constructor &amp; destructor</li>
<li><code>operator=</code> (disscuss on later lecture)</li>
<li>etc.</li>
</ul>
</li>
<li>utility functions are usually for in-class use
<ul>
<li>utility functions are used to help other member functions and make it reusable, readable, and maintainable</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>naming of member functions should be consistent with the class name
<ul>
<li><code>get_</code> for getter</li>
<li><code>set_</code> for setter</li>
<li><code>is_</code> for predicate</li>
<li><code>has_</code> for predicate</li>
<li><code>add_</code> for mutator</li>
<li><code>remove_</code> for mutator</li>
<li><code>clear_</code> for mutator</li>
<li><code>size_</code> for predicate</li>
<li><code>to_string_</code> for predicate</li>
<li><code>from_string_</code> for mutator</li>
<li>etc.</li>
</ul>
</li>
</ul>
<h2 id="example-1-triangle-again-a-hrefclasslecture4_ex1htmlsourcea"><a class="header" href="#example-1-triangle-again-a-hrefclasslecture4_ex1htmlsourcea">Example 1: Triangle (again) [<a href="class/./lecture4_ex1.html">Source</a>]</a></h2>
<p>A Triangle:</p>
<ul>
<li>contains 3 points</li>
<li>on the 2D plane</li>
<li>need to be able to calculate the area</li>
<li>need to be initialized, printed, and modified</li>
</ul>
<h2 id="example-2-vector-again-a-hrefclasslecture4_ex2htmlsourcea"><a class="header" href="#example-2-vector-again-a-hrefclasslecture4_ex2htmlsourcea">Example 2: Vector (again) [<a href="class/./lecture4_ex2.html">Source</a>]</a></h2>
<p>A Vector:</p>
<ul>
<li>contains 3 factors of the 3 basis $\bold{i}$, $\bold{j}$, $\bold{k}$</li>
<li>need to be able to calculate the length</li>
<li>need to be able to calculate the dot, cross product</li>
<li>need to be initialized, printed, and modified</li>
</ul>
<h2 id="example-3-integer-calculator-again-a-hrefclasslecture4_ex3htmlsourcea"><a class="header" href="#example-3-integer-calculator-again-a-hrefclasslecture4_ex3htmlsourcea">Example 3: Integer Calculator (again) [<a href="class/./lecture4_ex3.html">Source</a>]</a></h2>
<p>A Integer Calculator:</p>
<ul>
<li>contains current value, input value, and operation</li>
<li>neet to be able to set the input value</li>
<li>neet to be able to set the operation</li>
<li>neet to be able to calculate the result</li>
<li>neet to be able to clear the input value</li>
<li>need to be initialized</li>
<li>need to be able to get all information</li>
</ul>
<h2 id="lab-4-a-hrefclasslablab4-1htmlcomplex-numbera"><a class="header" href="#lab-4-a-hrefclasslablab4-1htmlcomplex-numbera">Lab 4: <a href="class/./lab/lab4-1.html">Complex Number</a></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-1-trangle-2"><a class="header" href="#example-1-trangle-2">Example 1: Trangle</a></h1>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

// Triangle class declaration
class Triangle
{
private:
    // define three points of the triangle
    // in x1, y1, x2, y2, x3, y3 format
    double m_x1, m_y1, m_x2, m_y2, m_x3, m_y3;

    // check &amp; correct the triangle points to counterclockwise order
    void _check_points();

public:
    // Constructor
    Triangle(const double &amp;arg_x1 = 0.0, const double &amp;arg_y1 = 0.0,
             const double &amp;arg_x2 = 0.0, const double &amp;arg_y2 = 0.0,
             const double &amp;arg_x3 = 0.0, const double &amp;arg_y3 = 0.0);

    // Copy constructor
    Triangle(const Triangle &amp;arg_triangle);

    // Destructor
    ~Triangle()
    {
        // do nothing
    }

    // print the triangle
    void print();
    // modify the three points of the triangle
    void set_points(const double &amp;arg_x1, const double &amp;arg_y1,
                    const double &amp;arg_x2, const double &amp;arg_y2,
                    const double &amp;arg_x3, const double &amp;arg_y3);
    void set_point1(const double &amp;arg_x1, const double &amp;arg_y1);
    void set_point2(const double &amp;arg_x2, const double &amp;arg_y2);
    void set_point3(const double &amp;arg_x3, const double &amp;arg_y3);
    void set_x1(const double &amp;arg_x1);
    void set_y1(const double &amp;arg_y1);
    void set_x2(const double &amp;arg_x2);
    void set_y2(const double &amp;arg_y2);
    void set_x3(const double &amp;arg_x3);
    void set_y3(const double &amp;arg_y3);
    // get the three points of the triangle
    double get_x1() const;
    double get_y1() const;
    double get_x2() const;
    double get_y2() const;
    double get_x3() const;
    double get_y3() const;

    // calculate the area of the triangle
    double area();
};

// Triangle class implementation

// check &amp; correct the triangle points to counterclockwise order
void Triangle::_check_points()
{
    // calculate the area of the triangle
    double area = (m_x1 * (m_y2 - m_y3) + m_x2 * (m_y3 - m_y1) 
                + m_x3 * (m_y1 - m_y2)) / 2.0;

    // if the area is negative, swap the points
    if (area &lt; 0.0)
    {
        double temp_x = m_x1;
        double temp_y = m_y1;
        m_x1 = m_x2;
        m_y1 = m_y2;
        m_x2 = temp_x;
        m_y2 = temp_y;
    }
}

// Constructor
Triangle::Triangle(const double &amp;arg_x1, const double &amp;arg_y1,
                   const double &amp;arg_x2, const double &amp;arg_y2,
                   const double &amp;arg_x3, const double &amp;arg_y3)
    : m_x1(arg_x1), m_y1(arg_y1), m_x2(arg_x2), m_y2(arg_y2),
      m_x3(arg_x3), m_y3(arg_y3)
{
    // check &amp; correct the triangle points to counterclockwise order
    _check_points();
}

// Copy constructor
Triangle::Triangle(const Triangle &amp;arg_triangle)
    : m_x1(arg_triangle.m_x1), m_y1(arg_triangle.m_y1),
      m_x2(arg_triangle.m_x2), m_y2(arg_triangle.m_y2),
      m_x3(arg_triangle.m_x3), m_y3(arg_triangle.m_y3)
{
}

// print the triangle
void Triangle::print()
{
    // print the three points of the triangle
    cout &lt;&lt; &quot;Triangle: &quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;(&quot; &lt;&lt; m_x1 &lt;&lt; &quot;, &quot; &lt;&lt; m_y1 &lt;&lt; &quot;)&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;(&quot; &lt;&lt; m_x2 &lt;&lt; &quot;, &quot; &lt;&lt; m_y2 &lt;&lt; &quot;)&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;(&quot; &lt;&lt; m_x3 &lt;&lt; &quot;, &quot; &lt;&lt; m_y3 &lt;&lt; &quot;)&quot; &lt;&lt; endl;
}

// set the three points of the triangle
void Triangle::set_points(const double &amp;arg_x1, const double &amp;arg_y1,
                          const double &amp;arg_x2, const double &amp;arg_y2,
                          const double &amp;arg_x3, const double &amp;arg_y3)
{
    m_x1 = arg_x1;
    m_y1 = arg_y1;
    m_x2 = arg_x2;
    m_y2 = arg_y2;
    m_x3 = arg_x3;
    m_y3 = arg_y3;

    // check &amp; correct the triangle points to counterclockwise order
    _check_points();
}
void Triangle::set_point1(const double &amp;arg_x1, const double &amp;arg_y1)
{
    m_x1 = arg_x1;
    m_y1 = arg_y1;

    // check &amp; correct the triangle points to counterclockwise order
    _check_points();
}
void Triangle::set_point2(const double &amp;arg_x2, const double &amp;arg_y2)
{
    m_x2 = arg_x2;
    m_y2 = arg_y2;

    // check &amp; correct the triangle points to counterclockwise order
    _check_points();
}
void Triangle::set_point3(const double &amp;arg_x3, const double &amp;arg_y3)
{
    m_x3 = arg_x3;
    m_y3 = arg_y3;

    // check &amp; correct the triangle points to counterclockwise order
    _check_points();
}
void Triangle::set_x1(const double &amp;arg_x1)
{
    m_x1 = arg_x1;

    // check &amp; correct the triangle points to counterclockwise order
    _check_points();
}
void Triangle::set_y1(const double &amp;arg_y1)
{
    m_y1 = arg_y1;

    // check &amp; correct the triangle points to counterclockwise order
    _check_points();
}
void Triangle::set_x2(const double &amp;arg_x2)
{
    m_x2 = arg_x2;

    // check &amp; correct the triangle points to counterclockwise order
    _check_points();
}
void Triangle::set_y2(const double &amp;arg_y2)
{
    m_y2 = arg_y2;

    // check &amp; correct the triangle points to counterclockwise order
    _check_points();
}
void Triangle::set_x3(const double &amp;arg_x3)
{
    m_x3 = arg_x3;

    // check &amp; correct the triangle points to counterclockwise order
    _check_points();
}
void Triangle::set_y3(const double &amp;arg_y3)
{
    m_y3 = arg_y3;

    // check &amp; correct the triangle points to counterclockwise order
    _check_points();
}

// get the three points of the triangle
double Triangle::get_x1() const
{
    return m_x1;
}
double Triangle::get_y1() const
{
    return m_y1;
}
double Triangle::get_x2() const
{
    return m_x2;
}
double Triangle::get_y2() const
{
    return m_y2;
}
double Triangle::get_x3() const
{
    return m_x3;
}
double Triangle::get_y3() const
{
    return m_y3;
}

// calculate the area of the triangle
double Triangle::area()
{
    // calculate the area of the triangle
    return (m_x1 * (m_y2 - m_y3) + m_x2 * (m_y3 - m_y1) + m_x3 * (m_y1 - m_y2)) / 2.0;
}

// main function

int main()
{
    Triangle t(1, 1, 2, 2, 0, 3);
    t.print();
    cout &lt;&lt; &quot;Area: &quot; &lt;&lt; t.area() &lt;&lt; endl;

    // change the points of the triangle
    t.set_points(1, 2, 2, 3, 3, 1);
    t.print();
    cout &lt;&lt; &quot;Area: &quot; &lt;&lt; t.area() &lt;&lt; endl;

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-2-vector-2"><a class="header" href="#example-2-vector-2">Example 2: Vector</a></h1>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;

// Vector class declaration
class Vector
{
private:
    // define the three factor of the basis vectors
    // on the x, y, z axes
    double m_x, m_y, m_z;

public:
    // Constructor
    Vector(const double &amp;arg_x = 0.0, const double &amp;arg_y = 0.0,
           const double &amp;arg_z = 0.0);

    // Copy constructor
    Vector(const Vector &amp;arg_vector);

    // Destructor
    ~Vector()
    {
        // do nothing
    }

    // print the vector
    void print();

    // set the three factor of the basis vectors
    void set_vector(const double &amp;arg_x, const double &amp;arg_y,
                    const double &amp;arg_z);
    void set_x(const double &amp;arg_x);
    void set_y(const double &amp;arg_y);
    void set_z(const double &amp;arg_z);
    // get the three factor of the basis vectors
    double get_x() const;
    double get_y() const;
    double get_z() const;

    // calculate the length of the vector
    double length();
    // calculate the dot product of two vectors
    int dot(const Vector &amp;);
    // calculate the cross product of two vectors
    Vector cross(const Vector &amp;);
};

// Vector class implementation

// Constructor
Vector::Vector(const double &amp;arg_x, const double &amp;arg_y,
               const double &amp;arg_z)
    : m_x(arg_x), m_y(arg_y), m_z(arg_z)
{
}

// Copy constructor
Vector::Vector(const Vector &amp;arg_vector)
    : m_x(arg_vector.m_x), m_y(arg_vector.m_y), m_z(arg_vector.m_z)
{
}

// print the vector
void Vector::print()
{
    // print the three factor of the basis vectors
    cout &lt;&lt; &quot;Vector: &quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;(&quot; &lt;&lt; m_x &lt;&lt; &quot;, &quot; &lt;&lt; m_y &lt;&lt; &quot;, &quot; &lt;&lt; m_z &lt;&lt; &quot;)&quot; &lt;&lt; endl;
}

// set the three factor of the basis vectors
void Vector::set_vector(const double &amp;arg_x, const double &amp;arg_y,
                        const double &amp;arg_z)
{
    m_x = arg_x;
    m_y = arg_y;
    m_z = arg_z;
}
void Vector::set_x(const double &amp;arg_x)
{
    m_x = arg_x;
}
void Vector::set_y(const double &amp;arg_y)
{
    m_y = arg_y;
}
void Vector::set_z(const double &amp;arg_z)
{
    m_z = arg_z;
}
// get the three factor of the basis vectors
double Vector::get_x() const
{
    return m_x;
}
double Vector::get_y() const
{
    return m_y;
}
double Vector::get_z() const
{
    return m_z;
}

// calculate the length of the vector
double Vector::length()
{
    // calculate the length of the vector
    return sqrt(m_x * m_x + m_y * m_y + m_z * m_z);
}

// calculate the dot product of two vectors
int Vector::dot(const Vector &amp;arg_v)
{
    // calculate the dot product of two vectors
    return m_x * arg_v.m_x + m_y * arg_v.m_y + m_z * arg_v.m_z;
}

// calculate the cross product of two vectors
Vector Vector::cross(const Vector &amp;arg_v)
{
    // calculate the cross product of two vectors
    Vector v;
    v.m_x = m_y * arg_v.m_z - m_z * arg_v.m_y;
    v.m_y = m_z * arg_v.m_x - m_x * arg_v.m_z;
    v.m_z = m_x * arg_v.m_y - m_y * arg_v.m_x;
    return v;
}

// main function

int main()
{
    Vector v1;
    v1.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;Length of v1: &quot; &lt;&lt; v1.length() &lt;&lt; endl;
    v1.set_vector(1.0, 2.0, 3.0);
    v1.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;Length of v1: &quot; &lt;&lt; v1.length() &lt;&lt; endl;
    cout &lt;&lt; endl;

    Vector v2(v1);
    v2.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;Length of v2: &quot; &lt;&lt; v2.length() &lt;&lt; endl;
    v2.set_vector(2.0, 3.0, 4.0);
    v2.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;Length of v2: &quot; &lt;&lt; v2.length() &lt;&lt; endl;
    cout &lt;&lt; endl;

    cout &lt;&lt; &quot;v1: &quot;;
    v1.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;v2: &quot;;
    v2.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;Dot: &quot; &lt;&lt; v1.dot(v2) &lt;&lt; endl;
    cout &lt;&lt; endl;

    v2.set_vector(1.0, 1.0, 1.0);
    Vector v3(v1.cross(v2));
    cout &lt;&lt; &quot;v1: &quot;;
    v1.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;v2: &quot;;
    v2.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;Cross: &quot;;
    v3.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; endl;

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-3-integer-calculator-1"><a class="header" href="#example-3-integer-calculator-1">Example 3: Integer Calculator</a></h1>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

// Triangle class declaration
class Int_Calc
{
private:
    // define current value
    long m_curr_val;
    // define input value
    long m_input_val;
    // define operation
    // `+`, `-`, `*`, `/`, and ` ` for none
    char m_op;
    // calculate result
    void _calc_result();

public:
    // Constructor
    Int_Calc(const long &amp;arg_curr_val = 0, const long &amp;arg_input_val = 0,
             const char &amp;arg_op = ' ');
    // Copy constructor
    Int_Calc(const Int_Calc &amp;arg_int_calc);

    // Destructor
    ~Int_Calc()
    {
        // do nothing
    }

    // clear the input value
    void clear();
    // set the input value
    void set_input(long arg_input);
    // add the input value to the current value
    void add();
    // subtract the input value from the current value
    void sub();
    // multiply the input value with the current value
    void mul();
    // divide the current value by the input value
    void div();
    // assign the input value to the current value
    void assign();
    // get the current value
    long get_curr_val();
    // get the current operation
    char get_op();
    // get the input value
    long get_input_val();
};

// Int_Calc class implementation

// Constructor
Int_Calc::Int_Calc(const long &amp;arg_curr_val, const long &amp;arg_input_val,
                   const char &amp;arg_op)
    : m_curr_val(arg_curr_val), m_input_val(arg_input_val), m_op(arg_op)
{
}

// Copy constructor
Int_Calc::Int_Calc(const Int_Calc &amp;arg_int_calc)
    : m_curr_val(arg_int_calc.m_curr_val),
      m_input_val(arg_int_calc.m_input_val),
      m_op(arg_int_calc.m_op)
{
}

// calculate the result
void Int_Calc::_calc_result()
{
    switch (m_op)
    {
    case '+':
        m_curr_val += m_input_val;
        break;
    case '-':
        m_curr_val -= m_input_val;
        break;
    case '*':
        m_curr_val *= m_input_val;
        break;
    case '/':
        m_curr_val /= m_input_val;
        break;
    case ' ':
        m_curr_val = m_input_val;
        break;
    default:
        break;
    }
}

// clear the input value
void Int_Calc::clear()
{
    m_input_val = 0;
}

// set the input value
void Int_Calc::set_input(long arg_input)
{
    m_input_val = arg_input;
}

// add the input value to the current value
void Int_Calc::add()
{
    _calc_result();
    m_op = '+';
}

// subtract the input value from the current value
void Int_Calc::sub()
{
    _calc_result();
    m_op = '-';
}

// multiply the input value with the current value
void Int_Calc::mul()
{
    _calc_result();
    m_op = '*';
}

// divide the current value by the input value
void Int_Calc::div()
{
    _calc_result();
    m_op = '/';
}

// assign the input value to the current value
void Int_Calc::assign()
{
    _calc_result();
    m_op = ' ';
}

// get the current value
long Int_Calc::get_curr_val()
{
    return m_curr_val;
}

// get the current operation
char Int_Calc::get_op()
{
    return m_op;
}

// get the input value
long Int_Calc::get_input_val()
{
    return m_input_val;
}

// main function

int main()
{
    // create an instance of the class
    Int_Calc calc;
    // set the input value
    calc.set_input(10);
    // get the input value
    cout &lt;&lt; calc.get_input_val() &lt;&lt; endl;
    // add the input value to the current value
    calc.add();
    // get current op
    cout &lt;&lt; '\'' &lt;&lt; calc.get_op() &lt;&lt; '\'' &lt;&lt; endl;
    // set another input value
    calc.set_input(20);
    // get the input value
    cout &lt;&lt; calc.get_input_val() &lt;&lt; endl;
    // clear the input value
    calc.clear();
    // set the input value
    calc.set_input(30);
    // get the input value
    cout &lt;&lt; calc.get_input_val() &lt;&lt; endl;
    // compute the result
    calc.assign();
    // print the result
    cout &lt;&lt; calc.get_curr_val() &lt;&lt; endl;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-4-complex-number"><a class="header" href="#lab-4-complex-number">Lab 4: Complex Number</a></h1>
<h2 id="lab-4-1-complex-numbers-50"><a class="header" href="#lab-4-1-complex-numbers-50">Lab 4-1: Complex Numbers (50%)</a></h2>
<ul>
<li>輸入：
<ol>
<li>以 <code>double</code> 格式輸入複數的實數及虛數部分，以空格分開</li>
<li>一行輸入一個複數</li>
<li>輸入 <kbd>Ctrl</kbd>+<kbd>D</kbd> 完成輸入
<ul>
<li>Windows 請輸入 <kbd>Ctrl</kbd>+<kbd>Z</kbd> (會在螢幕上顯示 <code>^Z</code>) 再輸入 <kbd>Enter</kbd> 完成輸入</li>
</ul>
</li>
</ol>
</li>
<li>輸出：
<ol>
<li>顯示複數儲存 Complex Class 的數字</li>
<li>一行輸入跟著輸出一個複數</li>
</ol>
</li>
<li>檔名：<code>lab4-1_&lt;學號&gt;.cpp</code> (e.g. <code>lab4-1_106062802.cpp</code>)</li>
</ul>
<p>注意事項：</p>
<ul>
<li>程式不會輸出任何使用者提示，只會輸出程式結果</li>
<li>請使用 pseudo code 提供的 main function 來處理輸入與輸出</li>
<li>程式需要於 10 秒內完成，所有的測資皆會保證於 10 秒內完成</li>
</ul>
<h3 id="format-1"><a class="header" href="#format-1">Format</a></h3>
<pre><code class="language-text">&lt;real 1&gt; &lt;imag 1&gt;⏎
&lt;real 1&gt; + &lt;imag 1&gt; i
&lt;real 2&gt; &lt;imag 2&gt;⏎
&lt;real 2&gt; + &lt;imag 2&gt; i
...
&lt;real n&gt; &lt;imag n&gt;⏎
&lt;real n&gt; + &lt;imag n&gt; i
^Z⏎
</code></pre>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<pre><code class="language-console">$ ./a.out
1.0 0.0⏎
1 + 0 i
2.0 1.1⏎
2 + 1.1 i
-3.0 -2.2⏎
-3 + -2.2 i
^Z⏎
$
</code></pre>
<h3 id="pseudo-code-1"><a class="header" href="#pseudo-code-1">Pseudo Code</a></h3>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Complex
{
private:
    // data members
    // save the real and imaginary parts of the complex number
    // with `double` precision

public:
    // Constructor, initializes real and imaginary parts
    // hint: as like as `modify` function in examples
    // but use default constructor to implement

    // print function
    // note: be careful about the format of output
    // especially the ` ` and newline (endl)
    void print();
};

int main()
{
    double real = 0.0, imag = 0.0;
    while (cin &gt;&gt; real &gt;&gt; imag)
    {
        Complex c(real, imag);
        c.print();
    }
    return 0;
}
</code></pre>
<h3 id="reference-code"><a class="header" href="#reference-code">Reference Code:</a></h3>
<h4 id="陳光齊-110021102"><a class="header" href="#陳光齊-110021102">陳光齊 (110021102)</a></h4>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Complex
{
private:
    // data members
    // save the real and imaginary parts of the complex number
    // with `double` precision
    double m_real;
    double m_imag;

public:
    // Constructor, initializes real and imaginary parts
    // hint: as like as `modify` function in examples
    // but use default constructor to implement
    Complex(double arg_real, double arg_imag);
    // print function
    // note: be careful about the format of output
    // especially the ` ` and newline (endl)
    void print();
};

Complex::Complex(double arg_real, double arg_imag)
    : m_real(arg_real), m_imag(arg_imag)
{
}
void Complex::print()
{
    cout &lt;&lt; m_real &lt;&lt; &quot; + &quot; &lt;&lt; this-&gt;m_imag &lt;&lt; &quot; i&quot; &lt;&lt; endl;
}

int main()
{
    double real = 0.0, imag = 0.0;
    while (cin &gt;&gt; real &gt;&gt; imag)
    {
        Complex c(real, imag);

        c.print();
    }
    return 0;
}
</code></pre>
<h4 id="賴杰弘-110021118"><a class="header" href="#賴杰弘-110021118">賴杰弘 (110021118)</a></h4>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Complex
{
private:
    // data members
    // save the real and imaginary parts of the complex number
    // with `double` precision
    double m_real;
    double m_imag;

public:
    // Constructor, initializes real and imaginary parts
    // hint: as like as `modify` function in examples
    // but use default constructor to implement
    Complex(const double &amp;arg_real = 0.0, const double &amp;arg_imag = 0.0);
    // Copy Constructor
    Complex(const Complex &amp;arg_complex);
    // Destructor
    ~Complex(){
        // do nothing
    };
    // print function
    // note: be careful about the format of output
    // especially the ` ` and newline (endl)
    void print();
};

Complex::Complex(const double &amp;arg_real, const double &amp;arg_imag)
    : m_real(arg_real), m_imag(arg_imag)
{
}

Complex::Complex(const Complex &amp;arg_complex)
    : m_real(arg_complex.m_real), m_imag(arg_complex.m_imag)
{
}

void Complex::print()
{
    cout &lt;&lt; m_real &lt;&lt; &quot; + &quot; &lt;&lt; m_imag &lt;&lt; &quot; i&quot; &lt;&lt; endl;
    return;
}

int main()
{
    double real = 0.0, imag = 0.0;
    while (cin &gt;&gt; real &gt;&gt; imag)
    {
        Complex c(real, imag);
        c.print();
    }
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="lab-4-2-complex-number-calculation-35"><a class="header" href="#lab-4-2-complex-number-calculation-35">Lab 4-2: Complex Number Calculation (35%)</a></h2>
<ul>
<li>輸入：
<ol>
<li>以 <code>double</code> 格式輸入複數的實數及虛數部分，以空格分開，一行輸入一個複數</li>
<li>以 <code>char</code> 格式輸入複數的運算子，包含 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>，一行輸入一個運算子</li>
<li>複數與運算子以交錯的方式輸入，一行輸入一個複數接著一個運算子，倒數兩行為複數與完成輸入指令</li>
<li>輸入 <kbd>Ctrl</kbd>+<kbd>D</kbd> 完成輸入
<ul>
<li>Windows 請輸入 <kbd>Ctrl</kbd>+<kbd>Z</kbd> (會在螢幕上顯示 <code>^Z</code>) 再輸入 <kbd>Enter</kbd> (Format 中的 <code>⏎</code>) 完成輸入</li>
</ul>
</li>
</ol>
</li>
<li>輸出：
<ol>
<li>顯示運算複數的結果</li>
</ol>
</li>
<li>檔名：<code>lab4-2_&lt;學號&gt;.cpp</code> (e.g. <code>lab4-2_106062802.cpp</code>)</li>
</ul>
<p>注意事項：</p>
<ul>
<li>程式不會輸出任何使用者提示，只會輸出程式結果</li>
<li>使用者不需要處理錯誤輸入</li>
<li>請使用 pseudo code 提供的 main function 來處理輸入與輸出</li>
<li>程式需要於 10 秒內完成，所有的測資皆會保證於 10 秒內完成</li>
</ul>
<h3 id="format-2"><a class="header" href="#format-2">Format</a></h3>
<pre><code class="language-text">&lt;real 1&gt; &lt;imag 1&gt;⏎
&lt;op 1&gt;⏎
&lt;real 2&gt; &lt;imag 2&gt;⏎
&lt;op 2&gt;⏎
...
&lt;real n-1&gt; &lt;imag n-1&gt;⏎
&lt;op n-1&gt;⏎
&lt;real n&gt; &lt;imag n&gt;⏎
^Z⏎
&lt;real result&gt; + &lt;imag result&gt; i
</code></pre>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<pre><code class="language-console">$ ./a.out
1.0 0.0⏎
^Z⏎
1 + 0 i
$
$ ./a.out
1.0 0.0⏎
+⏎
2.0 1.1⏎
-⏎
-3.0 -2.2⏎
*⏎
4.3 2.1⏎
/⏎
-1.2 -3.4⏎
^Z⏎
-8.74846 + 2.46231 i
$
</code></pre>
<h3 id="pseudo-code-2"><a class="header" href="#pseudo-code-2">Pseudo Code</a></h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

using namespace std;

class Complex
{
private:
    // data members
    // save the real and imaginary parts of the complex number
    // with `double` precision

public:
    // Constructor, initializes real and imaginary parts
    // hint: as like as `modify` function in examples
    // but use default constructor to implement

    // print function
    // note: be careful about the format of output
    // especially the ` ` and newline (endl)
    void print();

    // add function
    
    // subtract function
        
    // multiply function
        
    // divide function
        
};

int main()
{
    string input;
    Complex result_complex;
    char op = ' ';

    while (getline(cin, input))
    {
        // input is a operation
        if (input == &quot;+&quot; || input == &quot;-&quot; || input == &quot;*&quot; || input == &quot;/&quot;)
        {
            op = input[0];
            continue;
        }
        // input is a complex number
        else
        {
            stringstream ss(input);
            double real, imag;
            ss &gt;&gt; real &gt;&gt; imag;
            Complex current_complex(real, imag);
            switch (op)
            {
            case '+':
                result_complex = result_complex.add(current_complex);
                break;
            case '-':
                result_complex = result_complex.sub(current_complex);
                break;
            case '*':
                result_complex = result_complex.mul(current_complex);
                break;
            case '/':
                result_complex = result_complex.div(current_complex);
                break;
            case ' ':
                result_complex = current_complex;
                break;
            default:
                cerr &lt;&lt; &quot;Error: unknown operation&quot; &lt;&lt; endl;
                return 1;
            }
        }
    }
    result_complex.print();
    return 0;
}
</code></pre>
<h3 id="reference-code-1"><a class="header" href="#reference-code-1">Reference Code:</a></h3>
<h4 id="陳光齊-110021102-1"><a class="header" href="#陳光齊-110021102-1">陳光齊 (110021102)</a></h4>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;sstream&gt;

using namespace std;

class Complex
{
private:
    // data members
    // save the real and imaginary parts of the complex number
    // with `double` precision
    double m_real;
    double m_imag;

public:
    // Constructor, initializes real and imaginary parts
    // hint: as like as `modify` function in examples
    // but use default constructor to implement
    Complex(double arg_real = 0.0, double arg_imag = 0.0);
    Complex(const Complex &amp;arg_c);
    // print function
    // note: be careful about the format of output
    // especially the ` ` and newline (endl)
    void print() const;
    double get_real() const;
    double get_imag() const;
    void set_real(double &amp;real);
    void set_imag(double &amp;imag);
    Complex add(const Complex &amp;arg_c);
    Complex sub(const Complex &amp;arg_c);
    Complex mul(const Complex &amp;arg_c);
    Complex div(Complex &amp;arg_c);
    Complex const_mul(double arg_x);
    Complex conj();
};
Complex::Complex(double arg_real, double arg_imag)
    : m_real(arg_real), m_imag(arg_imag)
{
}
Complex::Complex(const Complex &amp;arg_c)
    : m_real(arg_c.get_real()), m_imag(arg_c.get_imag())
{
}
void Complex::print() const
{
    cout &lt;&lt; m_real &lt;&lt; &quot; + &quot; &lt;&lt; this-&gt;m_imag &lt;&lt; &quot; i&quot; &lt;&lt; endl;
}
double Complex::get_real() const
{
    return m_real;
}
double Complex::get_imag() const
{
    return m_imag;
}
void Complex::set_real(double &amp;real)
{
    m_real = real;
}
void Complex::set_imag(double &amp;imag)
{
    m_imag = imag;
}
Complex Complex::add(const Complex &amp;arg_c)
{
    Complex c_temp;
    c_temp.m_real = m_real + (arg_c.get_real());
    c_temp.m_imag = m_imag + (arg_c.get_imag());
    return c_temp;
}
Complex Complex::sub(const Complex &amp;arg_c)
{
    Complex c_temp;
    c_temp.m_real = m_real - (arg_c.get_real());
    c_temp.m_imag = m_imag - (arg_c.get_imag());
    return c_temp;
}
Complex Complex::mul(const Complex &amp;arg_c)
{
    Complex c_temp;
    c_temp.m_real = m_real * (arg_c.get_real()) - m_imag * (arg_c.get_imag());
    c_temp.m_imag = m_imag * (arg_c.get_real()) + m_real * (arg_c.get_imag());
    return c_temp;
}
Complex Complex::div(Complex &amp;arg_c)
{
    double c = arg_c.get_real();
    double d = arg_c.get_imag();
    Complex c_this(m_real, m_imag);
    Complex c_temp;
    arg_c = arg_c.conj();
    c_temp = c_this.mul(arg_c);
    c = c * c + d * d;
    c = 1 / c;
    c_temp = c_temp.const_mul(c);
    return c_temp;
}
Complex Complex::const_mul(double arg_x)
{
    Complex c_temp;
    c_temp.m_real = m_real * arg_x;
    c_temp.m_imag = m_imag * arg_x;
    return c_temp;
}
Complex Complex::conj()
{
    Complex c_temp;
    c_temp.m_real = m_real;
    c_temp.m_imag = -m_imag;
    return c_temp;
}

int main()
{
    string input;
    Complex result_complex;
    char op = ' ';

    while (getline(cin, input))
    {
        // input is a operation
        if (input == &quot;+&quot; || input == &quot;-&quot; || input == &quot;*&quot; || input == &quot;/&quot;)
        {
            op = input[0];
            continue;
        }
        // input is a complex number
        else
        {
            stringstream ss(input);
            double real, imag;
            ss &gt;&gt; real &gt;&gt; imag;
            Complex current_complex(real, imag);
            switch (op)
            {
            case '+':
                result_complex = result_complex.add(current_complex);
                break;
            case '-':
                result_complex = result_complex.sub(current_complex);
                break;
            case '*':
                result_complex = result_complex.mul(current_complex);
                break;
            case '/':
                result_complex = result_complex.div(current_complex);
                break;
            case ' ':
                result_complex = current_complex;
                break;
            default:
                cerr &lt;&lt; &quot;Error: unknown operation&quot; &lt;&lt; endl;
                return 1;
            }
        }
    }
    result_complex.print();
    return 0;
}
</code></pre>
<h4 id="賴杰弘-110021118-1"><a class="header" href="#賴杰弘-110021118-1">賴杰弘 (110021118)</a></h4>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

using namespace std;

class Complex
{
private:
    // data members
    // save the real and imaginary parts of the complex number
    // with `double` precision
    double m_real;
    double m_imag;

public:
    // Constructor, initializes real and imaginary parts
    // hint: as like as `modify` function in examples
    // but use default constructor to implement
    Complex(const double &amp;arg_real = 0.0, const double &amp;arg_imag = 0.0);
    // Copy Constructor
    Complex(const Complex &amp;arg_complex);
    // Destructor
    ~Complex(){
        // do nothing
    };

    // print function
    // note: be careful about the format of output
    // especially the ` ` and newline (endl)
    void print();

    // add function
    Complex add(const Complex &amp;arg_complex);
    // subtract function
    Complex sub(const Complex &amp;arg_complex);
    // multiply function
    Complex mul(const Complex &amp;arg_complex);
    // divide function
    Complex div(const Complex &amp;arg_complex);
};

Complex::Complex(const double &amp;arg_real, const double &amp;arg_imag)
    : m_real(arg_real), m_imag(arg_imag)
{
}

Complex::Complex(const Complex &amp;arg_complex)
    : m_real(arg_complex.m_real), m_imag(arg_complex.m_imag)
{
}

void Complex::print()
{
    cout &lt;&lt; m_real &lt;&lt; &quot; + &quot; &lt;&lt; m_imag &lt;&lt; &quot; i&quot; &lt;&lt; endl;
    return;
}

Complex Complex::add(const Complex &amp;arg_complex)
{
    Complex complex;
    complex.m_real = m_real + arg_complex.m_real;
    complex.m_imag = m_imag + arg_complex.m_imag;

    return complex;
}
Complex Complex::sub(const Complex &amp;arg_complex)
{
    Complex complex;
    complex.m_real = m_real - arg_complex.m_real;
    complex.m_imag = m_imag - arg_complex.m_imag;

    return complex;
}
Complex Complex::mul(const Complex &amp;arg_complex)
{
    Complex complex;
    complex.m_real = (m_real * arg_complex.m_real) - (m_imag * arg_complex.m_imag);
    complex.m_imag = (m_real * arg_complex.m_imag) + (m_imag * arg_complex.m_real);

    return complex;
}
Complex Complex::div(const Complex &amp;arg_complex)
{
    Complex complex;
    complex.m_real = ((m_real * arg_complex.m_real) + (m_imag * arg_complex.m_imag)) 
                    / ((arg_complex.m_real * arg_complex.m_real) + (arg_complex.m_imag * arg_complex.m_imag));
    complex.m_imag = ((m_imag * arg_complex.m_real) - (m_real * arg_complex.m_imag)) 
                    / ((arg_complex.m_real * arg_complex.m_real) + (arg_complex.m_imag * arg_complex.m_imag));

    return complex;
}

int main()
{
    string input;
    Complex result_complex;
    char op = ' ';

    while (getline(cin, input))
    {
        // input is a operation
        if (input == &quot;+&quot; || input == &quot;-&quot; || input == &quot;*&quot; || input == &quot;/&quot;)
        {
            op = input[0];
            continue;
        }
        // input is a complex number
        else
        {
            stringstream ss(input);
            double real, imag;
            ss &gt;&gt; real &gt;&gt; imag;
            Complex current_complex(real, imag);
            switch (op)
            {
            case '+':
                result_complex = result_complex.add(current_complex);
                break;
            case '-':
                result_complex = result_complex.sub(current_complex);
                break;
            case '*':
                result_complex = result_complex.mul(current_complex);
                break;
            case '/':
                result_complex = result_complex.div(current_complex);
                break;
            case ' ':
                result_complex = current_complex;
                break;
            default:
                cerr &lt;&lt; &quot;Error: unknown operation&quot; &lt;&lt; endl;
                return 1;
            }
        }
    }
    result_complex.print();
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="lab-4-3-advance-complex-number-calculation-15"><a class="header" href="#lab-4-3-advance-complex-number-calculation-15">Lab 4-3: Advance Complex Number Calculation (15%)</a></h2>
<ul>
<li>輸入：
<ol>
<li>以 <code>double</code> 格式輸入複數的實數及虛數部分，以空格分開，一行輸入一個複數</li>
<li>以 <code>char</code> 格式輸入複數的運算子，包含 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>，一行輸入一個運算子</li>
<li>複數與運算子以交錯的方式輸入，一行輸入一個複數接著一個運算子，倒數兩行為複數與完成輸入指令</li>
<li>輸入 <kbd>Ctrl</kbd>+<kbd>D</kbd> 完成輸入
<ul>
<li>Windows 請輸入 <kbd>Ctrl</kbd>+<kbd>Z</kbd> (會在螢幕上顯示 <code>^Z</code>) 再輸入 <kbd>Enter</kbd> (Format 中的 <code>⏎</code>) 完成輸入</li>
</ul>
</li>
<li>程式輸入以行為單位，每行輸入為任何有效的 <code>string</code> 格式</li>
</ol>
</li>
<li>輸出：
<ol>
<li>顯示運算複數的結果</li>
<li>若使用者輸入的複數或運算子不正確，則顯示錯誤訊息 <code>Error: Invalid input</code> 並結束程式</li>
</ol>
</li>
<li>檔名：<code>lab4-3_&lt;學號&gt;.cpp</code> (e.g. <code>lab4-3_106062802.cpp</code>)</li>
</ul>
<p>注意事項：</p>
<ul>
<li>程式不會輸出任何使用者提示，只會輸出程式結果或錯誤訊息</li>
<li>程式僅需處裡輸入錯誤的例外狀況，如輸入的複數或運算子不正確，其餘錯誤不須處裡</li>
<li>請基於 pseudo code 提供的 main function 進行修改來處理輸入與輸出</li>
<li>程式需要於 10 秒內完成，所有的測資皆會保證於 10 秒內完成</li>
</ul>
<h3 id="format-3"><a class="header" href="#format-3">Format</a></h3>
<pre><code class="language-text">&lt;real 1&gt; &lt;imag 1&gt;⏎
&lt;op 1&gt;⏎
&lt;real 2&gt; &lt;imag 2&gt;⏎
&lt;op 2&gt;⏎
...
&lt;real n-1&gt; &lt;imag n-1&gt;⏎
&lt;op n-1&gt;⏎
&lt;real n&gt; &lt;imag n&gt;⏎
^Z⏎
&lt;real result&gt; + &lt;imag result&gt; i
</code></pre>
<h3 id="example-4"><a class="header" href="#example-4">Example</a></h3>
<h4 id="normal"><a class="header" href="#normal">Normal</a></h4>
<pre><code class="language-console">$ ./a.out
1.0 0.0⏎
^Z⏎
1 + 0 i
$
$ ./a.out
1.0 0.0⏎
+⏎
2.0 1.1⏎
-⏎
-3.0 -2.2⏎
*⏎
4.3 2.1⏎
/⏎
-1.2 -3.4⏎
^Z⏎
-8.74846 + 2.46231 i
$
</code></pre>
<h4 id="exception-handling"><a class="header" href="#exception-handling">Exception Handling</a></h4>
<pre><code class="language-console">$ ./a.out
+⏎
Error: Invalid input
$
$ ./a.out
1.0 0.0⏎
+⏎
^Z⏎
Error: Invalid input
$
$ ./a.out
1.0 0.0⏎
1.0 0.0⏎
Error: Invalid input
$
$ ./a.out
1.0 0.0⏎
+⏎
+⏎
Error: Invalid input
$
$ ./a.out
^Z⏎
Error: Invalid input
$
$ ./a.out
1.0 2.0 3.0⏎
Error: Invalid input
$
$ ./a.out
1.0 2.0⏎
sdafsdagret⏎
Error: Invalid input
$
$ ./a.out
sdoifjwepoirjpwoie⏎
Error: Invalid input
$
</code></pre>
<h3 id="pseudo-code-3"><a class="header" href="#pseudo-code-3">Pseudo Code</a></h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

using namespace std;

class Complex
{
private:
    // data members
    // save the real and imaginary parts of the complex number
    // with `double` precision

public:
    // Constructor, initializes real and imaginary parts
    // hint: as like as `modify` function in examples
    // but use default constructor to implement

    // print function
    // note: be careful about the format of output
    // especially the ` ` and newline (endl)
    void print();

    // add function

    // subtract function

    // multiply function

    // divide function

    // parse function
    // note: use `stringstream` and `&gt;&gt;` to parse the string to double
    // and use `stringstream::fail()` to check the conversion is successful

};

// parse op global function
char parse_op(const string &amp;arg_str);

// prompt invalid input and exit
void prompt_invalid_input()
{
    cout &lt;&lt; &quot;Error: Invalid input&quot; &lt;&lt; endl;
    exit(1);
}

int main()
{
    string input;
    Complex result_complex;
    char op = ' ';                   // default op is ' '
    bool is_process_continue = true; // current process should be continued or not

    while (is_process_continue)
    {
        // get the first input
        
        // check is not end of input
        if (input.empty() || cin.eof())
        {
            prompt_invalid_input();
        }
        // check the input is a valid complex number
        
        // calculate the result
        
        // get the second input
        
        // check is end of input or not
        if (input.empty() || cin.eof())
        {
            is_process_continue = false;
        }
        // if not end of input, check the input is a valid operator
        
    }
    result_complex.print();
    return 0;
}
</code></pre>
<h3 id="reference-code-2"><a class="header" href="#reference-code-2">Reference Code:</a></h3>
<h4 id="藍珮芳110021116"><a class="header" href="#藍珮芳110021116">藍珮芳(110021116)</a></h4>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;
using namespace std;

class Complex
{
private:
    double m_real;
    double m_imag;

public:
    Complex(double arg_real = 0.0, double arg_imag = 0.0)
    {
        m_real = arg_real;
        m_imag = arg_imag;
    }
    void print()
    {
        cout &lt;&lt; m_real &lt;&lt; &quot; + &quot; &lt;&lt; m_imag &lt;&lt; &quot; i\n&quot;;
    };
    Complex add(Complex &amp;arg_c)
    {
        Complex temp;
        temp.m_real = m_real + arg_c.m_real;
        temp.m_imag = m_imag + arg_c.m_imag;
        return temp;
    };
    Complex sub(Complex &amp;arg_c)
    {
        Complex temp;
        temp.m_real = m_real - arg_c.m_real;
        temp.m_imag = m_imag - arg_c.m_imag;
        return temp;
    };
    Complex mul(Complex &amp;arg_c)
    {
        Complex temp;
        temp.m_real = m_real * arg_c.m_real - m_imag * arg_c.m_imag;
        temp.m_imag = m_real * arg_c.m_imag + m_imag * arg_c.m_real;
        return temp;
    };
    Complex div(Complex &amp;arg_c)
    {
        Complex temp;
        temp.m_real = (m_real * arg_c.m_real + m_imag * arg_c.m_imag) 
                    / (arg_c.m_real * arg_c.m_real + arg_c.m_imag * arg_c.m_imag);
        temp.m_imag = (m_imag * arg_c.m_real - m_real * arg_c.m_imag) 
                    / (arg_c.m_real * arg_c.m_real + arg_c.m_imag * arg_c.m_imag);
        return temp;
    };
};
bool check_complex(string &amp;input)
{
    string temp_str;
    vector&lt;string&gt; vec;
    stringstream terms_extractor(input);
    while (terms_extractor &gt;&gt; temp_str)
    {
        vec.push_back(temp_str);
    }
    if (vec.size() == 2)
    {
        if ((!isdigit(vec[0][0]) &amp;&amp; vec[0][0] != '-') 
            || (!isdigit(vec[1][0]) &amp;&amp; vec[1][0] != '-'))
        {
            return false;
        }

        for (int i = 1; i &lt; vec[0].size(); i++)
        {
            if (isdigit(vec[0][i]) || vec[0][i] == '.')
            {
                continue;
            }
            else
            {
                return false;
            }
        }
        for (int i = 1; i &lt; vec[1].size(); i++)
        {
            if (isdigit(vec[1][i]) || vec[1][i] == '.')
            {
                continue;
            }
            else
            {
                return false;
            }
        }
    }
    else
    {
        return false;
    }
    return true;
}
bool check_op(string &amp;input)
{
    if (input == &quot;+&quot; || input == &quot;-&quot; || input == &quot;*&quot; || input == &quot;/&quot;)
    {
        return true;
    }
    else
    {
        return false;
    }
}
int main()
{
    string input;
    Complex result_complex;
    char op = ' ';
    int process = 0;
    while (getline(cin, input))
    {
        if ((process % 2 == 1) &amp;&amp; (check_op(input) == true))
        {
            op = input[0];
        }
        else if ((process % 2 == 0) &amp;&amp; (check_complex(input) == true))
        {
            double real, imag;
            stringstream ss(input);
            ss &gt;&gt; real &gt;&gt; imag;
            Complex current_complex(real, imag);
            switch (op)
            {
            case '+':
                result_complex = result_complex.add(current_complex);
                break;
            case '-':
                result_complex = result_complex.sub(current_complex);
                break;
            case '*':
                result_complex = result_complex.mul(current_complex);
                break;
            case '/':
                result_complex = result_complex.div(current_complex);
                break;
            case ' ':
                result_complex = current_complex;
                break;
            default:
                cerr &lt;&lt; &quot;Error: unknown operation\n&quot;;
                return 1;
            }
        }
        else
        {
            cout &lt;&lt; &quot;Error: Invalid input&quot; &lt;&lt; endl;
            return 0;
        }
        process = process + 1;
    }
    if (process = 0 || process % 2 == 1)
    {
        result_complex.print();
    }
    else
    {
        cout &lt;&lt; &quot;Error: Invalid input&quot; &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<h4 id="ta"><a class="header" href="#ta">TA</a></h4>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
using namespace std;

void prompt_invalid_input();

class Complex
{
private:
    // data members
    // save the real and imaginary parts of the complex number
    // with `double` precision
    double m_real;
    double m_imag;

public:
    // Constructor, initializes real and imaginary parts
    // hint: as like as `modify` function in examples
    // but use default constructor to implement
    Complex(const double &amp;arg_real = 0.0, const double &amp;arg_imag = 0.0)
    {
        m_real = arg_real;
        m_imag = arg_imag;
    }
    // print function
    // note: be careful about the format of output
    // especially the ` ` and newline (endl)
    void print()
    {
        cout &lt;&lt; m_real &lt;&lt; &quot; + &quot; &lt;&lt; m_imag &lt;&lt; &quot; i&quot; &lt;&lt; endl;
    }
    // add function
    Complex add(const Complex &amp;arg_c)
    {
        Complex c;
        c.m_real = m_real + arg_c.m_real;
        c.m_imag = m_imag + arg_c.m_imag;
        return c;
    }
    // subtract function
    Complex sub(const Complex &amp;arg_c)
    {
        Complex c;
        c.m_real = m_real - arg_c.m_real;
        c.m_imag = m_imag - arg_c.m_imag;
        return c;
    }
    // multiply function
    Complex mul(const Complex &amp;arg_c)
    {
        Complex c;
        c.m_real = m_real * arg_c.m_real - m_imag * arg_c.m_imag;
        c.m_imag = m_real * arg_c.m_imag + m_imag * arg_c.m_real;
        return c;
    }
    // divide function
    Complex div(const Complex &amp;arg_c)
    {
        if (arg_c.m_real == 0 &amp;&amp; arg_c.m_imag == 0)
            prompt_invalid_input();

        Complex c;
        c.m_real = (m_real * arg_c.m_real + m_imag * arg_c.m_imag) 
                    / (arg_c.m_real * arg_c.m_real + arg_c.m_imag * arg_c.m_imag);
        c.m_imag = (m_imag * arg_c.m_real - m_real * arg_c.m_imag) 
                    / (arg_c.m_real * arg_c.m_real + arg_c.m_imag * arg_c.m_imag);
        return c;
    }
    // parse function
    // note: use `stringstream` and `&gt;&gt;` to parse the string to double
    // and use `stringstream::fail()` to check the conversion is successful
    bool parse(const string &amp;arg_str)
    {
        // Check if the number of tokens = 2
        for (int i = 0, n = 0; i &lt; arg_str.length(); i++)
        {
            if (arg_str[i] == ' ')
                n++;
            if (n &gt; 1 || (n == 0 &amp;&amp; i == arg_str.length() - 1))
                return false;
        }

        stringstream ss(arg_str);
        double input_real, input_imag;

        ss &gt;&gt; input_real;
        if (ss.fail())
        {
            return false;
        }

        ss &gt;&gt; input_imag;
        if (ss.fail())
        {
            return false;
        }
        m_real = input_real;
        m_imag = input_imag;
        return ss.eof();
    }
};
// parse op global function
char parse_op(const string &amp;arg_str)
{
    switch (arg_str[0])
    {
    case '+':
    case '-':
    case '*':
    case '/':
        return arg_str[0];
    default:
        return '\0'; // invalid op
    }
}
// prompt invalid input and exit
void prompt_invalid_input()
{
    cout &lt;&lt; &quot;Error: Invalid input&quot; &lt;&lt; endl;
    exit(1);
}
int main()
{
    string input;
    Complex result_complex;
    char op = ' ';                   // default op is ' '
    bool is_process_continue = true; // current process should be continued or not
    while (is_process_continue)
    {
        // get the first input
        getline(cin, input);
        // check is not end of input
        if (input.empty() || cin.eof())
        {
            prompt_invalid_input();
        }
        // check the input is a valid complex number
        Complex input_complex;
        bool is_valid_complex = input_complex.parse(input);
        if (!is_valid_complex)
        {
            prompt_invalid_input();
        }
        // calculate the result
        switch (op)
        {
        case '+':
            result_complex = result_complex.add(input_complex);
            break;
        case '-':
            result_complex = result_complex.sub(input_complex);
            break;
        case '*':
            result_complex = result_complex.mul(input_complex);
            break;
        case '/':
            result_complex = result_complex.div(input_complex);
            break;
        case ' ':
            result_complex = input_complex;
            break;
        default:
            prompt_invalid_input();
        }
        // get the second input
        getline(cin, input);
        // check is end of input or not
        if (input.empty() || cin.eof())
        {
            is_process_continue = false;
        }
        // if not end of input, check the input is a valid operator
        else
        {
            op = parse_op(input);
            if (op == '\0')
            {
                prompt_invalid_input();
            }
        }
    }
    result_complex.print();
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
marp: true
author: Yi-Wen Hung
theme: default
headingDivider: 2
paginate: true
-->
<h1 id="collaborate-with-other-classes"><a class="header" href="#collaborate-with-other-classes">Collaborate with Other Classes</a></h1>
<blockquote>
<p>Slides version: <a href="class/./lecture5_slides.html">lecture5_slides.html</a>
Website version: <a href="class/./lecture5.html">lecture5.html</a></p>
</blockquote>
<ul>
<li>Interaction in other classes</li>
<li>How to use a class with another class
<ul>
<li>as an argument</li>
<li>use member functions</li>
<li>use <code>friend</code> class</li>
</ul>
</li>
<li>How to use a class in another function
<ul>
<li>use getter and setter</li>
<li>use <code>friend</code> function</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li><code>friend</code> function
<ul>
<li>syntax &amp; example</li>
</ul>
</li>
<li>Example
<ul>
<li>Example: Triangle (again)</li>
<li>Example: Vector (again)</li>
<li>Example: Fixed Point Number &amp; Fixed Point Number Calculator</li>
</ul>
</li>
<li>Pratices</li>
</ul>
<h2 id="interaction-with-other-classes"><a class="header" href="#interaction-with-other-classes">Interaction with other classes</a></h2>
<p>User can use multiple classes to process data.</p>
<ul>
<li>use <code>std::vector</code> to store multiple <code>std::string</code> data</li>
<li>compute the intersection of a line and a point in a 2D plane with user-defined <code>line</code> and <code>point</code> classes</li>
<li>etc.</li>
</ul>
<h2 id="how-to-use-a-class-in-another-class"><a class="header" href="#how-to-use-a-class-in-another-class">How to use a class in another class</a></h2>
<p>To use a class with another class:</p>
<ul>
<li>as an argument</li>
<li>use member functions</li>
<li><code>friend</code> class</li>
</ul>
<hr />
<h3 id="use-a-class-as-an-argument"><a class="header" href="#use-a-class-as-an-argument">Use a class as an argument</a></h3>
<p>Example: <code>Point_2D</code> and <code>Line_2D</code> (v1, partial)</p>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Point_2D // a point on a 2D plane
{
private:
    // record the x coordinate
    int m_x;
    // record the y coordinate
    int m_y;
public:
    // Constructor
    Point_2D(const int &amp;arg_x = 0, const int &amp;arg_y = 0);
    Point_2D(const Point_2D &amp;arg_point);
   
    // Member functions
    void set_x(const int &amp;arg_x);
    void set_y(const int &amp;arg_y);
    void set(const int &amp;arg_x, const int &amp;arg_y);
    int get_x() const;
    int get_y() const;
};
</code></pre>
<hr />
<pre><code class="language-c++">class Line_2D // a line on a 2D plane
{
private:
    // record the start point
    Point_2D m_start;
    // record the end point
    Point_2D m_end;
public:
    // Constructor
    Line_2D(const Point_2D &amp;arg_start, const Point_2D &amp;arg_end);
    Line_2D(const Line_2D &amp;arg_line);
   
    // Member functions
    void set_start(const Point_2D &amp;arg_start);
    void set_end(const Point_2D &amp;arg_end);
    void set(const Point_2D &amp;arg_start, const Point_2D &amp;arg_end);
    Point_2D get_start() const;
    Point_2D get_end() const;
};
</code></pre>
<hr />
<h3 id="use-member-functions-of-a-class"><a class="header" href="#use-member-functions-of-a-class">Use member functions of a class</a></h3>
<p>Example: <code>Point_2D</code> and <code>Line_2D</code> (v2, partial)</p>
<pre><code class="language-c++">class Line_2D // a line on a 2D plane
{
private:
    // record the start point
    Point_2D m_start;
    // record the end point
    Point_2D m_end;
public:
    // Constructor
    Line_2D(const Point_2D &amp;arg_start, const Point_2D &amp;arg_end);
    Line_2D(const Line_2D &amp;arg_line);
    // use Point_2D's constructor to set the start and end point
    Line_2D(int arg_start_x = 0, int arg_start_y = 0,
            int arg_end_x = 0, int arg_end_y = 0);
</code></pre>
<hr />
<pre><code class="language-c++">    // Member functions
    void set_start(const Point_2D &amp;arg_start);
    void set_end(const Point_2D &amp;arg_end);
    void set(const Point_2D &amp;arg_start, const Point_2D &amp;arg_end);
    // use member function to set the x and y coordinates
    void set_start(int arg_x, int arg_y)
    {
        m_start.set_x(arg_x);
        m_start.set_y(arg_y);
    }
    void set_end(int arg_x, int arg_y)
    {
        m_end.set_x(arg_x);
        m_end.set_y(arg_y);
    }
    void set(int arg_start_x, int arg_start_y,
             int arg_end_x, int arg_end_y)
    {
        m_start.set_x(arg_start_x);
        m_start.set_y(arg_start_y);
        m_end.set_x(arg_end_x);
        m_end.set_y(arg_end_y);
    }
</code></pre>
<hr />
<pre><code class="language-c++">    Point_2D get_start() const;
    Point_2D get_end() const;
    // use member function to get the x and y coordinates
    int get_start_x() const { return m_start.get_x(); }
    int get_start_y() const { return m_start.get_y(); }
    int get_end_x() const { return m_end.get_x(); }
    int get_end_y() const { return m_end.get_y(); }
};
</code></pre>
<hr />
<h3 id="use-friend-class"><a class="header" href="#use-friend-class">Use <code>friend</code> class</a></h3>
<p>Example: <code>Point_2D</code> and <code>Line_2D</code> (v3, partial)</p>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Point_2D // a point on a 2D plane
{
private:
    // record the x coordinate
    int m_x;
    // record the y coordinate
    int m_y;
public:
    // Constructor
    Point_2D(const int &amp;arg_x = 0, const int &amp;arg_y = 0);
    Point_2D(const Point_2D &amp;arg_point);
   
    // Member functions
    void set_x(const int &amp;arg_x);
    void set_y(const int &amp;arg_y);
    void set(const int &amp;arg_x, const int &amp;arg_y);
    int get_x() const;
    int get_y() const;

    // Friend class, can access private members
    friend class Line_2D;
};
</code></pre>
<hr />
<pre><code class="language-c++">class Line_2D // a line on a 2D plane
{
private:
    // record the start point
    Point_2D m_start;
    // record the end point
    Point_2D m_end;
public:
    // Constructor
    Line_2D(const Point_2D &amp;arg_start, const Point_2D &amp;arg_end);
    Line_2D(const Line_2D &amp;arg_line);
    // use Point_2D's constructor to set the start and end point
    Line_2D(int arg_start_x = 0, int arg_start_y = 0,
            int arg_end_x = 0, int arg_end_y = 0);
</code></pre>
<hr />
<pre><code class="language-c++">    // Member functions
    void set_start(const Point_2D &amp;arg_start);
    void set_end(const Point_2D &amp;arg_end);
    void set(const Point_2D &amp;arg_start, const Point_2D &amp;arg_end);
    // set the x and y coordinates directly because of friend class
    void set_start(int arg_x, int arg_y) 
    { 
        m_start.m_x = arg_x; m_start.m_y = arg_y; 
    }
    void set_end(int arg_x, int arg_y)
    {
        m_end.m_x = arg_x; m_end.m_y = arg_y;
    }
    void set(int arg_start_x, int arg_start_y,
             int arg_end_x, int arg_end_y)
    {
        m_start.m_x = arg_start_x; m_start.m_y = arg_start_y;
        m_end.m_x = arg_end_x; m_end.m_y = arg_end_y;
    }
</code></pre>
<hr />
<pre><code class="language-c++">    Point_2D get_start() const;
    Point_2D get_end() const;
    // get the x and y coordinates directly because of friend class
    int get_start_x() const { return m_start.m_x; }
    int get_start_y() const { return m_start.m_y; }
    int get_end_x() const { return m_end.m_x; }
    int get_end_y() const { return m_end.m_y; }
};
</code></pre>
<h2 id="what-is-a-friend-class--friend-function"><a class="header" href="#what-is-a-friend-class--friend-function">What is a <code>friend</code> class &amp; <code>friend</code> function?</a></h2>
<p>Ref: <a href="https://www.geeksforgeeks.org/friend-class-function-cpp/">Friend class and function in C++ - GeeksforGeeks</a></p>
<blockquote>
<p>A friend class can access private and protected members of other class in which it is declared as friend. It is sometimes useful to allow a particular class to access private members of other class.</p>
</blockquote>
<h3 id="friend-class-example"><a class="header" href="#friend-class-example">Friend Class Example</a></h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
class A {
private:
    int a;

public:
    A() { a = 0; }
    friend class B; // Friend Class
};
</code></pre>
<hr />
<pre><code class="language-c++">class B {
private:
    int b;

public:
    void showA(A&amp; x)
    {
        // Since B is friend of A, it can access
        // private members of A
        std::cout &lt;&lt; &quot;A::a=&quot; &lt;&lt; x.a;
    }
};

int main()
{
    A a;
    B b;
    b.showA(a);
    return 0;
}
</code></pre>
<hr />
<h3 id="friend-function-example"><a class="header" href="#friend-function-example">Friend Function Example</a></h3>
<pre><code class="language-c++">#include &lt;iostream&gt;

class B; // Forward declaration, used in class A

class A {
public:
	void showB(B&amp;);
};

class B {
private:
	int b;

public:
	B() { b = 0; }
	friend void A::showB(B&amp; x); // Friend function
};
</code></pre>
<hr />
<pre><code class="language-c++">void A::showB(B&amp; x)
{
	// Since showB() is friend of B, it can
	// access private members of B
	std::cout &lt;&lt; &quot;B::b = &quot; &lt;&lt; x.b;
}

int main()
{
	A a;
	B x;
	a.showB(x);
	return 0;
}
</code></pre>
<hr />
<h3 id="friend-function-example-global"><a class="header" href="#friend-function-example-global">Friend Function Example (global)</a></h3>
<pre><code class="language-c++">#include &lt;iostream&gt;

class A {
	int a;

public:
	A() { a = 0; }

	// global friend function
	friend void showA(A&amp;);
};

void showA(A&amp; x)
{
	// Since showA() is a friend, it can access
	// private members of A
	std::cout &lt;&lt; &quot;A::a=&quot; &lt;&lt; x.a;
}

int main()
{
	A a;
	showA(a);
	return 0;
}

</code></pre>
<h2 id="how-to-use-a-class-in-another-function"><a class="header" href="#how-to-use-a-class-in-another-function">How to use a class in another function</a></h2>
<p>To use a class with another function:</p>
<ul>
<li>use getter and setter</li>
<li>use <code>friend</code> function</li>
</ul>
<hr />
<h3 id="use-getter-and-setter-of-a-class"><a class="header" href="#use-getter-and-setter-of-a-class">Use getter and setter of a class</a></h3>
<p>Example: compare two <code>Point_2D</code> objects</p>
<pre><code class="language-c++">int compare(const Point_2D &amp;arg_point1, const Point_2D &amp;arg_point2)
{
    // compare the x coordinates
    if (arg_point1.get_x() &lt; arg_point2.get_x())
    {
        return -1;
    }
    else if (arg_point1.get_x() &gt; arg_point2.get_x())
    {
        return 1;
    }
    else
    {
        // compare the y coordinates
        if (arg_point1.get_y() &lt; arg_point2.get_y())
        {
            return -1;
        }
        else if (arg_point1.get_y() &gt; arg_point2.get_y())
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }
}
</code></pre>
<hr />
<h3 id="use-friend-function"><a class="header" href="#use-friend-function">Use <code>friend</code> function</a></h3>
<p>Example: compare two <code>Point_2D</code> objects with <code>friend</code> function</p>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Point_2D // a point on a 2D plane
{
private:
    // record the x coordinate
    int m_x;
    // record the y coordinate
    int m_y;
public:
    // Constructor
    Point_2D(const int &amp;arg_x = 0, const int &amp;arg_y = 0);
    Point_2D(const Point_2D &amp;arg_point);
   
    // Member functions
    void set_x(const int &amp;arg_x);
    void set_y(const int &amp;arg_y);
    void set(const int &amp;arg_x, const int &amp;arg_y);
    int get_x() const;
    int get_y() const;

    // Friend function, can access private members
    friend int compare(const Point_2D &amp;arg_point1, const Point_2D &amp;arg_point2);
};
</code></pre>
<hr />
<pre><code class="language-c++">int compare(const Point_2D &amp;arg_point1, const Point_2D &amp;arg_point2)
{
    // compare the x coordinates
    if (arg_point1.m_x &lt; arg_point2.m_x)
    {
        return -1;
    }
    else if (arg_point1.m_x &gt; arg_point2.m_x)
    {
        return 1;
    }
    else
    {
        // compare the y coordinates
        if (arg_point1.m_y &lt; arg_point2.m_y)
        {
            return -1;
        }
        else if (arg_point1.m_y &gt; arg_point2.m_y)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }
}
</code></pre>
<h2 id="example-1-triangle-again-a-hrefclasslecture5_ex1htmlsourcea"><a class="header" href="#example-1-triangle-again-a-hrefclasslecture5_ex1htmlsourcea">Example 1: Triangle (again) [<a href="class/./lecture5_ex1.html">Source</a>]</a></h2>
<p>A Triangle:</p>
<ul>
<li>contains 3 points</li>
<li>on the 2D plane</li>
<li>need to be able to calculate the area</li>
<li>need to be initialized, printed, and modified</li>
</ul>
<h2 id="example-2-vector-again-a-hrefclasslecture5_ex2htmlsourcea"><a class="header" href="#example-2-vector-again-a-hrefclasslecture5_ex2htmlsourcea">Example 2: Vector (again) [<a href="class/./lecture5_ex2.html">Source</a>]</a></h2>
<p>A Vector:</p>
<ul>
<li>contains 3 factors of the 3 basis $\bold{i}$, $\bold{j}$, $\bold{k}$</li>
<li>need to be able to calculate the length</li>
<li>need to be able to calculate the dot, cross product</li>
<li>need to be initialized, printed, and modified</li>
</ul>
<h2 id="example-3-fixed-point-number--fixed-point-number-calculator-a-hrefclasslecture5_ex3htmlsourcea"><a class="header" href="#example-3-fixed-point-number--fixed-point-number-calculator-a-hrefclasslecture5_ex3htmlsourcea">Example 3: Fixed Point Number &amp; Fixed Point Number Calculator [<a href="class/./lecture5_ex3.html">Source</a>]</a></h2>
<p>A Fixed Point Number:</p>
<ul>
<li>contains a integer part, a fractional part, and a precision</li>
<li>need to be able to calculate the sum, difference</li>
<li>need to be able to convert to/from string, <code>float</code>, and <code>double</code></li>
<li>need to be initialized, printed, and modified</li>
</ul>
<hr />
<p>A Fixed Point Number Calculator:</p>
<ul>
<li>contains current value, input value, and operation</li>
<li>need to be able to set the input value</li>
<li>need to be able to set the operation</li>
<li>need to be able to calculate the result</li>
<li>need to be able to clear the input value</li>
<li>need to be initialized</li>
<li>need to be able to get all information</li>
</ul>
<h2 id="pratices-2"><a class="header" href="#pratices-2">Pratices</a></h2>
<ul>
<li>Pratice 1: 參考 <code>Triangle</code> class, 如果需要支援多維度的座標系以及四邊形等其他圖形需要如何修改?</li>
<li>Pratice 2: 參考 <code>Vector</code> class, 如果需要支援多維度的座標系上、或是轉換 basis 為其他 vector 要如何修改?</li>
<li>Pratice 3: 參考 <code>Fp_Calc</code> class, 如果需要支援乘除法、超過 <code>Fixed_Point</code> 可儲存的範圍要如何設計相關的 member function?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-1-trangle-3"><a class="header" href="#example-1-trangle-3">Example 1: Trangle</a></h1>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Triangle_2D; // forward declaration

class Point_2D // the class name
// we use first upper case letter to indicate a class
{
private: // private data members &amp; member functions
    // Data members
    // we use `m_` to indicate a data member

    // record the x coordinate
    double m_x;
    // record the y coordinate
    double m_y;

    // Member functions
    // we use `_` to indicate a member function

    // check if the point is valid
    void _check_validity();

public: // public member functions
    // Constructor

    // Constructor &amp; Default constructor
    // initialize data members, with default values
    // accessable to const object by default
    Point_2D(const double &amp;arg_x = 0, const double &amp;arg_y = 0);

    // Copy constructor
    // copy the data members from the given object
    // accessable to const object by default
    Point_2D(const Point_2D &amp;arg_point);

    // Destructor
    ~Point_2D() // destructor
    {
        // do nothing, because we don't
        // have any dynamic memory
    }

    // Member functions
    // we use lower case letter to indicate a member function
    // also, we just define the function declaration
    // and leave the definition to the end of the class

    // print the x and y coordinate in format (x, y)
    // accessable to const object
    void print() const;
    // modify the x and y coordinate
    // we use `arg_` to indicate the arguments
    // and re-write with setter
    void set_x(const double &amp;arg_x);
    void set_y(const double &amp;arg_y);
    void set(const double &amp;arg_x, const double &amp;arg_y);
    // get the x coordinate and y coordinate
    // accessable to const object
    double get_x() const;
    double get_y() const;

    // friend class
    friend class Triangle_2D;
};

// Triangle_2D class declaration
class Triangle_2D
{
private:
    // define three points of the Triangle_2D
    // in array of Point_2D format
    Point_2D m_point[3];

    // check &amp; correct the Triangle_2D points to counterclockwise order
    void _check_points();

public:
    // Constructor
    Triangle_2D(const double &amp;arg_x0 = 0.0, const double &amp;arg_y0 = 0.0,
                const double &amp;arg_x1 = 0.0, const double &amp;arg_y1 = 0.0,
                const double &amp;arg_x2 = 0.0, const double &amp;arg_y2 = 0.0);

    // Copy constructor
    Triangle_2D(const Triangle_2D &amp;arg_triangle);

    // Destructor
    ~Triangle_2D()
    {
        // do nothing
    }

    // print the Triangle_2D
    void print();
    // modify the three points of the Triangle_2D
    void set_points(const double &amp;arg_x0, const double &amp;arg_y0,
                    const double &amp;arg_x1, const double &amp;arg_y1,
                    const double &amp;arg_x2, const double &amp;arg_y2);
    void set_point1(const double &amp;arg_x0, const double &amp;arg_y0);
    void set_point2(const double &amp;arg_x1, const double &amp;arg_y1);
    void set_point3(const double &amp;arg_x2, const double &amp;arg_y2);
    void set_x0(const double &amp;arg_x0);
    void set_y0(const double &amp;arg_y0);
    void set_x1(const double &amp;arg_x1);
    void set_y1(const double &amp;arg_y1);
    void set_x2(const double &amp;arg_x2);
    void set_y2(const double &amp;arg_y2);
    // get the three points of the Triangle_2D
    double get_x0() const;
    double get_y0() const;
    double get_x1() const;
    double get_y1() const;
    double get_x2() const;
    double get_y2() const;

    // calculate the area of the Triangle_2D
    double area();
};

// function definition

// check if the point is valid
void Point_2D::_check_validity()
{
    // check if the x coordinate is valid
    if (m_x &lt; 0)
    {
        // if not, set it to 0
        m_x = 0;
    }
    // check if the y coordinate is valid
    if (m_y &lt; 0)
    {
        // if not, set it to 0
        m_y = 0;
    }
}
// Constructor &amp; Default constructor
// initialize data members, with default values
Point_2D::Point_2D(const double &amp;arg_x, const double &amp;arg_y)
    // use `: var_name1(arg_var_name1), var_name2(arg_var_name2)`
    // to initialize data members
    : m_x(arg_x),
      m_y(arg_y)
{
    // check if the point is valid
    _check_validity();
}

// Copy constructor
// copy the data members from the given object
Point_2D::Point_2D(const Point_2D &amp;arg_point)
    : m_x(arg_point.m_x),
      m_y(arg_point.m_y)
{
    // check if the point is valid
    _check_validity();
}
// print the x and y coordinate
// accessable to const object
void Point_2D::print() const
{
    cout &lt;&lt; &quot;(&quot; &lt;&lt; m_x &lt;&lt; &quot;, &quot; &lt;&lt; m_y &lt;&lt; &quot;)&quot;;
}

// modify the x and y coordinate
// we use `arg_` to indicate the arguments
// and re-write with setter
void Point_2D::set_x(const double &amp;arg_x)
{
    m_x = arg_x;
    // check if the point is valid
    _check_validity();
}
void Point_2D::set_y(const double &amp;arg_y)
{
    m_y = arg_y;
    // check if the point is valid
    _check_validity();
}
void Point_2D::set(const double &amp;arg_x, const double &amp;arg_y)
{
    m_x = arg_x;
    m_y = arg_y;
    // check if the point is valid
    _check_validity();
}

// get the x coordinate and y coordinate
// accessable to const object
double Point_2D::get_x() const
{
    return m_x;
}
double Point_2D::get_y() const
{
    return m_y;
}

// Triangle_2D class implementation

// check &amp; correct the Triangle_2D points to counterclockwise order
void Triangle_2D::_check_points()
{
    // calculate the area of the Triangle_2D
    double area = m_point[0].m_x * m_point[1].m_y +
                  m_point[1].m_x * m_point[2].m_y +
                  m_point[2].m_x * m_point[0].m_y -
                  m_point[0].m_x * m_point[2].m_y -
                  m_point[1].m_x * m_point[0].m_y -
                  m_point[2].m_x * m_point[1].m_y;

    // if the area is negative, swap the points
    if (area &lt; 0.0)
    {
        Point_2D temp = m_point[0];
        m_point[0] = m_point[1];
        m_point[1] = temp;
    }
}

// Constructor
Triangle_2D::Triangle_2D(const double &amp;arg_x0, const double &amp;arg_y0,
                         const double &amp;arg_x1, const double &amp;arg_y1,
                         const double &amp;arg_x2, const double &amp;arg_y2)
    : m_point{Point_2D(arg_x0, arg_y0),
              Point_2D(arg_x1, arg_y1),
              Point_2D(arg_x2, arg_y2)} // init the array with {}
{
    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}

// Copy constructor
Triangle_2D::Triangle_2D(const Triangle_2D &amp;arg_triangle)
    : m_point{Point_2D(arg_triangle.m_point[0]),
              Point_2D(arg_triangle.m_point[1]),
              Point_2D(arg_triangle.m_point[2])} // init the array with {}
{
}

// print the Triangle_2D
void Triangle_2D::print()
{
    // print the three points of the Triangle_2D
    cout &lt;&lt; &quot;Triangle_2D: &quot; &lt;&lt; endl;
    for (int i = 0; i &lt; 3; i++)
    {
        m_point[i].print();
        cout &lt;&lt; endl;
    }
}

// set the three points of the Triangle_2D
void Triangle_2D::set_points(const double &amp;arg_x0, const double &amp;arg_y0,
                             const double &amp;arg_x1, const double &amp;arg_y1,
                             const double &amp;arg_x2, const double &amp;arg_y2)
{
    m_point[0].set(arg_x0, arg_y0);
    m_point[1].set(arg_x1, arg_y1);
    m_point[2].set(arg_x2, arg_y2);

    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}
void Triangle_2D::set_point1(const double &amp;arg_x0, const double &amp;arg_y0)
{
    m_point[0].set(arg_x0, arg_y0);

    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}
void Triangle_2D::set_point2(const double &amp;arg_x1, const double &amp;arg_y1)
{
    m_point[1].set(arg_x1, arg_y1);

    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}
void Triangle_2D::set_point3(const double &amp;arg_x2, const double &amp;arg_y2)
{
    m_point[2].set(arg_x2, arg_y2);

    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}
void Triangle_2D::set_x0(const double &amp;arg_x0)
{
    m_point[0].m_x = arg_x0;

    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}
void Triangle_2D::set_y0(const double &amp;arg_y0)
{
    m_point[0].m_y = arg_y0;

    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}
void Triangle_2D::set_x1(const double &amp;arg_x1)
{
    m_point[1].m_x = arg_x1;

    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}
void Triangle_2D::set_y1(const double &amp;arg_y1)
{
    m_point[1].m_y = arg_y1;

    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}
void Triangle_2D::set_x2(const double &amp;arg_x2)
{
    m_point[2].m_x = arg_x2;

    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}
void Triangle_2D::set_y2(const double &amp;arg_y2)
{
    m_point[2].m_y = arg_y2;

    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}

// get the three points of the Triangle_2D
double Triangle_2D::get_x0() const
{
    return m_point[0].m_x;
}
double Triangle_2D::get_y0() const
{
    return m_point[0].m_y;
}
double Triangle_2D::get_x1() const
{
    return m_point[1].m_x;
}
double Triangle_2D::get_y1() const
{
    return m_point[1].m_y;
}
double Triangle_2D::get_x2() const
{
    return m_point[2].m_x;
}
double Triangle_2D::get_y2() const
{
    return m_point[2].m_y;
}

// calculate the area of the Triangle_2D
double Triangle_2D::area()
{
    // calculate the area of the Triangle_2D
    return (m_point[0].m_x * m_point[1].m_y +
            m_point[1].m_x * m_point[2].m_y +
            m_point[2].m_x * m_point[0].m_y -
            m_point[0].m_x * m_point[2].m_y -
            m_point[1].m_x * m_point[0].m_y -
            m_point[2].m_x * m_point[1].m_y) /
           2.0;
}

// main function

int main()
{
    Triangle_2D t(1, 1, 2, 2, 0, 3);
    t.print();
    cout &lt;&lt; &quot;Area: &quot; &lt;&lt; t.area() &lt;&lt; endl;

    // change the points of the Triangle_2D
    t.set_points(1, 2, 2, 3, 3, 1);
    t.print();
    cout &lt;&lt; &quot;Area: &quot; &lt;&lt; t.area() &lt;&lt; endl;

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-2-vector-3"><a class="header" href="#example-2-vector-3">Example 2: Vector</a></h1>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;

class Vector_3D; // forward declaration

class Point_3D // represents a point in 3D space
{
private:
    // record the x coordinate
    double m_x;
    // record the y coordinate
    double m_y;
    // record the z coordinate
    double m_z;

public:
    Point_3D(const double &amp;arg_x = 0, const double &amp;arg_y = 0);
    Point_3D(const Point_3D &amp;arg_point);

    // Destructor
    ~Point_3D() // destructor
    {
        // do nothing, because we don't
        // have any dynamic memory
    }

    // print the x and y coordinate in format (x, y, z)
    void print() const;
    // modify the x, y and z coordinate
    void set_x(const double &amp;arg_x);
    void set_y(const double &amp;arg_y);
    void set_z(const double &amp;arg_z);
    void set(const double &amp;arg_x, const double &amp;arg_y, const double &amp;arg_z);
    // get the x, y and z coordinate
    double get_x() const;
    double get_y() const;
    double get_z() const;

    // friend class
    friend class Vector_3D;
};

// Vector_3D class declaration
class Vector_3D
{
private:
    // define the three factor of the basis vectors
    // on the x, y, z axes
    double m_x, m_y, m_z;

public:
    // Constructor
    Vector_3D(const double &amp;arg_x = 0.0, const double &amp;arg_y = 0.0,
              const double &amp;arg_z = 0.0);
    Vector_3D(const Point_3D &amp;arg_point1, const Point_3D &amp;arg_point2);

    // Copy constructor
    Vector_3D(const Vector_3D &amp;arg_vector);

    // Destructor
    ~Vector_3D()
    {
        // do nothing
    }

    // print the Vector_3D
    void print();

    // set the three factor of the basis vectors
    void set_vector(const double &amp;arg_x, const double &amp;arg_y,
                    const double &amp;arg_z);
    void set_vector(const Point_3D &amp;arg_point1, const Point_3D &amp;arg_point2);
    void set_x(const double &amp;arg_x);
    void set_y(const double &amp;arg_y);
    void set_z(const double &amp;arg_z);
    // get the three factor of the basis vectors
    double get_x() const;
    double get_y() const;
    double get_z() const;

    // calculate the length of the Vector_3D
    double length();
    // calculate the dot product of two vectors
    int dot(const Vector_3D &amp;);
    // calculate the cross product of two vectors
    Vector_3D cross(const Vector_3D &amp;);
};

// Vector_3D class implementation

// Constructor
Vector_3D::Vector_3D(const double &amp;arg_x, const double &amp;arg_y,
                     const double &amp;arg_z)
    : m_x(arg_x), m_y(arg_y), m_z(arg_z)
{
}

Vector_3D::Vector_3D(const Point_3D &amp;arg_point1, const Point_3D &amp;arg_point2)
    : m_x(arg_point2.m_x - arg_point1.m_x),
      m_y(arg_point2.m_y - arg_point1.m_y),
      m_z(arg_point2.m_z - arg_point1.m_z)
{
}

// Copy constructor
Vector_3D::Vector_3D(const Vector_3D &amp;arg_vector)
    : m_x(arg_vector.m_x), m_y(arg_vector.m_y), m_z(arg_vector.m_z)
{
}

// print the Vector_3D
void Vector_3D::print()
{
    // print the three factor of the basis vectors
    cout &lt;&lt; &quot;Vector_3D: &quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;(&quot; &lt;&lt; m_x &lt;&lt; &quot;, &quot; &lt;&lt; m_y &lt;&lt; &quot;, &quot; &lt;&lt; m_z &lt;&lt; &quot;)&quot; &lt;&lt; endl;
}

// set the three factor of the basis vectors
void Vector_3D::set_vector(const double &amp;arg_x, const double &amp;arg_y,
                           const double &amp;arg_z)
{
    m_x = arg_x;
    m_y = arg_y;
    m_z = arg_z;
}
void Vector_3D::set_vector(const Point_3D &amp;arg_point1,
                           const Point_3D &amp;arg_point2)
{
    m_x = arg_point2.m_x - arg_point1.m_x;
    m_y = arg_point2.m_y - arg_point1.m_y;
    m_z = arg_point2.m_z - arg_point1.m_z;
}
void Vector_3D::set_x(const double &amp;arg_x)
{
    m_x = arg_x;
}
void Vector_3D::set_y(const double &amp;arg_y)
{
    m_y = arg_y;
}
void Vector_3D::set_z(const double &amp;arg_z)
{
    m_z = arg_z;
}
// get the three factor of the basis vectors
double Vector_3D::get_x() const
{
    return m_x;
}
double Vector_3D::get_y() const
{
    return m_y;
}
double Vector_3D::get_z() const
{
    return m_z;
}

// calculate the length of the Vector_3D
double Vector_3D::length()
{
    // calculate the length of the Vector_3D
    return sqrt(m_x * m_x + m_y * m_y + m_z * m_z);
}

// calculate the dot product of two vectors
int Vector_3D::dot(const Vector_3D &amp;arg_v)
{
    // calculate the dot product of two vectors
    return m_x * arg_v.m_x + m_y * arg_v.m_y + m_z * arg_v.m_z;
}

// calculate the cross product of two vectors
Vector_3D Vector_3D::cross(const Vector_3D &amp;arg_v)
{
    // calculate the cross product of two vectors
    Vector_3D v;
    v.m_x = m_y * arg_v.m_z - m_z * arg_v.m_y;
    v.m_y = m_z * arg_v.m_x - m_x * arg_v.m_z;
    v.m_z = m_x * arg_v.m_y - m_y * arg_v.m_x;
    return v;
}

// main function

int main()
{
    Vector_3D v1;
    v1.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;Length of v1: &quot; &lt;&lt; v1.length() &lt;&lt; endl;
    v1.set_vector(1.0, 2.0, 3.0);
    v1.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;Length of v1: &quot; &lt;&lt; v1.length() &lt;&lt; endl;
    cout &lt;&lt; endl;

    Vector_3D v2(v1);
    v2.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;Length of v2: &quot; &lt;&lt; v2.length() &lt;&lt; endl;
    v2.set_vector(2.0, 3.0, 4.0);
    v2.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;Length of v2: &quot; &lt;&lt; v2.length() &lt;&lt; endl;
    cout &lt;&lt; endl;

    cout &lt;&lt; &quot;v1: &quot;;
    v1.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;v2: &quot;;
    v2.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;Dot: &quot; &lt;&lt; v1.dot(v2) &lt;&lt; endl;
    cout &lt;&lt; endl;

    v2.set_vector(1.0, 1.0, 1.0);
    Vector_3D v3(v1.cross(v2));
    cout &lt;&lt; &quot;v1: &quot;;
    v1.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;v2: &quot;;
    v2.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;Cross: &quot;;
    v3.print();
    cout &lt;&lt; endl;
    cout &lt;&lt; endl;

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-3-fixed-point-number--fixed-point-number-calculator"><a class="header" href="#example-3-fixed-point-number--fixed-point-number-calculator">Example 3: Fixed Point Number &amp; Fixed Point Number Calculator</a></h1>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cmath&gt;

using namespace std;

class Fp_Calc; // forward declaration

// Fixed point class declaration
class Fixed_Point
{
private:
    long long int m_int_part;
    long long int m_frac_part;
    unsigned int m_precision;

    // utility functions
    // set fixed point without checking
    void _set(const string &amp;arg_str);
    // normalize to m_precision
    void _normalize(const unsigned int arg_precision = 0);

public:
    Fixed_Point(const long long int &amp;arg_int_part = 0,
                const unsigned long long int &amp;arg_frac_part = 0,
                const unsigned int &amp;arg_precision = 9);
    Fixed_Point(const string &amp;arg_str);

    ~Fixed_Point();

    // getter &amp; setter
    void set_int_part(const long long int arg_int_part);
    void set_frac_part(const unsigned long long int arg_frac_part);
    void set_precision(const unsigned int arg_precision);
    void set(const long long int &amp;arg_int_part,
             const unsigned long long int &amp;arg_frac_part,
             const unsigned int &amp;arg_precision);
    void set(const string &amp;arg_str);
    void set(const double &amp;arg_double);
    void set(const float &amp;arg_float);
    long long int get_int_part() const;
    unsigned long long int get_frac_part() const;
    unsigned int get_precision() const;
    double get_double_value() const;
    float get_float_value() const;
    string get_string_value() const;

    // formatted output
    void print() const;

    // arithmetic operation
    Fixed_Point add(const Fixed_Point &amp;arg_fp) const;
    Fixed_Point sub(const Fixed_Point &amp;arg_fp) const;

    // friend class
    friend class Fp_Calc;
};

// Fixed point calculator class declaration
class Fp_Calc
{
private:
    // define current value
    Fixed_Point m_curr_val;
    // define input value
    Fixed_Point m_input_val;
    // define operation
    // `+`, `-`, `*`, `/`, and ` ` for none
    char m_op;
    // calculate result
    void _calc_result();

public:
    // Constructor
    Fp_Calc();
    // Copy constructor
    Fp_Calc(const Fp_Calc &amp;arg_int_calc);

    // Destructor
    ~Fp_Calc(){}; // no need to do anything

    // clear the input value
    void clear();
    // set the input value
    void set_input(const string &amp;arg_input);
    // add the input value to the current value
    void add();
    // subtract the input value from the current value
    void sub();
    // multiply the input value with the current value
    void mul();
    // divide the current value by the input value
    void div();
    // assign the input value to the current value
    void assign();
    // get the current value
    Fixed_Point get_curr_val();
    // get the current operation
    char get_op();
    // get the input value
    Fixed_Point get_input_val();
};

// Fixed point class implementation

// utility functions

// set fixed point without checking
void Fixed_Point::_set(const string &amp;arg_str)
{
    // set integer part
    m_int_part = stoll(arg_str.substr(0, arg_str.find('.')));
    // set fractional part
    m_frac_part = stoull(arg_str.substr(arg_str.find('.') + 1));
    // set precision
    m_precision = arg_str.length() - arg_str.find('.') - 1;
}

// normalize to precision
void Fixed_Point::_normalize(const unsigned int arg_precision)
{
    unsigned int temp_precision = arg_precision;
    // if precision is not specified, use the current precision
    if (arg_precision == 0)
    {
        temp_precision = m_precision;
    }
    // if precision is over the maximum, use the maximum
    else if (arg_precision &gt; 9)
    {
        temp_precision = 9;
    }
    else
    {
        temp_precision = arg_precision;
    }

    // update fractional part
    int precision_diff = temp_precision - m_precision;
    if (precision_diff &gt; 0)
    {
        m_frac_part *= pow(10, precision_diff);
    }
    else if (precision_diff &lt; 0)
    {
        m_frac_part /= pow(10, -precision_diff);
    }

    // update m_precision
    m_precision = temp_precision;

    // handle fractional part overflow

    // update integer part
    if (m_frac_part &gt;= pow(10, m_precision))
    {
        m_int_part += m_frac_part / pow(10, m_precision);
        m_frac_part %= (int)pow(10, m_precision);
    }

    // handle fractional part underflow

    // update integer part
    if (m_frac_part &lt; 0)
    {
        m_int_part -= 1;
        m_frac_part += pow(10, m_precision);
    }
}

// Constructor
Fixed_Point::Fixed_Point(const long long int &amp;arg_int_part,
                         const unsigned long long int &amp;arg_frac_part,
                         const unsigned int &amp;arg_precision)
    : m_int_part(arg_int_part),
      m_frac_part(arg_frac_part),
      m_precision(arg_precision)
{
}

Fixed_Point::Fixed_Point(const string &amp;arg_string)
{
    _set(arg_string);
    _normalize();
}

Fixed_Point::~Fixed_Point()
{
    // do nothing
}

// getter &amp; setter
void Fixed_Point::set_int_part(const long long int arg_int_part)
{
    m_int_part = arg_int_part;
}
void Fixed_Point::set_frac_part(const unsigned long long int arg_frac_part)
{
    m_frac_part = arg_frac_part;
    _normalize();
}
void Fixed_Point::set_precision(const unsigned int arg_precision)
{
    _normalize(arg_precision);
}
void Fixed_Point::set(const long long int &amp;arg_int_part,
                      const unsigned long long int &amp;arg_frac_part,
                      const unsigned int &amp;arg_precision)
{
    m_int_part = arg_int_part;
    m_frac_part = arg_frac_part;
    m_precision = arg_precision;
    _normalize();
}
void Fixed_Point::set(const string &amp;arg_str)
{
    _set(arg_str);
    _normalize();
}
void Fixed_Point::set(const double &amp;arg_double)
{
    _set(to_string(arg_double));
    _normalize();
}
void Fixed_Point::set(const float &amp;arg_float)
{
    _set(to_string(arg_float));
    _normalize();
}
long long int Fixed_Point::get_int_part() const
{
    return m_int_part;
}
unsigned long long int Fixed_Point::get_frac_part() const
{
    return m_frac_part;
}
unsigned int Fixed_Point::get_precision() const
{
    return m_precision;
}
double Fixed_Point::get_double_value() const
{
    return double(m_int_part) + double(m_frac_part) / pow(10, m_precision);
}
float Fixed_Point::get_float_value() const
{
    return float(m_int_part) + float(m_frac_part) / pow(10, m_precision);
}
string Fixed_Point::get_string_value() const
{
    string str_int_part = to_string(m_int_part);
    string str_frac_part = to_string(m_frac_part);
    // if precision is not specified, use the current precision
    if (m_precision == 0)
    {
        return str_int_part;
    }
    // if precision is 1, return integer part and fractional part
    else if (m_precision == 1)
    {
        return str_int_part + &quot;.&quot; + str_frac_part;
    }
    // if precision is over 1, return integer part and fractional part with
    // specified precision
    else
    {
        // if fractional part is 0, return integer part
        if (str_frac_part == &quot;0&quot;)
        {
            return str_int_part;
        }
        // if fractional part is not 0, return integer part and fractional part
        else
        {
            // if fractional part is less than precision, add 0 to the front
            if (str_frac_part.length() &lt; m_precision)
            {
                str_frac_part = string(m_precision - str_frac_part.length(), '0') + str_frac_part;
            }
            // if fractional part is more than precision, remove the end
            else if (str_frac_part.length() &gt; m_precision)
            {
                str_frac_part = str_frac_part.substr(0, m_precision);
            }
            return str_int_part + &quot;.&quot; + str_frac_part;
        }
    }
}

void Fixed_Point::print() const
{
    cout &lt;&lt; get_string_value();
}

Fixed_Point Fixed_Point::add(const Fixed_Point &amp;arg_fixed_point) const
{
    Fixed_Point result;
    Fixed_Point normalized_this(*this);
    Fixed_Point normalized_arg(arg_fixed_point);
    unsigned int max_precision = max(normalized_this.m_precision,
                                     normalized_arg.m_precision);
    normalized_this.set_precision(max_precision);
    normalized_arg.set_precision(max_precision);
    result.m_precision = max_precision;
    result.m_int_part = normalized_this.m_int_part + normalized_arg.m_int_part;
    result.m_frac_part = normalized_this.m_frac_part + normalized_arg.m_frac_part;
    result._normalize();
    return result;
}

Fixed_Point Fixed_Point::sub(const Fixed_Point &amp;arg_fixed_point) const
{
    Fixed_Point result;
    Fixed_Point normalized_this(*this);
    Fixed_Point normalized_arg(arg_fixed_point);
    unsigned int max_precision = max(normalized_this.m_precision,
                                     normalized_arg.m_precision);
    normalized_this.set_precision(max_precision);
    normalized_arg.set_precision(max_precision);
    result.m_precision = max_precision;
    result.m_int_part = normalized_this.m_int_part - normalized_arg.m_int_part;
    result.m_frac_part = normalized_this.m_frac_part - normalized_arg.m_frac_part;
    result._normalize();
    return result;
}

// Fp_Calc class implementation

// Constructor
Fp_Calc::Fp_Calc()
    : m_curr_val(), m_input_val(), m_op(' ')
{
}

// Copy constructor
Fp_Calc::Fp_Calc(const Fp_Calc &amp;arg_int_calc)
    : m_curr_val(arg_int_calc.m_curr_val),
      m_input_val(arg_int_calc.m_input_val),
      m_op(arg_int_calc.m_op)
{
}

// calculate the result
void Fp_Calc::_calc_result()
{
    switch (m_op)
    {
    case '+':
        m_curr_val = m_curr_val.add(m_input_val);
        break;
    case '-':
        m_curr_val = m_curr_val.sub(m_input_val);
        break;
    case ' ':
        m_curr_val = m_input_val;
        break;
    default:
        break;
    }
}

// clear the input value
void Fp_Calc::clear()
{
    m_input_val = Fixed_Point();
}

// set the input value
void Fp_Calc::set_input(const string &amp;arg_input_val)
{
    m_input_val = Fixed_Point(arg_input_val);
}

// add the input value to the current value
void Fp_Calc::add()
{
    _calc_result();
    m_op = '+';
}

// subtract the input value from the current value
void Fp_Calc::sub()
{
    _calc_result();
    m_op = '-';
}

// multiply the input value with the current value
void Fp_Calc::mul()
{
    _calc_result();
    m_op = '*';
}

// divide the current value by the input value
void Fp_Calc::div()
{
    _calc_result();
    m_op = '/';
}

// assign the input value to the current value
void Fp_Calc::assign()
{
    _calc_result();
    m_op = ' ';
}

// get the current value
Fixed_Point Fp_Calc::get_curr_val()
{
    return m_curr_val;
}

// get the current operation
char Fp_Calc::get_op()
{
    return m_op;
}

// get the input value
Fixed_Point Fp_Calc::get_input_val()
{
    return m_input_val;
}

// main function

int main()
{
    // create an instance of the class
    Fp_Calc calc;
    // set the input value
    calc.set_input(&quot;10.0&quot;);
    // get the input value
    calc.get_input_val().print();
    cout &lt;&lt; endl;
    // add the input value to the current value
    calc.add();
    // get current op
    cout &lt;&lt; '\'' &lt;&lt; calc.get_op() &lt;&lt; '\'' &lt;&lt; endl;
    // set another input value
    calc.set_input(&quot;20.0123&quot;);
    // get the input value
    calc.get_input_val().print();
    cout &lt;&lt; endl;
    // clear the input value
    calc.clear();
    cout &lt;&lt; &quot;clear&quot; &lt;&lt; endl;
    // set the input value
    calc.set_input(&quot;30.000456&quot;);
    // get the input value
    calc.get_input_val().print();
    cout &lt;&lt; endl;
    // subtract the input value from the current value
    calc.sub();
    // get current op
    cout &lt;&lt; '\'' &lt;&lt; calc.get_op() &lt;&lt; '\'' &lt;&lt; endl;
    // print the result
    calc.get_curr_val().print();
    cout &lt;&lt; endl;
    // set another input value
    calc.set_input(&quot;20.0123&quot;);
    // get the input value
    calc.get_input_val().print();
    cout &lt;&lt; endl;
    // compute the result
    calc.assign();
    // print the result
    calc.get_curr_val().print();
    cout &lt;&lt; endl;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
marp: true
author: Yi-Wen Hung
theme: default
headingDivider: 2
paginate: true
-->
<h1 id="operator--operator-overloading"><a class="header" href="#operator--operator-overloading">Operator &amp; Operator Overloading</a></h1>
<blockquote>
<p>Slides version: <a href="class/./lecture6_slides.html">lecture6_slides.html</a>
Website version: <a href="class/./lecture6.html">lecture6.html</a></p>
</blockquote>
<ul>
<li>What is Operator?</li>
<li>How to write/use your own operator? (Operator Overloading)
<ul>
<li>Syntax
<ul>
<li>Unary, Binary, Ternary</li>
</ul>
</li>
<li>Example</li>
</ul>
</li>
<li>Overloading other class's/global operator
<ul>
<li>Example: cout <code>&lt;&lt;</code> &amp; cin <code>&gt;&gt;</code> operator</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>How to design your own operator?
<ul>
<li>Guidelines</li>
</ul>
</li>
<li>Example
<ul>
<li>Example: Triangle (again)</li>
<li>Example: Vector (again)</li>
<li>Example: Fixed Point Number &amp; Fixed Point Number Calculator (again)</li>
</ul>
</li>
<li>Lab 6: Complex Number Calculator</li>
</ul>
<h2 id="what-is-operator"><a class="header" href="#what-is-operator">What is Operator?</a></h2>
<p>Ref: <a href="https://en.cppreference.com/w/cpp/language/operator_precedence">C++ Operator Precedence - cppreference.com</a></p>
<table><thead><tr><th align="center">precedence (partial)</th><th align="center">operator</th></tr></thead><tbody>
<tr><td align="center">1</td><td align="center"><code>a++</code>, <code>a--</code></td></tr>
<tr><td align="center">2</td><td align="center"><code>++a</code>, <code>--a</code></td></tr>
<tr><td align="center">3</td><td align="center"><code>+a</code>, <code>-a</code></td></tr>
<tr><td align="center"></td><td align="center"><code>!a</code>, <code>~a</code></td></tr>
<tr><td align="center"></td><td align="center"><code>(type)</code></td></tr>
<tr><td align="center">5</td><td align="center"><code>a * b</code>, <code>a / b</code>, <code>a % b</code></td></tr>
<tr><td align="center">6</td><td align="center"><code>a + b</code>, <code>a - b</code></td></tr>
<tr><td align="center">7</td><td align="center"><code>a &lt;&lt; b</code>, <code>a &gt;&gt; b</code></td></tr>
<tr><td align="center">9</td><td align="center"><code>a &lt; b</code>, <code>a &lt;= b</code>, <code>a &gt; b</code>, <code>a &gt;= b</code></td></tr>
<tr><td align="center">10</td><td align="center"><code>a == b</code>, <code>a != b</code></td></tr>
<tr><td align="center">11</td><td align="center"><code>a &amp; b</code></td></tr>
<tr><td align="center">12</td><td align="center"><code>a ^ b</code></td></tr>
<tr><td align="center">13</td><td align="center"><code>a \| b</code></td></tr>
<tr><td align="center">14</td><td align="center"><code>a &amp;&amp; b</code></td></tr>
<tr><td align="center">15</td><td align="center"><code>a \|\| b</code></td></tr>
<tr><td align="center">16</td><td align="center"><code>a ? b : c</code>, <code>a = b</code>, <code>a += b</code>, <code>a -= b</code>, <code>a *= b</code>, <code>a /= b</code></td></tr>
<tr><td align="center"></td><td align="center"><code>a %= b</code>, <code>a &lt;&lt;= b</code>, <code>a &gt;&gt;= b</code>, <code>a &amp;= b</code>, <code>a ^= b</code>, <code>a \|= b</code></td></tr>
</tbody></table>
<h2 id="how-to-writeuse-your-own-operator-operator-overloading"><a class="header" href="#how-to-writeuse-your-own-operator-operator-overloading">How to write/use your own operator? (Operator Overloading)</a></h2>
<h3 id="example-point_2d-partial"><a class="header" href="#example-point_2d-partial">Example: <code>Point_2D</code> (partial)</a></h3>
<ul>
<li>we want to compare two <code>Point_2D</code></li>
<li>we want to assign a <code>Point_2D</code> to another <code>Point_2D</code></li>
<li>we want to print/output a <code>Point_2D</code></li>
<li>we want to read/input a <code>Point_2D</code></li>
</ul>
<hr />
<p>naive implementation:</p>
<pre><code class="language-c++">class Point_2D
{
private:
/// ...

public:
/// ...
    // print the point in the format (x, y)
    void print() const;
    // read the point from input
    void read();
    // modify the x and y coordinate
    void set_x(const double &amp;arg_x);
    void set_y(const double &amp;arg_y);
    void set(const double &amp;arg_x, const double &amp;arg_y);
    // get the x coordinate and y coordinate
    double get_x() const;
    double get_y() const;
    // compare two points
    bool equal(const Point_2D &amp;arg_point) const;
    bool not_equal(const Point_2D &amp;arg_point) const;
    bool less(const Point_2D &amp;arg_point) const;
    bool greater(const Point_2D &amp;arg_point) const;
    bool less_equal(const Point_2D &amp;arg_point) const;
    bool greater_equal(const Point_2D &amp;arg_point) const;
    // assign the point with another point
    Point_2D assign(const Point_2D &amp;arg_point);
};
</code></pre>
<hr />
<p>Can we use <code>operator</code> like <code>&gt;</code>, <code>!=</code> to implement the above? Yes!</p>
<pre><code class="language-c++">class Point_2D
{
private:
/// ...

public:
/// ...
    // print the point in the format (x, y)
    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Point_2D &amp;arg_point);
    // read the point from input
    friend std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Point_2D &amp;arg_point);
    // modify the x and y coordinate
    void set_x(const double &amp;arg_x);
    void set_y(const double &amp;arg_y);
    void set(const double &amp;arg_x, const double &amp;arg_y);
    // get the x coordinate and y coordinate
    double get_x() const;
    double get_y() const;
    // compare two points
    bool operator==(const Point_2D &amp;arg_point) const;
    bool operator!=(const Point_2D &amp;arg_point) const;
    bool operator&lt;(const Point_2D &amp;arg_point) const;
    bool operator&gt;(const Point_2D &amp;arg_point) const;
    bool operator&lt;=(const Point_2D &amp;arg_point) const;
    bool operator&gt;=(const Point_2D &amp;arg_point) const;
    // assign the point with another point
    Point_2D operator=(const Point_2D &amp;arg_point);
};
</code></pre>
<hr />
<p>Usage:</p>
<pre><code class="language-c++">int main()
{
    Point_2D point1, point2;
    cin &gt;&gt; point1 &gt;&gt; point2;
    cout &lt;&lt; point1 &lt;&lt; point2 &lt;&lt; endl;
    if (point1 == point2)
    {
        std::cout &lt;&lt; &quot;point1 == point2&quot; &lt;&lt; std::endl;
    }
    else
    {
        std::cout &lt;&lt; &quot;point1 != point2&quot; &lt;&lt; std::endl;
    }
    point1 = point2;
    if (point1 == point2)
    {
        std::cout &lt;&lt; &quot;point1 == point2&quot; &lt;&lt; std::endl;
    }
    else
    {
        std::cout &lt;&lt; &quot;point1 != point2&quot; &lt;&lt; std::endl;
    }
    return 0;
}
</code></pre>
<hr />
<h3 id="syntax"><a class="header" href="#syntax">Syntax</a></h3>
<p>Ref: <a href="https://www.geeksforgeeks.org/operator-overloading-c/">Operator Overloading in C++ - GeeksforGeeks</a>, <a href="https://en.cppreference.com/w/cpp/language/operators">operator overloading - cppreference.com</a></p>
<ul>
<li><code>operator&lt;op&gt;</code>, where <code>&lt;op&gt;</code> is one of the following:
<ul>
<li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>^</code>, <code>&amp;</code>, <code>|</code>, <code>~</code>, <code>!</code>, <code>=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>^=</code>, <code>&amp;=</code>, <code>|=</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;=</code>, <code>&lt;&lt;=</code>, <code>==</code>, <code>!=</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&amp;&amp;</code>, <code>||</code>, <code>++</code>, <code>--</code>, <code>,</code>, <code>-&gt;*</code>, <code>-&gt;</code>, <code>( )</code>, <code>[ ]</code></li>
</ul>
</li>
<li><code>operator &lt;type&gt;</code>, where <code>&lt;type&gt;</code> is one of the following: (type conversion)
<ul>
<li><code>int</code>, <code>long</code>, <code>long long</code>, <code>unsigned</code>, <code>unsigned long</code>, <code>unsigned long long</code>, <code>float</code>, <code>double</code>, <code>long double</code>, <code>char</code>, <code>bool</code>, or user-defined type defined by <code>typedef</code></li>
</ul>
</li>
</ul>
<hr />
<h3 id="syntax-cont"><a class="header" href="#syntax-cont">Syntax (cont.)</a></h3>
<ul>
<li>2 types of operator:
<ul>
<li>unary operator: <code>(a).operator@()</code>, <code>operator@()</code>, <code>(a).operator@(0)</code>, <code>operator@(a, 0)</code></li>
<li>binary operator: <code>(a).operator@(b)</code>, <code>operator@(a, b)</code>, <code>(a).operator=(b)</code></li>
</ul>
</li>
</ul>
<hr />
<h3 id="example-member-function"><a class="header" href="#example-member-function">Example (member function)</a></h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

class Complex
{
private:
    int real, imag;

public:
    Complex(int r = 0, int i = 0)
    {
        real = r;
        imag = i;
    }
</code></pre>
<hr />
<pre><code class="language-c++">    // This is automatically called when '+' is used with
    // between two Complex objects
    Complex operator+(Complex const &amp;obj)
    {
        Complex res;
        res.real = real + obj.real;
        res.imag = imag + obj.imag;
        return res;
    }
    void print() { cout &lt;&lt; real &lt;&lt; &quot; + i&quot; &lt;&lt; imag &lt;&lt; '\n'; }
};

int main()
{
    Complex c1(10, 5), c2(2, 4);
    Complex c3 = c1 + c2;
    c3.print();
}
</code></pre>
<hr />
<h3 id="example-friend-function"><a class="header" href="#example-friend-function">Example (friend function)</a></h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

class Complex
{
private:
    int real, imag;

public:
    Complex(int r = 0, int i = 0)
    {
        real = r;
        imag = i;
    }
    void print() { cout &lt;&lt; real &lt;&lt; &quot; + i&quot; &lt;&lt; imag &lt;&lt; '\n'; }
</code></pre>
<hr />
<pre><code class="language-c++">    // The global operator function is made friend of this class so
    // that it can access private members
    friend Complex operator+(Complex const &amp;, Complex const &amp;);
};

Complex operator+(Complex const &amp;c1, Complex const &amp;c2)
{
    return Complex(c1.real + c2.real, c1.imag + c2.imag);
}

int main()
{
    Complex c1(10, 5), c2(2, 4);
    Complex c3 = c1 + c2;
    c3.print();
    return 0;
}
</code></pre>
<hr />
<h3 id="example-type-conversion"><a class="header" href="#example-type-conversion">Example (type conversion)</a></h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
class Fraction
{
private:
	int num, den;
public:
	Fraction(int n, int d) { num = n; den = d; }

	// Conversion operator: return float value of fraction
	operator float() const {
		return float(num) / float(den);
	}
};

int main() {
	Fraction f(2, 5);
	float val = f;
	cout &lt;&lt; val &lt;&lt; '\n';
	return 0;
}
</code></pre>
<h2 id="overloading-other-classsglobal-operator"><a class="header" href="#overloading-other-classsglobal-operator">Overloading other class's/global operator</a></h2>
<p>Ref: <a href="https://en.cppreference.com/w/cpp/language/operators">operator overloading - cppreference.com</a></p>
<ul>
<li>Global operator: To overload a global operator, you can define a function with the same name as the operator.</li>
<li>Other class's operator: To overload a member operator, you need to inherit from the class and define a function with the same name as the operator. (disscuss in Lecture 9)</li>
</ul>
<hr />
<h3 id="example-cout---cin--operator"><a class="header" href="#example-cout---cin--operator">Example: cout <code>&lt;&lt;</code> &amp; cin <code>&gt;&gt;</code> operator</a></h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class Point_2D
{
private:
    // record the x coordinate
    double m_x;
    // record the y coordinate
    double m_y;

public:
    // print the point in the format (x, y)
    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;arg_os, const Point_2D &amp;arg_point)
    {
        arg_os &lt;&lt; &quot;(&quot; &lt;&lt; arg_point.m_x &lt;&lt; &quot;, &quot; &lt;&lt; arg_point.m_y &lt;&lt; &quot;)&quot;;
        return arg_os;
    }
</code></pre>
<hr />
<pre><code class="language-c++">    // read the coordinate of a point from the input, format: (x, y) and ignore space
    friend std::istream &amp;operator&gt;&gt;(std::istream &amp;arg_is, Point_2D &amp;arg_point)
    {
        string str_x, str_y, temp;

        if (getline(arg_is, temp, '(')) // ignore the first '('
        {
            if (getline(arg_is, str_x, ','))
            {
                if (getline(arg_is, str_y, ')'))
                {
                    arg_point.m_x = stod(str_x);
                    arg_point.m_y = stod(str_y);
                }
            }
        }
        return arg_is;
    }
};
</code></pre>
<hr />
<pre><code class="language-c++">int main()
{
    Point_2D point;
    cin &gt;&gt; point;
    cout &lt;&lt; point &lt;&lt; endl;
    return 0;
}
</code></pre>
<p>Output:</p>
<pre><code class="language-console">$ ./a.out
(1.0, 2.0)⏎
(1, 2)
$
</code></pre>
<h2 id="how-to-design-your-own-operator"><a class="header" href="#how-to-design-your-own-operator">How to design your own operator?</a></h2>
<p>Ref: <a href="https://google.github.io/styleguide/cppguide.html#Operator_Overloading">Google C++ Style Guide</a>, This section is licensed under the Apache License 2.0</p>
<blockquote>
<p>Define overloaded operators only if their meaning is obvious, unsurprising, and consistent with the corresponding built-in operators.
For example, use <code>|</code> as a bitwise- or logical-or, not as a shell-style pipe.</p>
</blockquote>
<hr />
<blockquote>
<p>Define operators only on your own types. More precisely, define them in the same headers, .cc files, and namespaces as the types they operate on. That way, the operators are available wherever the type is, minimizing the risk of multiple definitions. 
If possible, avoid defining operators as templates, because they must satisfy this rule for any possible template arguments. 
If you define an operator, also define any related operators that make sense, and make sure they are defined consistently. For example, if you overload <code>&lt;</code>, overload all the comparison operators, and make sure <code>&lt;</code> and <code>&gt;</code> never return true for the same arguments.</p>
</blockquote>
<hr />
<blockquote>
<p>Prefer to define non-modifying binary operators as non-member functions. 
If a binary operator is defined as a class member, implicit conversions will apply to the right-hand argument, but not the left-hand one. It will confuse your users if <code>a &lt; b</code> compiles but <code>b &lt; a</code> doesn't.</p>
</blockquote>
<hr />
<blockquote>
<p>Don't go out of your way to avoid defining operator overloads. 
For example, prefer to define <code>==</code>, <code>=</code>, and <code>&lt;&lt;</code>, rather than <code>Equals()</code>, <code>CopyFrom()</code>, and <code>PrintTo()</code>. 
Conversely, don't define operator overloads just because other libraries expect them. 
For example, if your type doesn't have a natural ordering, but you want to store it in a <code>std::set</code>, use a custom comparator rather than overloading <code>&lt;</code>.</p>
</blockquote>
<hr />
<blockquote>
<p>Do not overload <code>&amp;&amp;</code>, <code>||</code>, <code>,</code> (comma), or unary <code>&amp;</code>. Do not overload <code>operator&quot;&quot;</code>, i.e., do not introduce user-defined literals. Do not use any such literals provided by others (including the standard library).</p>
</blockquote>
<hr />
<blockquote>
<p>Type conversion operators are covered in the section on <a href="https://google.github.io/styleguide/cppguide.html#Implicit_Conversions">implicit conversions</a>.
The <code>=</code> operator is covered in the section on <a href="https://google.github.io/styleguide/cppguide.html#Copyable_Movable_Types">copy constructors</a>.
Overloading <code>&lt;&lt;</code> for use with streams is covered in the section on <a href="https://google.github.io/styleguide/cppguide.html#Streams">streams</a>.
See also the rules on <a href="https://google.github.io/styleguide/cppguide.html#Function_Overloading">function overloading</a>, which apply to operator overloading as well.</p>
</blockquote>
<h2 id="example-1-triangle-again-a-hrefclasslecture6_ex1htmlsourcea"><a class="header" href="#example-1-triangle-again-a-hrefclasslecture6_ex1htmlsourcea">Example 1: Triangle (again) [<a href="class/./lecture6_ex1.html">Source</a>]</a></h2>
<p>A Triangle:</p>
<ul>
<li>contains 3 points</li>
<li>on the 2D plane</li>
<li>need to be able to calculate the area</li>
<li>need to be initialized, printed, and modified</li>
</ul>
<h2 id="example-2-vector-again-a-hrefclasslecture6_ex2htmlsourcea"><a class="header" href="#example-2-vector-again-a-hrefclasslecture6_ex2htmlsourcea">Example 2: Vector (again) [<a href="class/./lecture6_ex2.html">Source</a>]</a></h2>
<p>A Vector:</p>
<ul>
<li>contains 3 factors of the 3 basis $\bold{i}$, $\bold{j}$, $\bold{k}$</li>
<li>need to be able to calculate the length</li>
<li>need to be able to calculate the dot, cross product</li>
<li>need to be initialized, printed, and modified</li>
</ul>
<h2 id="example-3-fixed-point-number--fixed-point-number-calculator-again-a-hrefclasslecture6_ex3htmlsourcea"><a class="header" href="#example-3-fixed-point-number--fixed-point-number-calculator-again-a-hrefclasslecture6_ex3htmlsourcea">Example 3: Fixed Point Number &amp; Fixed Point Number Calculator (again) [<a href="class/./lecture6_ex3.html">Source</a>]</a></h2>
<p>A Fixed Point Number:</p>
<ul>
<li>contains a integer part, a fractional part, and a precision</li>
<li>need to be able to calculate the sum, difference</li>
<li>need to be able to convert to/from string, <code>float</code>, and <code>double</code></li>
<li>need to be initialized, printed, and modified</li>
</ul>
<hr />
<p>A Fixed Point Number Calculator:</p>
<ul>
<li>contains current value, input value, and operation</li>
<li>need to be able to set the input value</li>
<li>need to be able to set the operation</li>
<li>need to be able to calculate the result</li>
<li>need to be able to clear the input value</li>
<li>need to be initialized</li>
<li>need to be able to get all information</li>
</ul>
<h2 id="lab-6-a-hrefclasslablab6-1htmlcomplex-number-calculatora"><a class="header" href="#lab-6-a-hrefclasslablab6-1htmlcomplex-number-calculatora">Lab 6: <a href="class/./lab/lab6-1.html">Complex Number Calculator</a></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-1-trangle-4"><a class="header" href="#example-1-trangle-4">Example 1: Trangle</a></h1>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Triangle_2D; // forward declaration

class Point_2D // the class name
// we use first upper case letter to indicate a class
{
private: // private data members &amp; member functions
    // Data members
    // we use `m_` to indicate a data member

    // record the x coordinate
    double m_x;
    // record the y coordinate
    double m_y;

    // Member functions
    // we use `_` to indicate a member function

    // check if the point is valid
    void _check_validity();

public: // public member functions
    // Constructor

    // Constructor &amp; Default constructor
    // initialize data members, with default values
    // accessable to const object by default
    Point_2D(const double &amp;arg_x = 0, const double &amp;arg_y = 0);

    // Copy constructor
    // copy the data members from the given object
    // accessable to const object by default
    Point_2D(const Point_2D &amp;arg_point);

    // Destructor
    ~Point_2D() // destructor
    {
        // do nothing, because we don't
        // have any dynamic memory
    }

    // Member functions
    // we use lower case letter to indicate a member function
    // also, we just define the function declaration
    // and leave the definition to the end of the class

    // modify the x and y coordinate
    // we use `arg_` to indicate the arguments
    // and re-write with setter
    void set_x(const double &amp;arg_x);
    void set_y(const double &amp;arg_y);
    void set(const double &amp;arg_x, const double &amp;arg_y);
    // get the x coordinate and y coordinate
    // accessable to const object
    double get_x() const;
    double get_y() const;
    // // compare two points
    bool operator==(const Point_2D &amp;arg_point) const;
    bool operator!=(const Point_2D &amp;arg_point) const;
    bool operator&lt;(const Point_2D &amp;arg_point) const;
    bool operator&gt;(const Point_2D &amp;arg_point) const;
    bool operator&lt;=(const Point_2D &amp;arg_point) const;
    bool operator&gt;=(const Point_2D &amp;arg_point) const;
    // assign the point with another point
    Point_2D &amp;operator=(const Point_2D &amp;arg_point);

    // friend class
    friend class Triangle_2D;
    // friend function
    // print the x and y coordinate in format (x, y)
    // accessable to const object
    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;arg_os, const Point_2D &amp;arg_point);
    // read the coordinate of a point from the input, format: (x, y) and ignore space
    friend std::istream &amp;operator&gt;&gt;(std::istream &amp;arg_is, Point_2D &amp;arg_point);
};

// Triangle_2D class declaration
class Triangle_2D
{
private:
    // define three points of the Triangle_2D
    // in array of Point_2D format
    Point_2D m_point[3];

    // check &amp; correct the Triangle_2D points to counterclockwise order
    void _check_points();

public:
    // Constructor
    Triangle_2D(const double &amp;arg_x0 = 0.0, const double &amp;arg_y0 = 0.0,
                const double &amp;arg_x1 = 0.0, const double &amp;arg_y1 = 0.0,
                const double &amp;arg_x2 = 0.0, const double &amp;arg_y2 = 0.0);

    // Copy constructor
    Triangle_2D(const Triangle_2D &amp;arg_triangle);

    // Destructor
    ~Triangle_2D()
    {
        // do nothing
    }

    // modify the three points of the Triangle_2D
    void set_points(const double &amp;arg_x0, const double &amp;arg_y0,
                    const double &amp;arg_x1, const double &amp;arg_y1,
                    const double &amp;arg_x2, const double &amp;arg_y2);
    void set_point1(const double &amp;arg_x0, const double &amp;arg_y0);
    void set_point2(const double &amp;arg_x1, const double &amp;arg_y1);
    void set_point3(const double &amp;arg_x2, const double &amp;arg_y2);
    void set_x0(const double &amp;arg_x0);
    void set_y0(const double &amp;arg_y0);
    void set_x1(const double &amp;arg_x1);
    void set_y1(const double &amp;arg_y1);
    void set_x2(const double &amp;arg_x2);
    void set_y2(const double &amp;arg_y2);
    // get the three points of the Triangle_2D
    double get_x0() const;
    double get_y0() const;
    double get_x1() const;
    double get_y1() const;
    double get_x2() const;
    double get_y2() const;

    // calculate the area of the Triangle_2D
    double area();

    // print the Triangle_2D
    // format: ((x0, y0), (x1, y1), (x2, y2))
    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;arg_os, const Triangle_2D &amp;arg_tri);
    // read the coordinate of a point from the input,
    // format: ((x0, y0), (x1, y1), (x2, y2)) and ignore space
    friend std::istream &amp;operator&gt;&gt;(std::istream &amp;arg_is, Triangle_2D &amp;arg_tri);
};

// function definition

// check if the point is valid
void Point_2D::_check_validity()
{
    // check if the x coordinate is valid
    if (m_x &lt; 0)
    {
        // if not, set it to 0
        m_x = 0;
    }
    // check if the y coordinate is valid
    if (m_y &lt; 0)
    {
        // if not, set it to 0
        m_y = 0;
    }
}
// Constructor &amp; Default constructor
// initialize data members, with default values
Point_2D::Point_2D(const double &amp;arg_x, const double &amp;arg_y)
    // use `: var_name1(arg_var_name1), var_name2(arg_var_name2)`
    // to initialize data members
    : m_x(arg_x),
      m_y(arg_y)
{
    // check if the point is valid
    _check_validity();
}

// Copy constructor
// copy the data members from the given object
Point_2D::Point_2D(const Point_2D &amp;arg_point)
    : m_x(arg_point.m_x),
      m_y(arg_point.m_y)
{
    // check if the point is valid
    _check_validity();
}

// modify the x and y coordinate
// we use `arg_` to indicate the arguments
// and re-write with setter
void Point_2D::set_x(const double &amp;arg_x)
{
    m_x = arg_x;
    // check if the point is valid
    _check_validity();
}
void Point_2D::set_y(const double &amp;arg_y)
{
    m_y = arg_y;
    // check if the point is valid
    _check_validity();
}
void Point_2D::set(const double &amp;arg_x, const double &amp;arg_y)
{
    m_x = arg_x;
    m_y = arg_y;
    // check if the point is valid
    _check_validity();
}

// get the x coordinate and y coordinate
// accessable to const object
double Point_2D::get_x() const
{
    return m_x;
}
double Point_2D::get_y() const
{
    return m_y;
}

// // compare two points
bool Point_2D::operator==(const Point_2D &amp;arg_point) const
{
    // if the x and y coordinates are equal,
    // return true
    return (m_x == arg_point.m_x &amp;&amp; m_y == arg_point.m_y);
}
bool Point_2D::operator!=(const Point_2D &amp;arg_point) const
{
    return !(*this == arg_point);
}
bool Point_2D::operator&lt;(const Point_2D &amp;arg_point) const
{
    // if the x coordinate is smaller than the other point,
    // return true
    if (m_x &lt; arg_point.m_x)
    {
        return true;
    }
    // if the x coordinate is equal to the other point,
    // check if the y coordinate is smaller than the other point
    else if (m_x == arg_point.m_x)
    {
        // if the y coordinate is smaller, return true
        if (m_y &lt; arg_point.m_y)
        {
            return true;
        }
        // if the y coordinate is equal to the other point,
        // return false
        else if (m_y == arg_point.m_y)
        {
            return false;
        }
        // if the y coordinate is larger, return false
        else
        {
            return false;
        }
    }
    // if the x coordinate is larger, return false
    else
    {
        return false;
    }
}
bool Point_2D::operator&gt;(const Point_2D &amp;arg_point) const
{
    return !(*this &lt; arg_point || *this == arg_point);
}
bool Point_2D::operator&lt;=(const Point_2D &amp;arg_point) const
{
    return (*this &lt; arg_point || *this == arg_point);
}
bool Point_2D::operator&gt;=(const Point_2D &amp;arg_point) const
{
    return !(*this &lt; arg_point);
}
// assign the point with another point
Point_2D &amp;Point_2D::operator=(const Point_2D &amp;arg_point)
{
    // check if the point is valid
    _check_validity();
    // assign the x and y coordinate
    m_x = arg_point.m_x;
    m_y = arg_point.m_y;
    // check if the point is valid
    _check_validity();
    return *this;
}

// print the point in the format (x, y)
std::ostream &amp;operator&lt;&lt;(std::ostream &amp;arg_os, const Point_2D &amp;arg_point)
{
    arg_os &lt;&lt; &quot;(&quot; &lt;&lt; arg_point.m_x &lt;&lt; &quot;, &quot; &lt;&lt; arg_point.m_y &lt;&lt; &quot;)&quot;;
    return arg_os;
}

// read the coordinate of a point from the input, format: (x, y) and ignore space
std::istream &amp;operator&gt;&gt;(std::istream &amp;arg_is, Point_2D &amp;arg_point)
{
    string str_x, str_y, temp;

    if (getline(arg_is, temp, '(')) // ignore the first '('
    {
        if (getline(arg_is, str_x, ','))
        {
            if (getline(arg_is, str_y, ')'))
            {
                arg_point.m_x = stod(str_x);
                arg_point.m_y = stod(str_y);
            }
        }
    }

    // check if the point is valid
    arg_point._check_validity();

    return arg_is;
}

// Triangle_2D class implementation

// check &amp; correct the Triangle_2D points to counterclockwise order
void Triangle_2D::_check_points()
{
    // sort the points in ascending order
    for (int i = 0; i &lt; 3; i++)
    {
        for (int j = i + 1; j &lt; 3; j++)
        {
            if (m_point[i] &gt; m_point[j])
            {
                // swap the points
                Point_2D temp = m_point[i];
                m_point[i] = m_point[j];
                m_point[j] = temp;
            }
        }
    }

    // if the area is negative, swap the points
    if (area() &lt; 0.0)
    {
        Point_2D temp = m_point[0];
        m_point[0] = m_point[1];
        m_point[1] = temp;
    }
}

// Constructor
Triangle_2D::Triangle_2D(const double &amp;arg_x0, const double &amp;arg_y0,
                         const double &amp;arg_x1, const double &amp;arg_y1,
                         const double &amp;arg_x2, const double &amp;arg_y2)
    : m_point{Point_2D(arg_x0, arg_y0),
              Point_2D(arg_x1, arg_y1),
              Point_2D(arg_x2, arg_y2)} // init the array with {}
{
    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}

// Copy constructor
Triangle_2D::Triangle_2D(const Triangle_2D &amp;arg_triangle)
    : m_point{Point_2D(arg_triangle.m_point[0]),
              Point_2D(arg_triangle.m_point[1]),
              Point_2D(arg_triangle.m_point[2])} // init the array with {}
{
}

// set the three points of the Triangle_2D
void Triangle_2D::set_points(const double &amp;arg_x0, const double &amp;arg_y0,
                             const double &amp;arg_x1, const double &amp;arg_y1,
                             const double &amp;arg_x2, const double &amp;arg_y2)
{
    m_point[0].set(arg_x0, arg_y0);
    m_point[1].set(arg_x1, arg_y1);
    m_point[2].set(arg_x2, arg_y2);

    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}
void Triangle_2D::set_point1(const double &amp;arg_x0, const double &amp;arg_y0)
{
    m_point[0].set(arg_x0, arg_y0);

    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}
void Triangle_2D::set_point2(const double &amp;arg_x1, const double &amp;arg_y1)
{
    m_point[1].set(arg_x1, arg_y1);

    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}
void Triangle_2D::set_point3(const double &amp;arg_x2, const double &amp;arg_y2)
{
    m_point[2].set(arg_x2, arg_y2);

    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}
void Triangle_2D::set_x0(const double &amp;arg_x0)
{
    m_point[0].m_x = arg_x0;

    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}
void Triangle_2D::set_y0(const double &amp;arg_y0)
{
    m_point[0].m_y = arg_y0;

    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}
void Triangle_2D::set_x1(const double &amp;arg_x1)
{
    m_point[1].m_x = arg_x1;

    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}
void Triangle_2D::set_y1(const double &amp;arg_y1)
{
    m_point[1].m_y = arg_y1;

    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}
void Triangle_2D::set_x2(const double &amp;arg_x2)
{
    m_point[2].m_x = arg_x2;

    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}
void Triangle_2D::set_y2(const double &amp;arg_y2)
{
    m_point[2].m_y = arg_y2;

    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}

// get the three points of the Triangle_2D
double Triangle_2D::get_x0() const
{
    return m_point[0].m_x;
}
double Triangle_2D::get_y0() const
{
    return m_point[0].m_y;
}
double Triangle_2D::get_x1() const
{
    return m_point[1].m_x;
}
double Triangle_2D::get_y1() const
{
    return m_point[1].m_y;
}
double Triangle_2D::get_x2() const
{
    return m_point[2].m_x;
}
double Triangle_2D::get_y2() const
{
    return m_point[2].m_y;
}

// calculate the area of the Triangle_2D
double Triangle_2D::area()
{
    // calculate the area of the Triangle_2D
    return (m_point[0].m_x * m_point[1].m_y +
            m_point[1].m_x * m_point[2].m_y +
            m_point[2].m_x * m_point[0].m_y -
            m_point[0].m_x * m_point[2].m_y -
            m_point[1].m_x * m_point[0].m_y -
            m_point[2].m_x * m_point[1].m_y) /
           2.0;
}

// print the Triangle_2D
// format: ((x0, y0), (x1, y1), (x2, y2))
std::ostream &amp;operator&lt;&lt;(std::ostream &amp;arg_os, const Triangle_2D &amp;arg_tri)
{
    arg_os &lt;&lt; &quot;(&quot;;
    for (int i = 0; i &lt; 3; i++)
    {
        arg_os &lt;&lt; arg_tri.m_point[i];
        if (i &lt; 2)
            arg_os &lt;&lt; &quot;, &quot;;
    }
    arg_os &lt;&lt; &quot;)&quot;;
    return arg_os;
}
// read the coordinate of a point from the input,
// format: ((x0, y0), (x1, y1), (x2, y2)) and ignore space
std::istream &amp;operator&gt;&gt;(std::istream &amp;arg_is, Triangle_2D &amp;arg_tri)
{
    string temp;
    if (getline(arg_is, temp, '(')) // ignore the first '('
    {
        for (int i = 0; i &lt; 3; i++)
        {
            arg_is &gt;&gt; arg_tri.m_point[i];
            if (i &lt; 2)
            {
                getline(arg_is, temp, ','); // ignore the ','
            }
        }
        getline(arg_is, temp, ')'); // ignore the last ')'
    }

    // check &amp; correct the Triangle_2D points to counterclockwise order
    arg_tri._check_points();

    return arg_is;
}

// main function

int main()
{
    Triangle_2D t(1, 1, 2, 2, 0, 3);
    cout &lt;&lt; t &lt;&lt; endl;
    cout &lt;&lt; &quot;Area: &quot; &lt;&lt; t.area() &lt;&lt; endl;

    // change the points of the Triangle_2D
    cin &gt;&gt; t;
    cout &lt;&lt; t &lt;&lt; endl;
    cout &lt;&lt; &quot;Area: &quot; &lt;&lt; t.area() &lt;&lt; endl;

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-2-vector-4"><a class="header" href="#example-2-vector-4">Example 2: Vector</a></h1>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;

class Vector_3D; // forward declaration

class Point_3D // represents a point in 3D space
{
private:
    // record the x coordinate
    double m_x;
    // record the y coordinate
    double m_y;
    // record the z coordinate
    double m_z;

public:
    Point_3D(const double &amp;arg_x = 0, const double &amp;arg_y = 0,
             const double &amp;arg_z = 0);
    Point_3D(const Point_3D &amp;arg_point);

    // Destructor
    ~Point_3D() // destructor
    {
        // do nothing, because we don't
        // have any dynamic memory
    }

    // modify the x, y and z coordinate
    void set_x(const double &amp;arg_x);
    void set_y(const double &amp;arg_y);
    void set_z(const double &amp;arg_z);
    void set(const double &amp;arg_x, const double &amp;arg_y, const double &amp;arg_z);
    // get the x, y and z coordinate
    double get_x() const;
    double get_y() const;
    double get_z() const;

    // calculate the distance between two points
    // in form of a vector
    Vector_3D operator-(const Point_3D &amp;arg_point) const;

    // friend class
    friend class Vector_3D;
    // print the x and y coordinate in format (x, y, z)
    // accessable to const object
    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;arg_os, const Point_3D &amp;arg_point);
    // read the coordinate of a point from the input,
    // format: (x, y, z) and ignore space
    friend std::istream &amp;operator&gt;&gt;(std::istream &amp;arg_is, Point_3D &amp;arg_point);
};

// Vector_3D class declaration
class Vector_3D
{
private:
    // define the three factor of the basis vectors
    // on the x, y, z axes
    double m_x, m_y, m_z;

public:
    // Constructor
    Vector_3D(const double &amp;arg_x = 0.0, const double &amp;arg_y = 0.0,
              const double &amp;arg_z = 0.0);
    Vector_3D(const Point_3D &amp;arg_point1, const Point_3D &amp;arg_point2);

    // Copy constructor
    Vector_3D(const Vector_3D &amp;arg_vector);

    // Destructor
    ~Vector_3D()
    {
        // do nothing
    }

    // set the three factor of the basis vectors
    void set_vector(const double &amp;arg_x, const double &amp;arg_y,
                    const double &amp;arg_z);
    void set_vector(const Point_3D &amp;arg_point1, const Point_3D &amp;arg_point2);
    void set_x(const double &amp;arg_x);
    void set_y(const double &amp;arg_y);
    void set_z(const double &amp;arg_z);
    // get the three factor of the basis vectors
    double get_x() const;
    double get_y() const;
    double get_z() const;

    // assign operator
    Vector_3D &amp;operator=(const Vector_3D &amp;arg_vector);

    // calculate the length of the Vector_3D
    double length();
    // calculate the dot product of two vectors
    int dot(const Vector_3D &amp;);
    // calculate the cross product of two vectors
    Vector_3D cross(const Vector_3D &amp;);

    // print the Vector_3D in format (x, y, z)
    // accessable to const object
    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;arg_os,
                                    const Vector_3D &amp;arg_point);
    // read the factors of a vector from the input,
    // format: (x, y, z) and ignore space
    friend std::istream &amp;operator&gt;&gt;(std::istream &amp;arg_is,
                                    Vector_3D &amp;arg_point);
};

// Point_3D class implementation

// Constructor &amp; Default constructor
// initialize data members, with default values
Point_3D::Point_3D(const double &amp;arg_x, const double &amp;arg_y,
                   const double &amp;arg_z)
    : m_x(arg_x),
      m_y(arg_y),
      m_z(arg_z)
{
}

// Copy constructor
// copy the data members from the given object
Point_3D::Point_3D(const Point_3D &amp;arg_point)
    : m_x(arg_point.m_x),
      m_y(arg_point.m_y),
      m_z(arg_point.m_z)
{
}

// modify the x and y coordinate
// we use `arg_` to indicate the arguments
// and re-write with setter
void Point_3D::set_x(const double &amp;arg_x)
{
    m_x = arg_x;
}
void Point_3D::set_y(const double &amp;arg_y)
{
    m_y = arg_y;
}
void Point_3D::set(const double &amp;arg_x, const double &amp;arg_y,
                   const double &amp;arg_z)
{
    m_x = arg_x;
    m_y = arg_y;
    m_z = arg_z;
}

// get the x coordinate and y coordinate
// accessable to const object
double Point_3D::get_x() const
{
    return m_x;
}
double Point_3D::get_y() const
{
    return m_y;
}
double Point_3D::get_z() const
{
    return m_z;
}

// calculate the distance between two points
// in form of a vector
Vector_3D Point_3D::operator-(const Point_3D &amp;arg_point) const
{
    return Vector_3D(*this, arg_point);
}

// print the point in the format (x, y, z)
std::ostream &amp;operator&lt;&lt;(std::ostream &amp;arg_os, const Point_3D &amp;arg_point)
{
    arg_os &lt;&lt; &quot;(&quot; &lt;&lt; arg_point.m_x &lt;&lt; &quot;, &quot; &lt;&lt; arg_point.m_y
           &lt;&lt; &quot;, &quot; &lt;&lt; arg_point.m_z &lt;&lt; &quot;)&quot;;
    return arg_os;
}

// read the coordinate of a point from the input,
// format: (x, y, z) and ignore space
std::istream &amp;operator&gt;&gt;(std::istream &amp;arg_is, Point_3D &amp;arg_point)
{
    string str_x, str_y, str_z, temp;

    if (getline(arg_is, temp, '(')) // ignore the first '('
    {
        if (getline(arg_is, str_x, ','))
        {
            if (getline(arg_is, str_y, ','))
            {
                if (getline(arg_is, str_z, ')'))
                {
                    arg_point.m_x = stod(str_x);
                    arg_point.m_y = stod(str_y);
                    arg_point.m_z = stod(str_z);
                }
            }
        }
    }
    return arg_is;
}

// Vector_3D class implementation

// Constructor
Vector_3D::Vector_3D(const double &amp;arg_x, const double &amp;arg_y,
                     const double &amp;arg_z)
    : m_x(arg_x), m_y(arg_y), m_z(arg_z)
{
}

Vector_3D::Vector_3D(const Point_3D &amp;arg_point1, const Point_3D &amp;arg_point2)
    : m_x(arg_point2.m_x - arg_point1.m_x),
      m_y(arg_point2.m_y - arg_point1.m_y),
      m_z(arg_point2.m_z - arg_point1.m_z)
{
}

// Copy constructor
Vector_3D::Vector_3D(const Vector_3D &amp;arg_vector)
    : m_x(arg_vector.m_x), m_y(arg_vector.m_y), m_z(arg_vector.m_z)
{
}

// set the three factor of the basis vectors
void Vector_3D::set_vector(const double &amp;arg_x, const double &amp;arg_y,
                           const double &amp;arg_z)
{
    m_x = arg_x;
    m_y = arg_y;
    m_z = arg_z;
}
void Vector_3D::set_vector(const Point_3D &amp;arg_point1,
                           const Point_3D &amp;arg_point2)
{
    m_x = arg_point2.m_x - arg_point1.m_x;
    m_y = arg_point2.m_y - arg_point1.m_y;
    m_z = arg_point2.m_z - arg_point1.m_z;
}
void Vector_3D::set_x(const double &amp;arg_x)
{
    m_x = arg_x;
}
void Vector_3D::set_y(const double &amp;arg_y)
{
    m_y = arg_y;
}
void Vector_3D::set_z(const double &amp;arg_z)
{
    m_z = arg_z;
}
// get the three factor of the basis vectors
double Vector_3D::get_x() const
{
    return m_x;
}
double Vector_3D::get_y() const
{
    return m_y;
}
double Vector_3D::get_z() const
{
    return m_z;
}

// assign operator
Vector_3D &amp;Vector_3D::operator=(const Vector_3D &amp;arg_vector)
{
    m_x = arg_vector.m_x;
    m_y = arg_vector.m_y;
    m_z = arg_vector.m_z;
    return *this;
}

// calculate the length of the Vector_3D
double Vector_3D::length()
{
    // calculate the length of the Vector_3D
    return sqrt(m_x * m_x + m_y * m_y + m_z * m_z);
}

// calculate the dot product of two vectors
int Vector_3D::dot(const Vector_3D &amp;arg_v)
{
    // calculate the dot product of two vectors
    return m_x * arg_v.m_x + m_y * arg_v.m_y + m_z * arg_v.m_z;
}

// calculate the cross product of two vectors
Vector_3D Vector_3D::cross(const Vector_3D &amp;arg_v)
{
    // calculate the cross product of two vectors
    Vector_3D v;
    v.m_x = m_y * arg_v.m_z - m_z * arg_v.m_y;
    v.m_y = m_z * arg_v.m_x - m_x * arg_v.m_z;
    v.m_z = m_x * arg_v.m_y - m_y * arg_v.m_x;
    return v;
}

// print the point in the format (x, y, z)
std::ostream &amp;operator&lt;&lt;(std::ostream &amp;arg_os, const Vector_3D &amp;arg_vector)
{
    arg_os &lt;&lt; &quot;(&quot; &lt;&lt; arg_vector.m_x &lt;&lt; &quot;, &quot; &lt;&lt; arg_vector.m_y
           &lt;&lt; &quot;, &quot; &lt;&lt; arg_vector.m_z &lt;&lt; &quot;)&quot;;
    return arg_os;
}

// read the factors of a vector from the input,
// format: (x, y, z) and ignore space
std::istream &amp;operator&gt;&gt;(std::istream &amp;arg_is, Vector_3D &amp;arg_vector)
{
    string str_x, str_y, str_z, temp;

    if (getline(arg_is, temp, '(')) // ignore the first '('
    {
        if (getline(arg_is, str_x, ','))
        {
            if (getline(arg_is, str_y, ','))
            {
                if (getline(arg_is, str_z, ')'))
                {
                    arg_vector.m_x = stod(str_x);
                    arg_vector.m_y = stod(str_y);
                    arg_vector.m_z = stod(str_z);
                }
            }
        }
    }
    return arg_is;
}

// main function

int main()
{
    Vector_3D v1;
    cout &lt;&lt; v1 &lt;&lt; endl;
    cout &lt;&lt; &quot;Length of v1: &quot; &lt;&lt; v1.length() &lt;&lt; endl;
    cin &gt;&gt; v1;
    cout &lt;&lt; v1 &lt;&lt; endl;
    cout &lt;&lt; &quot;Length of v1: &quot; &lt;&lt; v1.length() &lt;&lt; endl;
    cout &lt;&lt; endl;

    Vector_3D v2(v1);
    cout &lt;&lt; v2 &lt;&lt; endl;
    cout &lt;&lt; &quot;Length of v2: &quot; &lt;&lt; v2.length() &lt;&lt; endl;

    Point_3D p1, p2;
    cin &gt;&gt; p1 &gt;&gt; p2;
    v2 = p1 - p2;
    cout &lt;&lt; v2 &lt;&lt; endl;
    cout &lt;&lt; &quot;Length of v2: &quot; &lt;&lt; v2.length() &lt;&lt; endl;
    cout &lt;&lt; endl;

    cout &lt;&lt; &quot;v1: &quot; &lt;&lt; v1 &lt;&lt; endl;
    cout &lt;&lt; &quot;v2: &quot; &lt;&lt; v2 &lt;&lt; endl;
    cout &lt;&lt; &quot;Dot: &quot; &lt;&lt; v1.dot(v2) &lt;&lt; endl;
    cout &lt;&lt; endl;

    cin &gt;&gt; v2;
    Vector_3D v3 = v1.cross(v2);
    cout &lt;&lt; &quot;v1: &quot; &lt;&lt; v1 &lt;&lt; endl;
    cout &lt;&lt; &quot;v2: &quot; &lt;&lt; v2 &lt;&lt; endl;
    cout &lt;&lt; &quot;Cross: &quot; &lt;&lt; v3 &lt;&lt; endl;
    cout &lt;&lt; endl;

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-3-fixed-point-number--fixed-point-number-calculator-1"><a class="header" href="#example-3-fixed-point-number--fixed-point-number-calculator-1">Example 3: Fixed Point Number &amp; Fixed Point Number Calculator</a></h1>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cmath&gt;

using namespace std;

class Fp_Calc; // forward declaration

// Fixed point class declaration
class Fixed_Point
{
private:
    long long int m_int_part;
    long long int m_frac_part;
    unsigned int m_precision;

    // utility functions
    // set fixed point without checking
    void _set(const string &amp;arg_str);
    // normalize to m_precision
    void _normalize(const unsigned int arg_precision = 0);

public:
    Fixed_Point(const long long int &amp;arg_int_part = 0,
                const unsigned long long int &amp;arg_frac_part = 0,
                const unsigned int &amp;arg_precision = 9);
    // Fixed_Point(const string &amp;arg_str);

    ~Fixed_Point();

    // getter &amp; setter
    void set_int_part(const long long int arg_int_part);
    void set_frac_part(const unsigned long long int arg_frac_part);
    void set_precision(const unsigned int arg_precision);
    void set(const long long int &amp;arg_int_part,
             const unsigned long long int &amp;arg_frac_part,
             const unsigned int &amp;arg_precision);
    long long int get_int_part() const;
    unsigned long long int get_frac_part() const;
    unsigned int get_precision() const;
    string get_string_value() const;

    // arithmetic operators
    Fixed_Point operator+(const Fixed_Point &amp;arg_fp) const;
    Fixed_Point operator-(const Fixed_Point &amp;arg_fp) const;
    Fixed_Point operator+=(const Fixed_Point &amp;arg_fp);
    Fixed_Point operator-=(const Fixed_Point &amp;arg_fp);
    // conversion operators
    operator double() const;
    operator float() const;
    // assignment operators
    Fixed_Point &amp;operator=(const Fixed_Point &amp;arg_fp);
    Fixed_Point &amp;operator=(const double &amp;arg_double);
    Fixed_Point &amp;operator=(const float &amp;arg_float);

    // friend class
    friend class Fp_Calc;
    // friend function
    // formatted output
    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Fixed_Point &amp;arg_fp);
    // formatted input
    friend istream &amp;operator&gt;&gt;(istream &amp;is, Fixed_Point &amp;arg_fp);
};

// Fixed point calculator class declaration
class Fp_Calc
{
private:
    // define current value
    Fixed_Point m_curr_val;
    // define input value
    Fixed_Point m_input_val;
    // define operation
    // `+`, `-`, `*`, `/`, and ` ` for none
    char m_op;
    // calculate result
    void _calc_result();

public:
    // Constructor
    Fp_Calc();
    // Copy constructor
    Fp_Calc(const Fp_Calc &amp;arg_int_calc);

    // Destructor
    ~Fp_Calc(){}; // no need to do anything

    // clear the input value
    void clear();
    // // set the input value
    // void set_input(const string &amp;arg_input);
    // add the input value to the current value
    void add();
    // subtract the input value from the current value
    void sub();
    // multiply the input value with the current value
    void mul();
    // divide the current value by the input value
    void div();
    // assign the input value to the current value
    void assign();
    // get the current value
    Fixed_Point get_curr_val();
    // get the current operation
    char get_op();
    // get the input value
    Fixed_Point get_input_val();

    // formatted output
    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Fp_Calc &amp;arg_fp_calc);
    // formatted input
    friend istream &amp;operator&gt;&gt;(istream &amp;is, Fp_Calc &amp;arg_fp_calc);
};

// Fixed point class implementation

// utility functions

// set fixed point without checking
void Fixed_Point::_set(const string &amp;arg_str)
{
    // set integer part
    m_int_part = stoll(arg_str.substr(0, arg_str.find('.')));
    // set fractional part
    m_frac_part = stoull(arg_str.substr(arg_str.find('.') + 1));
    // set precision
    m_precision = arg_str.length() - arg_str.find('.') - 1;
}

// normalize to precision
void Fixed_Point::_normalize(const unsigned int arg_precision)
{
    unsigned int temp_precision = arg_precision;
    // if precision is not specified, use the current precision
    if (arg_precision == 0)
    {
        temp_precision = m_precision;
    }
    // if precision is over the maximum, use the maximum
    else if (arg_precision &gt; 9)
    {
        temp_precision = 9;
    }
    else
    {
        temp_precision = arg_precision;
    }

    // update fractional part
    int precision_diff = temp_precision - m_precision;
    if (precision_diff &gt; 0)
    {
        m_frac_part *= pow(10, precision_diff);
    }
    else if (precision_diff &lt; 0)
    {
        m_frac_part /= pow(10, -precision_diff);
    }

    // update m_precision
    m_precision = temp_precision;

    // handle fractional part overflow

    // update integer part
    if (m_frac_part &gt;= pow(10, m_precision))
    {
        m_int_part += m_frac_part / pow(10, m_precision);
        m_frac_part %= (int)pow(10, m_precision);
    }

    // handle fractional part underflow

    // update integer part
    if (m_frac_part &lt; 0)
    {
        m_int_part -= 1;
        m_frac_part += pow(10, m_precision);
    }
}

// Constructor
Fixed_Point::Fixed_Point(const long long int &amp;arg_int_part,
                         const unsigned long long int &amp;arg_frac_part,
                         const unsigned int &amp;arg_precision)
    : m_int_part(arg_int_part),
      m_frac_part(arg_frac_part),
      m_precision(arg_precision)
{
}

Fixed_Point::~Fixed_Point()
{
    // do nothing
}

// getter &amp; setter
void Fixed_Point::set_int_part(const long long int arg_int_part)
{
    m_int_part = arg_int_part;
}
void Fixed_Point::set_frac_part(const unsigned long long int arg_frac_part)
{
    m_frac_part = arg_frac_part;
    _normalize();
}
void Fixed_Point::set_precision(const unsigned int arg_precision)
{
    _normalize(arg_precision);
}
void Fixed_Point::set(const long long int &amp;arg_int_part,
                      const unsigned long long int &amp;arg_frac_part,
                      const unsigned int &amp;arg_precision)
{
    m_int_part = arg_int_part;
    m_frac_part = arg_frac_part;
    m_precision = arg_precision;
    _normalize();
}

long long int Fixed_Point::get_int_part() const
{
    return m_int_part;
}
unsigned long long int Fixed_Point::get_frac_part() const
{
    return m_frac_part;
}
unsigned int Fixed_Point::get_precision() const
{
    return m_precision;
}
string Fixed_Point::get_string_value() const
{
    string str_int_part = to_string(m_int_part);
    string str_frac_part = to_string(m_frac_part);
    // if precision is not specified, use the current precision
    if (m_precision == 0)
    {
        return str_int_part;
    }
    // if precision is 1, return integer part and fractional part
    else if (m_precision == 1)
    {
        return str_int_part + &quot;.&quot; + str_frac_part;
    }
    // if precision is over 1, return integer part and fractional part with
    // specified precision
    else
    {
        // if fractional part is 0, return integer part
        if (str_frac_part == &quot;0&quot;)
        {
            return str_int_part;
        }
        // if fractional part is not 0, return integer part and fractional part
        else
        {
            // if fractional part is less than precision, add 0 to the front
            if (str_frac_part.length() &lt; m_precision)
            {
                str_frac_part = string(m_precision - str_frac_part.length(), '0') 
                                + str_frac_part;
            }
            // if fractional part is more than precision, remove the end
            else if (str_frac_part.length() &gt; m_precision)
            {
                str_frac_part = str_frac_part.substr(0, m_precision);
            }
            return str_int_part + &quot;.&quot; + str_frac_part;
        }
    }
}

Fixed_Point Fixed_Point::operator+(const Fixed_Point &amp;arg_fixed_point) const
{
    Fixed_Point result(*this);
    result += arg_fixed_point;
    return result;
}

Fixed_Point Fixed_Point::operator-(const Fixed_Point &amp;arg_fixed_point) const
{
    Fixed_Point result(*this);
    result -= arg_fixed_point;
    return result;
}

Fixed_Point Fixed_Point::operator+=(const Fixed_Point &amp;arg_fixed_point)
{
    Fixed_Point normalized_arg(arg_fixed_point);
    unsigned int max_precision = max(m_precision,
                                     normalized_arg.m_precision);
    set_precision(max_precision);
    normalized_arg.set_precision(max_precision);
    m_precision = max_precision;
    m_int_part = m_int_part + normalized_arg.m_int_part;
    m_frac_part = m_frac_part + normalized_arg.m_frac_part;
    _normalize();
    return *this;
}

Fixed_Point Fixed_Point::operator-=(const Fixed_Point &amp;arg_fixed_point)
{
    Fixed_Point normalized_arg(arg_fixed_point);
    unsigned int max_precision = max(m_precision,
                                     normalized_arg.m_precision);
    set_precision(max_precision);
    normalized_arg.set_precision(max_precision);
    m_int_part = m_int_part - normalized_arg.m_int_part;
    m_frac_part = m_frac_part - normalized_arg.m_frac_part;
    _normalize();
    return *this;
}

Fixed_Point::operator double() const
{
    return double(m_int_part) + double(m_frac_part) / pow(10, m_precision);
}

Fixed_Point::operator float() const
{
    return float(m_int_part) + float(m_frac_part) / pow(10, m_precision);
}

Fixed_Point &amp;Fixed_Point::operator=(const Fixed_Point &amp;arg_fp)
{
    m_int_part = arg_fp.m_int_part;
    m_frac_part = arg_fp.m_frac_part;
    m_precision = arg_fp.m_precision;
    return *this;
}
Fixed_Point &amp;Fixed_Point::operator=(const double &amp;arg_double)
{
    _set(to_string(arg_double));
    _normalize();
    return *this;
}
Fixed_Point &amp;Fixed_Point::operator=(const float &amp;arg_float)
{
    _set(to_string(arg_float));
    _normalize();
    return *this;
}

// formated output
ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Fixed_Point &amp;arg_fixed_point)
{
    arg_os &lt;&lt; arg_fixed_point.get_string_value(); // reuse get_string_value()
    return arg_os;
}

// formated input
istream &amp;operator&gt;&gt;(istream &amp;arg_is, Fixed_Point &amp;arg_fixed_point)
{
    string str_value;
    arg_is &gt;&gt; str_value;
    arg_fixed_point._set(str_value); // reuse _set()
    arg_fixed_point._normalize();
    return arg_is;
}

// Fp_Calc class implementation

// Constructor
Fp_Calc::Fp_Calc()
    : m_curr_val(), m_input_val(), m_op(' ')
{
}

// Copy constructor
Fp_Calc::Fp_Calc(const Fp_Calc &amp;arg_int_calc)
    : m_curr_val(arg_int_calc.m_curr_val),
      m_input_val(arg_int_calc.m_input_val),
      m_op(arg_int_calc.m_op)
{
}

// calculate the result
void Fp_Calc::_calc_result()
{
    switch (m_op)
    {
    case '+':
        m_curr_val += m_input_val;
        break;
    case '-':
        m_curr_val -= m_input_val;
        break;
    case ' ':
        m_curr_val = m_input_val;
        break;
    default:
        break;
    }
}

// clear the input value
void Fp_Calc::clear()
{
    m_input_val = Fixed_Point();
}

// // set the input value
// void Fp_Calc::set_input(const string &amp;arg_input_val)
// {
//     m_input_val = Fixed_Point(arg_input_val);
// }

// add the input value to the current value
void Fp_Calc::add()
{
    _calc_result();
    m_op = '+';
}

// subtract the input value from the current value
void Fp_Calc::sub()
{
    _calc_result();
    m_op = '-';
}

// multiply the input value with the current value
void Fp_Calc::mul()
{
    _calc_result();
    m_op = '*';
}

// divide the current value by the input value
void Fp_Calc::div()
{
    _calc_result();
    m_op = '/';
}

// assign the input value to the current value
void Fp_Calc::assign()
{
    _calc_result();
    m_op = ' ';
}

// get the current value
Fixed_Point Fp_Calc::get_curr_val()
{
    return m_curr_val;
}

// get the current operation
char Fp_Calc::get_op()
{
    return m_op;
}

// get the input value
Fixed_Point Fp_Calc::get_input_val()
{
    return m_input_val;
}

// formated output
ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, Fp_Calc &amp;arg_fp_calc)
{
    arg_os &lt;&lt; arg_fp_calc.get_curr_val();
    return arg_os;
}

// formated input
istream &amp;operator&gt;&gt;(istream &amp;arg_is, Fp_Calc &amp;arg_fp_calc)
{
    arg_is &gt;&gt; arg_fp_calc.m_input_val;
    return arg_is;
}

// main function

int main()
{
    // create an instance of the class
    Fp_Calc calc;
    // set the input value
    cin &gt;&gt; calc;
    // get the input value
    cout &lt;&lt; &quot;Input: &quot; &lt;&lt; calc.get_input_val() &lt;&lt; endl;
    // add the input value to the current value
    calc.add();
    // get current op
    cout &lt;&lt; '\'' &lt;&lt; calc.get_op() &lt;&lt; '\'' &lt;&lt; endl;
    // set another input value
    cin &gt;&gt; calc;
    // get the input value
    cout &lt;&lt; &quot;Input: &quot; &lt;&lt; calc.get_input_val() &lt;&lt; endl;
    // clear the input value
    calc.clear();
    cout &lt;&lt; &quot;clear&quot; &lt;&lt; endl;
    // set the input value
    cin &gt;&gt; calc;
    // get the input value
    cout &lt;&lt; &quot;Input: &quot; &lt;&lt; calc.get_input_val() &lt;&lt; endl;
    // subtract the input value from the current value
    calc.sub();
    // get current op
    cout &lt;&lt; '\'' &lt;&lt; calc.get_op() &lt;&lt; '\'' &lt;&lt; endl;
    // print the result
    cout &lt;&lt; &quot;Result: &quot; &lt;&lt; calc &lt;&lt; endl;
    // set another input value
    cin &gt;&gt; calc;
    // get the input value
    cout &lt;&lt; &quot;Input: &quot; &lt;&lt; calc.get_input_val() &lt;&lt; endl;
    // compute the result
    calc.assign();
    // print the result
    cout &lt;&lt; &quot;Result: &quot; &lt;&lt; calc &lt;&lt; endl;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-6-complex-number-calculator"><a class="header" href="#lab-6-complex-number-calculator">Lab 6: Complex Number Calculator</a></h1>
<h2 id="lab-6-1-enhanced-complex-numbers-40"><a class="header" href="#lab-6-1-enhanced-complex-numbers-40">Lab 6-1: Enhanced Complex Numbers (40%)</a></h2>
<ul>
<li>輸入：
<ol>
<li>以 <code>double</code> 格式輸入複數的實數及虛數部分，以空格分開，一行輸入一個複數</li>
<li>以 <code>char</code> 格式輸入複數的運算子，包含 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>，一行輸入一個運算子</li>
<li>複數與運算子以交錯的方式輸入，一行輸入一個複數接著一個運算子，倒數兩行為複數與完成輸入指令</li>
<li>輸入 <kbd>Ctrl</kbd>+<kbd>D</kbd> 完成輸入
<ul>
<li>Windows 請輸入 <kbd>Ctrl</kbd>+<kbd>Z</kbd> (會在螢幕上顯示 <code>^Z</code>) 再輸入 <kbd>Enter</kbd> (Format 中的 <code>⏎</code>) 完成輸入</li>
</ul>
</li>
</ol>
</li>
<li>輸出：
<ol>
<li>顯示運算複數的結果
<ol>
<li>格式請參考 <a href="class/lab/lab6-1.html#format">Format</a> 中的說明</li>
</ol>
</li>
<li>若虛數部分為 0 則僅顯示實數部分</li>
<li>虛數及實數部分皆以預設 <code>double</code> 格式顯示</li>
</ol>
</li>
<li>檔名：<code>lab6-1_&lt;學號&gt;.cpp</code> (e.g. <code>lab6-1_106062802.cpp</code>)</li>
</ul>
<p>注意事項：</p>
<ul>
<li>程式不會輸出任何使用者提示，只會輸出程式結果</li>
<li>使用者不需要處理錯誤輸入</li>
<li>請使用 pseudo code 提供的 main function 來處理輸入與輸出</li>
<li>程式需要於 10 秒內完成，所有的測資皆會保證於 10 秒內完成</li>
</ul>
<h3 id="format-4"><a class="header" href="#format-4">Format</a></h3>
<pre><code class="language-text">&lt;real 1&gt; &lt;imag 1&gt;⏎
&lt;op 1&gt;⏎
&lt;real 2&gt; &lt;imag 2&gt;⏎
&lt;op 2&gt;⏎
...
&lt;real n-1&gt; &lt;imag n-1&gt;⏎
&lt;op n-1&gt;⏎
&lt;real n&gt; &lt;imag n&gt;⏎
^Z⏎
(-)&lt;real result&gt; (+|-) (&lt;imag result&gt;i)
</code></pre>
<h3 id="example-5"><a class="header" href="#example-5">Example</a></h3>
<pre><code class="language-console">$ ./a.out
1.0 0.0⏎
^Z⏎
1
$ ./a.out
0.0 1.0⏎
^Z⏎
0 + 1i⏎
$ ./a.out
1.0 0.0⏎
+⏎
2.0 1.1⏎
-⏎
-3.0 -2.2⏎
*⏎
4.3 2.1⏎
/⏎
-1.2 -3.4⏎
^Z⏎
-8.74846 + 2.46231i
$ ./a.out
1.0 0.0⏎
+⏎
2.0 1.1⏎
-⏎
-3.0 -2.2⏎
*⏎
4.3 2.1⏎
/⏎
-1.2 3.4⏎
^Z⏎
5.26477 - 7.40815i
</code></pre>
<h3 id="pseudo-code-4"><a class="header" href="#pseudo-code-4">Pseudo Code</a></h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

using namespace std;

class Complex
{
private:
    // data members
    // save the real and imaginary parts of the complex number
    // with `double` precision
    double m_real;
    double m_imag;

public:
    // Constructor, initializes real and imaginary parts
    Complex(const double &amp;arg_real = 0.0, const double &amp;arg_imag = 0.0);
    // Copy constructor
    Complex(const Complex &amp;arg_c);
    // assignment operator
    Complex &amp;operator=(const Complex &amp;arg_c);
    // add assignment operator
    Complex &amp;operator+=(const Complex &amp;arg_c);
    // subtract assignment operator
    Complex &amp;operator-=(const Complex &amp;arg_c);
    // multiply assignment operator
    Complex &amp;operator*=(const Complex &amp;arg_c);
    // divide assignment operator
    Complex &amp;operator/=(const Complex &amp;arg_c);
    // add function
    Complex operator+(const Complex &amp;arg_c) const;
    // subtract function
    Complex operator-(const Complex &amp;arg_c) const;
    // multiply function
    Complex operator*(const Complex &amp;arg_c) const;
    // divide function
    Complex operator/(const Complex &amp;arg_c) const;
    // cout `&lt;&lt;` operator for print complex number
    // note: be careful about the format of output
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex &amp;arg_c);
    // cin `&gt;&gt;` operator for input complex number
    // note: be careful about the format of input
    // hint: use `stod` to convert string to double
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Complex &amp;arg_c);
};

// used for process the test cases, do not modify
int main()
{
    string input;
    Complex result_complex;
    char op = ' ';

    while (getline(cin, input))
    {
        // input is a operation
        if (input == &quot;+&quot; || input == &quot;-&quot; || input == &quot;*&quot; || input == &quot;/&quot;)
        {
            op = input[0];
            continue;
        }
        else if (input.empty())
        {
            continue;
        }
        // input is a complex number
        else
        {
            stringstream ss(input);
            Complex current_complex;
            ss &gt;&gt; current_complex;
            switch (op)
            {
            case '+':
                result_complex += current_complex;
                break;
            case '-':
                result_complex -= current_complex;
                break;
            case '*':
                result_complex *= current_complex;
                break;
            case '/':
                result_complex /= current_complex;
                break;
            case ' ':
                result_complex = current_complex;
                break;
            default:
                cerr &lt;&lt; &quot;Error: unknown operation&quot; &lt;&lt; endl;
                return 1;
            }
        }
    }
    cout &lt;&lt; endl;
    cout &lt;&lt; result_complex &lt;&lt; endl;
    return 0;
}
</code></pre>
<h3 id="reference-code-3"><a class="header" href="#reference-code-3">Reference Code:</a></h3>
<h4 id="陳誼倫110021127"><a class="header" href="#陳誼倫110021127">陳誼倫(110021127)</a></h4>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

using namespace std;

class Complex
{
private:
    // data members
    // save the real and imaginary parts of the complex number
    // with `double` precision
    double m_real;
    double m_imag;

public:
    // Constructor, initializes real and imaginary parts
    Complex(const double &amp;arg_real = 0, const double &amp;arg_imag = 0);
    // Copy constructor
    Complex(const Complex &amp;arg_c);
    // assignment operator
    ~Complex() {}
    Complex &amp;operator=(const Complex &amp;arg_c);
    // add assignment operator
    Complex &amp;operator+=(const Complex &amp;arg_c);
    // subtract assignment operator
    Complex &amp;operator-=(const Complex &amp;arg_c);
    // multiply assignment operator
    Complex &amp;operator*=(const Complex &amp;arg_c);
    // divide assignment operator
    Complex &amp;operator/=(const Complex &amp;arg_c);

    // cout `&lt;&lt;` operator for print complex number
    // note: be careful about the format of output
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex &amp;arg_c);
    // cin `&gt;&gt;` operator for input complex number
    // note: be careful about the format of input
    // hint: use `stod` to convert string to double
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Complex &amp;arg_c);
};
Complex::Complex(const double &amp;arg_real, const double &amp;arg_imag)
    : m_real(arg_real), m_imag(arg_imag) {}

Complex::Complex(const Complex &amp;arg_point)
    : m_real(arg_point.m_real), m_imag(arg_point.m_imag) {}

Complex &amp;Complex::operator=(const Complex &amp;arg_c)
{
    this-&gt;m_real = arg_c.m_real;
    this-&gt;m_imag = arg_c.m_imag;
    return *this;
}
Complex &amp;Complex::operator+=(const Complex &amp;arg_c)
{
    this-&gt;m_real += arg_c.m_real;
    this-&gt;m_imag += arg_c.m_imag;
    return *this;
}
Complex &amp;Complex::operator-=(const Complex &amp;arg_c)
{
    this-&gt;m_real -= arg_c.m_real;
    this-&gt;m_imag -= arg_c.m_imag;
    return *this;
}
Complex &amp;Complex::operator*=(const Complex &amp;arg_c)
{
    double _real = this-&gt;m_real, _imag = this-&gt;m_imag;
    this-&gt;m_real = (_real * arg_c.m_real) - (_imag * arg_c.m_imag);
    this-&gt;m_imag = (_real * arg_c.m_imag) + (_imag * arg_c.m_real);
    return *this;
}
Complex &amp;Complex::operator/=(const Complex &amp;arg_c)
{
    double _real = this-&gt;m_real, _imag = this-&gt;m_imag;
    this-&gt;m_real = ((_real * arg_c.m_real) + (_imag * arg_c.m_imag)) 
        / ((arg_c.m_real * arg_c.m_real + arg_c.m_imag * arg_c.m_imag));
    this-&gt;m_imag = ((-_real * arg_c.m_imag) + (_imag * arg_c.m_real)) 
        / ((arg_c.m_real * arg_c.m_real + arg_c.m_imag * arg_c.m_imag));
    return *this;
}
std::ostream &amp;operator&lt;&lt;(std::ostream &amp;arg_os, const Complex &amp;arg_point)
{
    if (arg_point.m_imag == 0)
    {
        arg_os &lt;&lt; arg_point.m_real;
        return arg_os;
    }
    else if (arg_point.m_imag &lt; 0)
    {
        arg_os &lt;&lt; arg_point.m_real &lt;&lt; &quot; - &quot; &lt;&lt; -arg_point.m_imag &lt;&lt; &quot;i &quot;;
        return arg_os;
    }
    else
    {
        arg_os &lt;&lt; arg_point.m_real &lt;&lt; &quot; + &quot; &lt;&lt; arg_point.m_imag &lt;&lt; &quot;i &quot;;
        return arg_os;
    }
}

// read the coordinate of a point from the input, format: (x, y) and ignore space
std::istream &amp;operator&gt;&gt;(std::istream &amp;arg_is, Complex &amp;arg_point)
{
    string str_x, str_y, temp;

    if (getline(arg_is, str_x, ' '))
    {
        if (getline(arg_is, str_y, ' '))
        {
            arg_point.m_real = stod(str_x);
            arg_point.m_imag = stod(str_y);
        }
    }

    return arg_is;
}

// used for process the test cases, do not modify
int main()
{
    string input;
    Complex result_complex;
    char op = ' ';

    while (getline(cin, input))
    {
        // input is a operation
        if (input == &quot;+&quot; || input == &quot;-&quot; || input == &quot;*&quot; || input == &quot;/&quot;)
        {
            op = input[0];
            continue;
        }
        else if (input.empty())
        {
            continue;
        }
        // input is a complex number
        else
        {
            stringstream ss(input);
            Complex current_complex;
            ss &gt;&gt; current_complex;
            switch (op)
            {
            case '+':
                result_complex += current_complex;
                break;
            case '-':
                result_complex -= current_complex;
                break;
            case '*':
                result_complex *= current_complex;
                break;
            case '/':
                result_complex /= current_complex;
                break;
            case ' ':
                result_complex = current_complex;
                break;
            default:
                cerr &lt;&lt; &quot;Error: unknown operation&quot; &lt;&lt; endl;
                return 1;
            }
        }
    }
    cout &lt;&lt; endl;
    cout &lt;&lt; result_complex &lt;&lt; endl;
    return 0;
}
</code></pre>
<h4 id="林恩佑109021107"><a class="header" href="#林恩佑109021107">林恩佑(109021107)</a></h4>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

using namespace std;

class Complex
{
private:
    // data members
    // save the real and imaginary parts of the complex number
    // with double precision
    double m_real;
    double m_imag;

public:
    // Constructor, initializes real and imaginary parts
    Complex(const double &amp;arg_real = 0.0, const double &amp;arg_imag = 0.0);
    // Copy constructor
    Complex(const Complex &amp;arg_c);
    // assignment operator
    Complex &amp;operator=(const Complex &amp;arg_c);
    // add assignment operator
    Complex &amp;operator+=(const Complex &amp;arg_c);
    // subtract assignment operator
    Complex &amp;operator-=(const Complex &amp;arg_c);
    // multiply assignment operator
    Complex &amp;operator*=(const Complex &amp;arg_c);
    // divide assignment operator
    Complex &amp;operator/=(const Complex &amp;arg_c);
    // add function
    Complex operator+(const Complex &amp;arg_c) const;
    // subtract function
    Complex operator-(const Complex &amp;arg_c) const;
    // multiply function
    Complex operator*(const Complex &amp;arg_c) const;
    // divide function
    Complex operator/(const Complex &amp;arg_c) const;
    // cout `&lt;&lt;` operator for print complex number
    // note: be careful about the format of output
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex &amp;arg_c);
    // cin `&gt;&gt;` operator for input complex number
    // note: be careful about the format of input
    // hint: use stod to convert string to double
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Complex &amp;arg_c);
};

Complex::Complex(const double &amp;arg_real, const double &amp;arg_image)
    : m_real(arg_real), m_imag(arg_image)
{
}

Complex::Complex(const Complex &amp;arg_c)
    : m_real(arg_c.m_real), m_imag(arg_c.m_imag)
{
}

Complex &amp;Complex::operator=(const Complex &amp;arg_c)
{
    m_real = arg_c.m_real;
    m_imag = arg_c.m_imag;
    return *this;
}

Complex &amp;Complex::operator+=(const Complex &amp;arg_c)
{
    m_real += arg_c.m_real;
    m_imag += arg_c.m_imag;
    return *this;
}

Complex &amp;Complex::operator-=(const Complex &amp;arg_c)
{
    m_real -= arg_c.m_real;
    m_imag -= arg_c.m_imag;
    return *this;
}

Complex &amp;Complex::operator*=(const Complex &amp;arg_c)
{
    Complex a;
    a.m_real = m_real;
    a.m_imag = m_imag;
    m_real = a.m_real * arg_c.m_real - a.m_imag * arg_c.m_imag;
    m_imag = a.m_real * arg_c.m_imag + arg_c.m_real * a.m_imag;
    return *this;
}

Complex &amp;Complex::operator/=(const Complex &amp;arg_c)
{
    Complex a;
    a.m_real = m_real;
    a.m_imag = m_imag;
    m_real = (a.m_real * arg_c.m_real + a.m_imag * arg_c.m_imag) 
        / (arg_c.m_real * arg_c.m_real + arg_c.m_imag * arg_c.m_imag);
    m_imag = (arg_c.m_real * a.m_imag - a.m_real * arg_c.m_imag) 
        / (arg_c.m_real * arg_c.m_real + arg_c.m_imag * arg_c.m_imag);
    return *this;
}

ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex &amp;arg_c)
{
    if (arg_c.m_imag == 0)
    {
        arg_os &lt;&lt; arg_c.m_real;
    }
    else if (arg_c.m_imag &lt; 0)
    {
        arg_os &lt;&lt; arg_c.m_real &lt;&lt; &quot; - &quot; &lt;&lt; 0.0 - arg_c.m_imag &lt;&lt; &quot;i&quot;;
    }
    else
    {
        arg_os &lt;&lt; arg_c.m_real &lt;&lt; &quot; + &quot; &lt;&lt; arg_c.m_imag &lt;&lt; &quot;i&quot;;
    }
    return arg_os;
}

istream &amp;operator&gt;&gt;(istream &amp;arg_is, Complex &amp;arg_c)
{
    string strs;
    size_t sz;
    arg_c = {0, 0};
    arg_is &gt;&gt; strs;
    try
    {
        arg_c.m_real = stod(strs);
    }
    catch (const invalid_argument &amp;ia)
    {
    }
    strs = &quot;&quot;;
    arg_is &gt;&gt; strs;
    try
    {
        arg_c.m_imag = stod(strs);
    }
    catch (const invalid_argument &amp;ia)
    {
    }
    return arg_is;
}

// used for process the test cases, do not modify
int main()
{
    string input;
    Complex result_complex;
    char op = ' ';

    while (getline(cin, input))
    {
        // input is a operation
        if (input == &quot;+&quot; || input == &quot;-&quot; || input == &quot;*&quot; || input == &quot;/&quot;)
        {
            op = input[0];
            continue;
        }
        else if (input.empty())
        {
            continue;
        }
        // input is a complex number
        else
        {
            stringstream ss(input);
            Complex current_complex;
            ss &gt;&gt; current_complex;
            switch (op)
            {
            case '+':
                result_complex += current_complex;
                break;
            case '-':
                result_complex -= current_complex;
                break;
            case '*':
                result_complex *= current_complex;
                break;
            case '/':
                result_complex /= current_complex;
                break;
            case ' ':
                result_complex = current_complex;
                break;
            default:
                cerr &lt;&lt; &quot;Error: unknown operation&quot; &lt;&lt; endl;
                return 1;
            }
        }
    }
    cout &lt;&lt; endl;
    cout &lt;&lt; result_complex &lt;&lt; endl;
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="lab-6-2-simple-complex-number-calculator-40"><a class="header" href="#lab-6-2-simple-complex-number-calculator-40">Lab 6-2: Simple Complex Number Calculator (40%)</a></h2>
<ul>
<li>輸入：
<ol>
<li>以 <code>double</code> 格式輸入複數的實數及虛數部分，以空格分開，一行輸入一個複數</li>
<li>以 <code>char</code> 格式輸入複數的運算子，包含 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>，一行輸入一個運算子</li>
<li>複數與運算子以交錯的方式輸入，一行輸入一個複數接著一個運算子，倒數一行為複數</li>
<li>輸入 <kbd>Ctrl</kbd>+<kbd>D</kbd> 結束程式</li>
</ol>
<ul>
<li>Windows 請輸入 <kbd>Ctrl</kbd>+<kbd>Z</kbd> (會在螢幕上顯示 <code>^Z</code>) 再輸入 <kbd>Enter</kbd> (Format 中的 <code>⏎</code>) 結束程式</li>
</ul>
</li>
<li>輸出：
<ol>
<li>顯示運算複數的結果</li>
<li>複數的格式為 <code>(-)&lt;real result&gt; (+|-) (&lt;imag result&gt;i)</code></li>
<li>若輸入運算子、需顯示之前運算的結果，如 <a href="class/lab/lab6-2.html#example">Example</a> 的範例</li>
</ol>
</li>
<li>檔名：<code>lab6-2_&lt;學號&gt;.cpp</code> (e.g. <code>lab6-2_106062802.cpp</code>)</li>
</ul>
<p>注意事項：</p>
<ul>
<li>程式不會輸出任何使用者提示，只會輸出程式結果或錯誤訊息</li>
<li>使用者不需要處理錯誤輸入</li>
<li>請使用 pseudo code 提供的 <code>main</code> 及 <code>Complex_Calc::set_input</code> 來處理輸入與輸出</li>
<li>程式需要於 10 秒內完成，所有的測資皆會保證於 10 秒內完成</li>
</ul>
<h3 id="format-5"><a class="header" href="#format-5">Format</a></h3>
<pre><code class="language-text">&lt;real 1&gt; &lt;imag 1&gt;⏎
&lt;result 1&gt;
&lt;op 1&gt;⏎
&lt;result 1&gt;
&lt;real 2&gt; &lt;imag 2&gt;⏎
&lt;result 2&gt;
&lt;op 2&gt;⏎
&lt;result 2&gt;
...
&lt;real n-1&gt; &lt;imag n-1&gt;⏎
&lt;result n-1&gt;
&lt;op n-1&gt;⏎
&lt;result n-1&gt;
&lt;real n&gt; &lt;imag n&gt;⏎
&lt;result n&gt;
^Z⏎
</code></pre>
<h3 id="example-6"><a class="header" href="#example-6">Example</a></h3>
<pre><code class="language-console">$ ./a.out
1.0 0.0⏎
1
^Z⏎
$ ./a.out
0.0 1.0⏎
0 + 1i⏎
^Z⏎
$ ./a.out
1.0 0.0⏎
1
+⏎
1
2.0 1.1⏎
3 + 1.1i
-⏎
3 + 1.1i
-3.0 -2.2⏎
6 + 3.3i
*⏎
6 + 3.3i
4.3 2.1⏎
18.87 + 26.79i
/⏎
18.87 + 26.79i
-1.2 -3.4⏎
-8.74846 + 2.46231i
^Z⏎
$ ./a.out
1.0 0.0⏎
1
+⏎
1
2.0 1.1⏎
3 + 1.1i
-⏎
3 + 1.1i
-3.0 -2.2⏎
6 + 3.3i
*⏎
6 + 3.3i
4.3 2.1⏎
18.87 + 26.79i
/⏎
18.87 + 26.79i
-1.2 3.4⏎
5.26477 - 7.40815i
^Z⏎
$
</code></pre>
<h3 id="pseudo-code-5"><a class="header" href="#pseudo-code-5">Pseudo Code</a></h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;cmath&gt;

using namespace std;

class Complex_Calc;

class Complex
{
private:
    // data members
    // save the real and imaginary parts of the complex number
    // with `double` precision
    double m_real;
    double m_imag;

public:
    // Constructor, initializes real and imaginary parts
    Complex(const double &amp;arg_real = 0.0, const double &amp;arg_imag = 0.0);
    // Copy constructor
    Complex(const Complex &amp;arg_c);
    // assignment operator
    Complex &amp;operator=(const Complex &amp;arg_c);
    // add assignment operator
    Complex &amp;operator+=(const Complex &amp;arg_c);
    // subtract assignment operator
    Complex &amp;operator-=(const Complex &amp;arg_c);
    // multiply assignment operator
    Complex &amp;operator*=(const Complex &amp;arg_c);
    // divide assignment operator
    Complex &amp;operator/=(const Complex &amp;arg_c);
    // add function
    Complex operator+(const Complex &amp;arg_c) const;
    // subtract function
    Complex operator-(const Complex &amp;arg_c) const;
    // multiply function
    Complex operator*(const Complex &amp;arg_c) const;
    // divide function
    Complex operator/(const Complex &amp;arg_c) const;
    // cout `&lt;&lt;` operator for print complex number
    // note: be careful about the format of output
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex &amp;arg_c);
    // cin `&gt;&gt;` operator for input complex number
    // note: be careful about the format of input
    // hint: use `stod` to convert string to double
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Complex &amp;arg_c);

    friend class Complex_Calc;
};

// Complex calculator class declaration
class Complex_Calc
{
private:
    // define current value
    Complex m_curr_val;
    // define input value
    Complex m_input_val;
    // define operation
    // `+`, `-`, `*`, `/`, and `=`
    char m_op;
    // calculate result
    void _calc_result();
    // operation functions
    // add the input value to the current value
    void _add();
    // subtract the input value from the current value
    void _sub();
    // multiply the input value with the current value
    void _mul();
    // divide the current value by the input value
    void _div();
    // assign the input value to the current value
    void _assign();

public:
    // Constructor
    Complex_Calc();
    // Copy constructor
    Complex_Calc(const Complex_Calc &amp;arg_int_calc);

    // Destructor
    ~Complex_Calc(){}; // no need to do anything

    // set input value or operation
    void set_input(const string &amp;arg_input);

    // cout `&lt;&lt;` operator for print calculator status
    // note: be careful about the format of output
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex_Calc &amp;arg_comp_calc);
};

// parse the test cases, do not modify belows

void Complex_Calc::set_input(const string &amp;arg_input)
{
    // input is empty, read again
    if (arg_input.empty())
    {
        return;
    }
    // input is a operation
    else if (arg_input == &quot;+&quot; || arg_input == &quot;-&quot; || arg_input == &quot;*&quot; 
        || arg_input == &quot;/&quot; || arg_input == &quot;=&quot;)
    {
        // set the activated operation
        // as the same as the user press the op button
        switch (arg_input[0])
        {
        case '+':
            _add();
            break;
        case '-':
            _sub();
            break;
        case '*':
            _mul();
            break;
        case '/':
            _div();
            break;
        case '=':
            _assign();
            break;
        }
    }
    // input is a complex number
    // as the same as the user type a number
    // it performs as the same as the user pressed the '=' button
    // if the input is the first input
    // thus, we initialize the m_op to '='
    else
    {
        stringstream ss(arg_input);
        ss &gt;&gt; m_input_val;
        _calc_result();
    }
}

// main function

int main()
{
    // create an instance of the class
    Complex_Calc calc;
    string input;
    while (getline(cin, input))
    {
        calc.set_input(input);
        cout &lt;&lt; calc &lt;&lt; endl;
    }
}
</code></pre>
<h3 id="reference-code-4"><a class="header" href="#reference-code-4">Reference Code:</a></h3>
<h4 id="林恩佑109021107-1"><a class="header" href="#林恩佑109021107-1">林恩佑(109021107)</a></h4>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;cmath&gt;

using namespace std;

class Complex_Calc;

class Complex
{
private:
    // data members
    // save the real and imaginary parts of the complex number
    // with double precision
    double m_real;
    double m_imag;

public:
    // Constructor, initializes real and imaginary parts
    Complex(const double &amp;arg_real = 0.0, const double &amp;arg_imag = 0.0);
    // Copy constructor
    Complex(const Complex &amp;arg_c);
    // assignment operator
    Complex &amp;operator=(const Complex &amp;arg_c);
    // add assignment operator
    Complex &amp;operator+=(const Complex &amp;arg_c);
    // subtract assignment operator
    Complex &amp;operator-=(const Complex &amp;arg_c);
    // multiply assignment operator
    Complex &amp;operator*=(const Complex &amp;arg_c);
    // divide assignment operator
    Complex &amp;operator/=(const Complex &amp;arg_c);
    // add function
    Complex operator+(const Complex &amp;arg_c) const;
    // subtract function
    Complex operator-(const Complex &amp;arg_c) const;
    // multiply function
    Complex operator*(const Complex &amp;arg_c) const;
    // divide function
    Complex operator/(const Complex &amp;arg_c) const;
    // cout `&lt;&lt;` operator for print complex number
    // note: be careful about the format of output
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex &amp;arg_c);
    // cin `&gt;&gt;` operator for input complex number
    // note: be careful about the format of input
    // hint: use stod to convert string to double
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Complex &amp;arg_c);

    friend class Complex_Calc;
};

Complex::Complex(const double &amp;arg_real, const double &amp;arg_image)
    : m_real(arg_real), m_imag(arg_image)
{
}

Complex::Complex(const Complex &amp;arg_c)
    : m_real(arg_c.m_real), m_imag(arg_c.m_imag)
{
}

Complex &amp;Complex::operator=(const Complex &amp;arg_c)
{
    m_real = arg_c.m_real;
    m_imag = arg_c.m_imag;
    return *this;
}

Complex &amp;Complex::operator+=(const Complex &amp;arg_c)
{
    m_real += arg_c.m_real;
    m_imag += arg_c.m_imag;
    return *this;
}

Complex &amp;Complex::operator-=(const Complex &amp;arg_c)
{
    m_real -= arg_c.m_real;
    m_imag -= arg_c.m_imag;
    return *this;
}

Complex &amp;Complex::operator*=(const Complex &amp;arg_c)
{
    Complex a;
    a.m_real = m_real;
    a.m_imag = m_imag;
    m_real = a.m_real * arg_c.m_real - a.m_imag * arg_c.m_imag;
    m_imag = a.m_real * arg_c.m_imag + arg_c.m_real * a.m_imag;
    return *this;
}

Complex &amp;Complex::operator/=(const Complex &amp;arg_c)
{
    Complex a;
    a.m_real = m_real;
    a.m_imag = m_imag;
    m_real = (a.m_real * arg_c.m_real + a.m_imag * arg_c.m_imag) 
        / (arg_c.m_real * arg_c.m_real + arg_c.m_imag * arg_c.m_imag);
    m_imag = (arg_c.m_real * a.m_imag - a.m_real * arg_c.m_imag) 
        / (arg_c.m_real * arg_c.m_real + arg_c.m_imag * arg_c.m_imag);
    return *this;
}

ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex &amp;arg_c)
{
    if (arg_c.m_imag == 0)
    {
        arg_os &lt;&lt; arg_c.m_real;
    }
    else if (arg_c.m_imag &lt; 0)
    {
        arg_os &lt;&lt; arg_c.m_real &lt;&lt; &quot; - &quot; &lt;&lt; 0.0 - arg_c.m_imag &lt;&lt; &quot;i&quot;;
    }
    else
    {
        arg_os &lt;&lt; arg_c.m_real &lt;&lt; &quot; + &quot; &lt;&lt; arg_c.m_imag &lt;&lt; &quot;i&quot;;
    }
    return arg_os;
}

istream &amp;operator&gt;&gt;(istream &amp;arg_is, Complex &amp;arg_c)
{
    string strs;
    size_t sz;
    arg_c = {0, 0};
    arg_is &gt;&gt; strs;
    try
    {
        arg_c.m_real = stod(strs);
    }
    catch (const invalid_argument &amp;ia)
    {
    }
    strs = &quot;&quot;;
    arg_is &gt;&gt; strs;
    try
    {
        arg_c.m_imag = stod(strs);
    }
    catch (const invalid_argument &amp;ia)
    {
    }
    return arg_is;
}

// Complex calculator class declaration
class Complex_Calc
{
private:
    // define current value
    Complex m_curr_val;
    // define input value
    Complex m_input_val;
    // define operation
    // `+`, `-`, `*`, `/`, and `=`
    char m_op;
    // calculate result
    void _calc_result();
    // operation functions
    // add the input value to the current value
    void _add();
    // subtract the input value from the current value
    void _sub();
    // multiply the input value with the current value
    void _mul();
    // divide the current value by the input value
    void _div();
    // assign the input value to the current value
    void _assign();

public:
    // Constructor
    Complex_Calc();
    // Copy constructor
    Complex_Calc(const Complex_Calc &amp;arg_int_calc);

    // Destructor
    ~Complex_Calc(){}; // no need to do anything

    // set input value or operation
    void set_input(const string &amp;arg_input);

    // cout `&lt;&lt;` operator for print calculator status
    // note: be careful about the format of output
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex_Calc &amp;arg_comp_calc);
};

Complex_Calc::Complex_Calc()
    : m_curr_val(), m_input_val(), m_op('=')
{
}

Complex_Calc::Complex_Calc(const Complex_Calc &amp;arg_int_calc)
    : m_curr_val(arg_int_calc.m_curr_val),
      m_input_val(arg_int_calc.m_input_val),
      m_op(arg_int_calc.m_op)
{
}

void Complex_Calc::_calc_result()
{
    switch (m_op)
    {
    case '+':
        m_curr_val += m_input_val;
        break;
    case '-':
        m_curr_val -= m_input_val;
        break;
    case '*':
        m_curr_val *= m_input_val;
        break;
    case '/':
        m_curr_val /= m_input_val;
        break;
    case '=':
        m_curr_val = m_input_val;
        break;
    default:
        break;
    }
}

void Complex_Calc::_add()
{
    m_op = '+';
}

void Complex_Calc::_sub()
{
    m_op = '-';
}

void Complex_Calc::_mul()
{
    m_op = '*';
}

void Complex_Calc::_div()
{
    m_op = '/';
}

void Complex_Calc::_assign()
{
    m_op = '=';
}

ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex_Calc &amp;arg_comp_calc)
{
    Complex arg_c = arg_comp_calc.m_curr_val;
    arg_os &lt;&lt; arg_c;
    return arg_os;
}

/*
ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex_Calc &amp;arg_comp_calc){
    if (arg_c.m_imag==0){
        arg_os &lt;&lt; arg_c.m_real &lt;&lt;endl;
    }
    else if (arg_c.m_imag&lt;0){
        arg_c.m_imag*=(-1);
        arg_os&lt;&lt;arg_c.m_real&lt;&lt;&quot; - &quot;&lt;&lt;arg_c.m_imag&lt;&lt;&quot; i&quot;&lt;&lt;endl;
    }
    else{
        arg_os &lt;&lt; arg_c.m_real &lt;&lt; &quot; + &quot; &lt;&lt; arg_c.m_imag &lt;&lt;&quot; i&quot;&lt;&lt;endl;
    }
    return arg_os;
}
*/

// parse the test cases, do not modify belows

void Complex_Calc::set_input(const string &amp;arg_input)
{
    // input is empty, read again
    if (arg_input.empty())
    {
        return;
    }
    // input is a operation
    else if (arg_input == &quot;+&quot; || arg_input == &quot;-&quot; || arg_input == &quot;*&quot; 
        || arg_input == &quot;/&quot; || arg_input == &quot;=&quot;)
    {
        // set the activated operation
        // as the same as the user press the op button
        switch (arg_input[0])
        {
        case '+':
            _add();
            break;
        case '-':
            _sub();
            break;
        case '*':
            _mul();
            break;
        case '/':
            _div();
            break;
        case '=':
            _assign();
            break;
        }
    }
    // input is a complex number
    // as the same as the user type a number
    // it performs as the same as the user pressed the '=' button
    // if the input is the first input
    // thus, we initialize the m_op to '='
    else
    {
        stringstream ss(arg_input);
        ss &gt;&gt; m_input_val;
        _calc_result();
    }
}

// main function

int main()
{
    // create an instance of the class
    Complex_Calc calc;
    string input;
    while (getline(cin, input))
    {
        calc.set_input(input);
        cout &lt;&lt; calc &lt;&lt; endl;
    }
}
</code></pre>
<h4 id="ta-1"><a class="header" href="#ta-1">TA</a></h4>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;cmath&gt;

using namespace std;

class Complex_Calc;

class Complex
{
private:
    // data members
    // save the real and imaginary parts of the complex number
    // with `double` precision
    double m_real;
    double m_imag;

public:
    // Constructor, initializes real and imaginary parts
    Complex(const double &amp;arg_real = 0.0, const double &amp;arg_imag = 0.0);
    // Copy constructor
    Complex(const Complex &amp;arg_c);
    // assignment operator
    Complex &amp;operator=(const Complex &amp;arg_c);
    // add assignment operator
    Complex &amp;operator+=(const Complex &amp;arg_c);
    // subtract assignment operator
    Complex &amp;operator-=(const Complex &amp;arg_c);
    // multiply assignment operator
    Complex &amp;operator*=(const Complex &amp;arg_c);
    // divide assignment operator
    Complex &amp;operator/=(const Complex &amp;arg_c);
    // add function
    Complex operator+(const Complex &amp;arg_c) const;
    // subtract function
    Complex operator-(const Complex &amp;arg_c) const;
    // multiply function
    Complex operator*(const Complex &amp;arg_c) const;
    // divide function
    Complex operator/(const Complex &amp;arg_c) const;
    // cout `&lt;&lt;` operator for print complex number
    // note: be careful about the format of output
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex &amp;arg_c);
    // cin `&gt;&gt;` operator for input complex number
    // note: use `&gt;&gt;` to parse the string to double,
    // use `istream::fail()` to check the conversion is successful
    // and use `istream::eof()` to check the is parse to the end of line
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Complex &amp;arg_c);

    friend class Complex_Calc;
};

// Complex calculator class declaration
class Complex_Calc
{
private:
    // define current value
    Complex m_curr_val;
    // define input value
    Complex m_input_val;
    // define operation
    // `+`, `-`, `*`, `/`, and `=`
    char m_op;
    // define input status, turns `op` for true and turns `value` for false
    bool m_op_input;
    // calculate result
    void _calc_result();
    // operation functions
    // set activation op to add
    void _add();
    // set activation op to subtract
    void _sub();
    // set activation op to multiply
    void _mul();
    // set activation op to divide
    void _div();
    // set activation op to assign
    void _assign();

public:
    // Constructor
    Complex_Calc();
    // Copy constructor
    Complex_Calc(const Complex_Calc &amp;arg_int_calc);

    // Destructor
    ~Complex_Calc(){}; // no need to do anything

    // set input value or operation
    // as the same as the user input number or operation
    // into the calculator
    void set_input(const string &amp;arg_input);

    // cout `&lt;&lt;` operator for print calculator status
    // note: be careful about the format of output
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex_Calc &amp;arg_comp_calc);
};

// error and exit
void error_and_exit()
{
    cerr &lt;&lt; &quot;Error: Invalid input&quot; &lt;&lt; endl;
    exit(1);
}

// Complex class implementation

// Constructor, initializes real and imaginary parts
// hint: as like as `modify` function in examples
// but use default constructor to implement
Complex::Complex(const double &amp;arg_real, const double &amp;arg_imag)
    : m_real(arg_real), m_imag(arg_imag)
{
}

// Copy constructor
Complex::Complex(const Complex &amp;arg_c)
    : m_real(arg_c.m_real), m_imag(arg_c.m_imag)
{
}

// assignment operator
Complex &amp;Complex::operator=(const Complex &amp;arg_c)
{
    if (this == &amp;arg_c) // self-assignment
        return *this;
    m_real = arg_c.m_real;
    m_imag = arg_c.m_imag;
    return *this;
}

// add assignment operator
Complex &amp;Complex::operator+=(const Complex &amp;arg_c)
{
    m_real += arg_c.m_real;
    m_imag += arg_c.m_imag;
    return *this;
}

// subtract assignment operator
Complex &amp;Complex::operator-=(const Complex &amp;arg_c)
{
    m_real -= arg_c.m_real;
    m_imag -= arg_c.m_imag;
    return *this;
}

// multiply assignment operator
Complex &amp;Complex::operator*=(const Complex &amp;arg_c)
{
    double real = m_real * arg_c.m_real - m_imag * arg_c.m_imag;
    double imag = m_real * arg_c.m_imag + m_imag * arg_c.m_real;
    m_real = real;
    m_imag = imag;
    return *this;
}

// divide assignment operator
Complex &amp;Complex::operator/=(const Complex &amp;arg_c)
{
    if (arg_c.m_real == 0 &amp;&amp; arg_c.m_imag == 0)
        error_and_exit();

    double real = (m_real * arg_c.m_real + m_imag * arg_c.m_imag) 
        / (arg_c.m_real * arg_c.m_real + arg_c.m_imag * arg_c.m_imag);
    double imag = (m_imag * arg_c.m_real - m_real * arg_c.m_imag) 
        / (arg_c.m_real * arg_c.m_real + arg_c.m_imag * arg_c.m_imag);
    m_real = real;
    m_imag = imag;
    return *this;
}

// add function
Complex Complex::operator+(const Complex &amp;arg_c) const
{
    Complex c(*this);
    c += arg_c;
    return c;
}

// subtract function
Complex Complex::operator-(const Complex &amp;arg_c) const
{
    Complex c(*this);
    c -= arg_c;
    return c;
}

// multiply function
Complex Complex::operator*(const Complex &amp;arg_c) const
{
    Complex c(*this);
    c *= arg_c;
    return c;
}

// divide function
Complex Complex::operator/(const Complex &amp;arg_c) const
{
    Complex c(*this);
    c /= arg_c;
    return c;
}

// cout `&lt;&lt;` operator for print complex number
// note: be careful about the format of output
ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex &amp;arg_c)
{
    if (arg_c.m_imag &gt; 0)
    {
        arg_os &lt;&lt; arg_c.m_real &lt;&lt; &quot; + &quot; &lt;&lt; arg_c.m_imag &lt;&lt; &quot;i&quot;;
    }
    else if (arg_c.m_imag &lt; 0)
    {
        arg_os &lt;&lt; arg_c.m_real &lt;&lt; &quot; - &quot; &lt;&lt; -arg_c.m_imag &lt;&lt; &quot;i&quot;;
    }
    else
    {
        arg_os &lt;&lt; arg_c.m_real;
    }
    return arg_os;
}

// cin `&gt;&gt;` operator for input complex number
// note: be careful about the format of input
istream &amp;operator&gt;&gt;(istream &amp;arg_is, Complex &amp;arg_c)
{
    double input_real, input_imag;
    arg_is &gt;&gt; input_real;
    arg_is &gt;&gt; input_imag;
    arg_c.m_real = input_real;
    arg_c.m_imag = input_imag;
    return arg_is;
}

// Complex_Calc class implementation

// Constructor
Complex_Calc::Complex_Calc()
    : m_curr_val(), m_input_val(), m_op('='), m_op_input(false)
{
}

// Copy constructor
Complex_Calc::Complex_Calc(const Complex_Calc &amp;arg_int_calc)
    : m_curr_val(arg_int_calc.m_curr_val),
      m_input_val(arg_int_calc.m_input_val),
      m_op(arg_int_calc.m_op),
      m_op_input(arg_int_calc.m_op_input)
{
}

// parse the test cases, do not modify belows

void Complex_Calc::set_input(const string &amp;arg_input)
{
    // input is empty, read again
    if (arg_input.empty())
    {
        return;
    }
    // input is a operation
    else if (arg_input == &quot;+&quot; || arg_input == &quot;-&quot; || arg_input == &quot;*&quot; 
        || arg_input == &quot;/&quot; || arg_input == &quot;=&quot;)
    {
        // set the activated operation
        // as the same as the user press the op button
        switch (arg_input[0])
        {
        case '+':
            _add();
            break;
        case '-':
            _sub();
            break;
        case '*':
            _mul();
            break;
        case '/':
            _div();
            break;
        case '=':
            _assign();
            break;
        }
    }
    // input is a complex number
    // as the same as the user type a number
    // it performs as the same as the user pressed the '=' button
    // if the input is the first input
    // thus, we initialize the m_op to '='
    else
    {
        stringstream ss(arg_input);
        ss &gt;&gt; m_input_val;
        _calc_result();
    }
}

void Complex_Calc::_calc_result()
{
    switch (m_op)
    {
    case '+':
        m_curr_val += m_input_val;
        break;
    case '-':
        m_curr_val -= m_input_val;
        break;
    case '*':
        m_curr_val *= m_input_val;
        break;
    case '/':
        m_curr_val /= m_input_val;
        break;
    case '=':
        m_curr_val = m_input_val;
        break;
    }
}

// add the input value to the current value
void Complex_Calc::_add()
{
    m_op = '+';
}

// subtract the input value from the current value
void Complex_Calc::_sub()
{
    m_op = '-';
}

// multiply the input value with the current value
void Complex_Calc::_mul()
{
    m_op = '*';
}

// divide the current value by the input value
void Complex_Calc::_div()
{
    m_op = '/';
}

// assign the input value to the current value
void Complex_Calc::_assign()
{
    m_op = '=';
}

// cout `&lt;&lt;` operator for print calculator status
ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex_Calc &amp;arg_comp_calc)
{
    arg_os &lt;&lt; arg_comp_calc.m_curr_val;
    return arg_os;
}

// main function

int main()
{
    // create an instance of the class
    Complex_Calc calc;
    string input;
    while (getline(cin, input))
    {
        calc.set_input(input);
        cout &lt;&lt; calc &lt;&lt; endl;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="lab-6-3-enhanced-complex-number-calculator-20"><a class="header" href="#lab-6-3-enhanced-complex-number-calculator-20">Lab 6-3: Enhanced Complex Number Calculator (20%)</a></h2>
<ul>
<li>輸入：
<ol>
<li>以 <code>double</code> 格式輸入複數的實數及虛數部分，以空格分開，一行輸入一個複數</li>
<li>以 <code>char</code> 格式輸入複數的運算子，包含 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>，一行輸入一個運算子</li>
<li>複數與運算子以交錯的方式輸入，一行輸入一個複數接著一個運算子，倒數一行為複數</li>
<li>在任一行輸入 <kbd>Ctrl</kbd>+<kbd>D</kbd> 結束程式</li>
</ol>
<ul>
<li>Windows 請輸入 <kbd>Ctrl</kbd>+<kbd>Z</kbd> (會在螢幕上顯示 <code>^Z</code>) 再輸入 <kbd>Enter</kbd> (Format 中的 <code>⏎</code>) 結束程式</li>
</ul>
<ol start="5">
<li>程式輸入以行為單位，每行輸入為任何有效的 <code>string</code> 格式</li>
</ol>
</li>
<li>輸出：
<ol>
<li>顯示運算複數的結果</li>
<li>複數的格式為 <code>(-)&lt;real result&gt; (+|-) (&lt;imag result&gt;i)</code></li>
<li>若輸入運算子、需顯示之前運算的結果，如 <a href="class/lab/lab6-3.html#example">Example</a> 的範例</li>
<li>若使用者輸入的複數或運算子不正確，則顯示錯誤訊息 <code>Error: Invalid input</code> 並結束程式</li>
</ol>
</li>
<li>檔名：<code>lab6-3_&lt;學號&gt;.cpp</code> (e.g. <code>lab6-3_106062802.cpp</code>)</li>
</ul>
<p>注意事項：</p>
<ul>
<li>程式不會輸出任何使用者提示，只會輸出程式結果或錯誤訊息</li>
<li>程式僅需處裡輸入錯誤的例外狀況，如輸入的複數或運算子不正確，其餘錯誤不須處裡</li>
<li>請基於 pseudo code 提供的 <code>main</code> 及 <code>Complex_Calc::set_input</code> 進行修改來處理輸入與輸出</li>
<li>程式需要於 10 秒內完成，所有的測資皆會保證於 10 秒內完成</li>
</ul>
<h3 id="format-6"><a class="header" href="#format-6">Format</a></h3>
<pre><code class="language-text">&lt;real 1&gt; &lt;imag 1&gt;⏎
&lt;result 1&gt;
&lt;op 1&gt;⏎
&lt;result 1&gt;
&lt;real 2&gt; &lt;imag 2&gt;⏎
&lt;result 2&gt;
&lt;op 2&gt;⏎
&lt;result 2&gt;
...
&lt;real n-1&gt; &lt;imag n-1&gt;⏎
&lt;result n-1&gt;
&lt;op n-1&gt;⏎
&lt;result n-1&gt;
&lt;real n&gt; &lt;imag n&gt;⏎
&lt;result n&gt;
^Z⏎
</code></pre>
<h3 id="example-7"><a class="header" href="#example-7">Example</a></h3>
<h4 id="normal-1"><a class="header" href="#normal-1">Normal</a></h4>
<pre><code class="language-console">$ ./a.out
1.0 0.0⏎
1
^Z⏎
$ ./a.out
0.0 1.0⏎
0 + 1i⏎
^Z⏎
$ ./a.out
1.0 0.0⏎
1
+⏎
1
^Z⏎
$ ./a.out
^Z⏎
$ ./a.out
1.0 0.0⏎
1
+⏎
1
2.0 1.1⏎
3 + 1.1i
-⏎
3 + 1.1i
-3.0 -2.2⏎
6 + 3.3i
*⏎
6 + 3.3i
4.3 2.1⏎
18.87 + 26.79i
/⏎
18.87 + 26.79i
-1.2 -3.4⏎
-8.74846 + 2.46231i
^Z⏎
$ ./a.out
1.0 0.0⏎
1
+⏎
1
2.0 1.1⏎
3 + 1.1i
-⏎
3 + 1.1i
-3.0 -2.2⏎
6 + 3.3i
*⏎
6 + 3.3i
4.3 2.1⏎
18.87 + 26.79i
/⏎
18.87 + 26.79i
-1.2 3.4⏎
5.26477 - 7.40815i
^Z⏎
$
</code></pre>
<h4 id="exception-handling-1"><a class="header" href="#exception-handling-1">Exception Handling</a></h4>
<pre><code class="language-console">$ ./a.out
+⏎
Error: Invalid input
$
$ ./a.out
1.0 0.0⏎
1
1.0 0.0⏎
Error: Invalid input
$
$ ./a.out
1.0 0.0⏎
1
+⏎
1
+⏎
Error: Invalid input
$
$ ./a.out
1.0 2.0 3.0⏎
Error: Invalid input
$
$ ./a.out
1.0 2.0⏎
1 + 2i
sdafsdagret⏎
Error: Invalid input
$
$ ./a.out
sdoifjwepoirjpwoie⏎
Error: Invalid input
$
</code></pre>
<h3 id="pseudo-code-6"><a class="header" href="#pseudo-code-6">Pseudo Code</a></h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;cmath&gt;

using namespace std;

class Complex_Calc;

class Complex
{
private:
    // data members
    // save the real and imaginary parts of the complex number
    // with `double` precision
    double m_real;
    double m_imag;

public:
    // Constructor, initializes real and imaginary parts
    Complex(const double &amp;arg_real = 0.0, const double &amp;arg_imag = 0.0);
    // Copy constructor
    Complex(const Complex &amp;arg_c);
    // assignment operator
    Complex &amp;operator=(const Complex &amp;arg_c);
    // add assignment operator
    Complex &amp;operator+=(const Complex &amp;arg_c);
    // subtract assignment operator
    Complex &amp;operator-=(const Complex &amp;arg_c);
    // multiply assignment operator
    Complex &amp;operator*=(const Complex &amp;arg_c);
    // divide assignment operator
    Complex &amp;operator/=(const Complex &amp;arg_c);
    // add function
    Complex operator+(const Complex &amp;arg_c) const;
    // subtract function
    Complex operator-(const Complex &amp;arg_c) const;
    // multiply function
    Complex operator*(const Complex &amp;arg_c) const;
    // divide function
    Complex operator/(const Complex &amp;arg_c) const;
    // cout `&lt;&lt;` operator for print complex number
    // note: be careful about the format of output
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex &amp;arg_c);
    // cin `&gt;&gt;` operator for input complex number
    // note: use `&gt;&gt;` to parse the string to double,
    // use `istream::fail()` to check the conversion is successful
    // and use `istream::eof()` to check the is parse to the end of line
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Complex &amp;arg_c);

    friend class Complex_Calc;
};

// Complex calculator class declaration
class Complex_Calc
{
private:
    // define current value
    Complex m_curr_val;
    // define input value
    Complex m_input_val;
    // define operation
    // `+`, `-`, `*`, `/`, and `=`
    char m_op;
    // define input status, truns `op` for true and turns `value` for false
    bool m_op_input;
    // calculate result
    void _calc_result();
    // operation functions
    // set activation op to add
    void _add();
    // set activation op to subtract
    void _sub();
    // set activation op to multiply
    void _mul();
    // set activation op to divide
    void _div();
    // set activation op to assign
    void _assign();

public:
    // Constructor
    Complex_Calc();
    // Copy constructor
    Complex_Calc(const Complex_Calc &amp;arg_int_calc);

    // Destructor
    ~Complex_Calc(){}; // no need to do anything

    // set input value or operation
    // as the same as the user input number or operation
    // into the calculator
    void set_input(const string &amp;arg_input);

    // cout `&lt;&lt;` operator for print calculator status
    // note: be careful about the format of output
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex_Calc &amp;arg_comp_calc);
};

// error and exit
void error_and_exit()
{
    cerr &lt;&lt; &quot;Error: Invalid input&quot; &lt;&lt; endl;
    exit(1);
}

void Complex_Calc::set_input(const string &amp;arg_input)
{
    // input is empty, read again
    if (arg_input.empty())
    {
        return;
    }
    // input is a operator in right turn

        // set the activated operation
        // as the same as the user press the op button

        // set to 'input a complex number' turn

    // input is a complex number in right turn
    // as the same as the user type a number
    // it performs as the same as the user pressed the '=' button
    // if the input is the first input
    // thus, we initialize the m_op to '='

    // else, input is invalid
    else
    {
        error_and_exit();
    }
}

// main function

int main()
{
    // create an instance of the class
    Complex_Calc calc;
    string input;
    while (getline(cin, input))
    {
        calc.set_input(input);
        cout &lt;&lt; calc &lt;&lt; endl;
    }
}
</code></pre>
<h3 id="reference-code-5"><a class="header" href="#reference-code-5">Reference Code:</a></h3>
<h4 id="林元鴻110021120"><a class="header" href="#林元鴻110021120">林元鴻(110021120)</a></h4>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;cmath&gt;

using namespace std;

class Complex_Calc;

class Complex
{
private:
    // data members
    // save the real and imaginary parts of the complex number
    // with `double` precision
    double m_real;
    double m_imag;

public:
    // Constructor, initializes real and imaginary parts
    Complex(const double &amp;arg_real = 0.0, const double &amp;arg_imag = 0.0)
    {
        m_real = arg_real;
        m_imag = arg_imag;
    }
    // Copy constructor
    Complex(const Complex &amp;arg_c)
    {
        m_real = arg_c.m_real;
        m_imag = arg_c.m_imag;
    }
    // assignment operator
    Complex &amp;operator=(const Complex &amp;arg_c)
    {
        m_imag = arg_c.m_imag;
        m_real = arg_c.m_real;
        return *this;
    }
    // add assignment operator
    Complex &amp;operator+=(const Complex &amp;arg_c)
    {
        m_imag = m_imag + arg_c.m_imag;
        m_real = m_real + arg_c.m_real;
        return *this;
    }
    // subtract assignment operator
    Complex &amp;operator-=(const Complex &amp;arg_c)
    {
        m_imag = m_imag - arg_c.m_imag;
        m_real = m_real - arg_c.m_real;
        return *this;
    }
    // multiply assignment operator
    Complex &amp;operator*=(const Complex &amp;arg_c)
    {
        Complex p;
        p.m_real = (m_real * arg_c.m_real) - (m_imag * arg_c.m_imag);
        p.m_imag = (m_real * arg_c.m_imag) + (m_imag * arg_c.m_real);
        m_imag = p.m_imag;
        m_real = p.m_real;
        return *this;
    }
    // divide assignment operator
    Complex &amp;operator/=(const Complex &amp;arg_c)
    {
        Complex p;
        p.m_real = (arg_c.m_real * m_real + m_imag * arg_c.m_imag) 
            / (arg_c.m_real * arg_c.m_real + arg_c.m_imag * arg_c.m_imag);
        p.m_imag = (arg_c.m_real * m_imag - m_real * arg_c.m_imag) 
            / (arg_c.m_real * arg_c.m_real + arg_c.m_imag * arg_c.m_imag);
        m_imag = p.m_imag;
        m_real = p.m_real;
        return *this;
    }
    // add function
    Complex operator+(const Complex &amp;arg_c) const
    {
        Complex p;
        p.m_imag = m_imag + arg_c.m_imag;
        p.m_real = m_real + arg_c.m_real;
        return p;
    }
    // subtract function
    Complex operator-(const Complex &amp;arg_c) const
    {
        Complex p;
        p.m_imag = m_imag - arg_c.m_imag;
        p.m_real = m_real - arg_c.m_real;
        return p;
    }
    // multiply function
    Complex operator*(const Complex &amp;arg_c) const
    {
        Complex p;
        p.m_real = (m_real * arg_c.m_real) - (m_imag * arg_c.m_imag);
        p.m_imag = (m_real * arg_c.m_imag) + (m_imag * arg_c.m_real);
        return p;
    }
    // divide function
    Complex operator/(const Complex &amp;arg_c) const
    {
        Complex p;
        p.m_real = (arg_c.m_real * m_real + m_imag * arg_c.m_imag) 
            / (arg_c.m_real * arg_c.m_real + arg_c.m_imag * arg_c.m_imag);
        p.m_imag = (arg_c.m_real * m_imag - m_real * arg_c.m_imag) 
            / (arg_c.m_real * arg_c.m_real + arg_c.m_imag * arg_c.m_imag);
        return p;
    }

    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex &amp;arg_c)
    {
        if (arg_c.m_imag == 0)
            arg_os &lt;&lt; arg_c.m_real;
        else if (arg_c.m_imag &gt; 0)
            arg_os &lt;&lt; arg_c.m_real &lt;&lt; &quot; + &quot; &lt;&lt; arg_c.m_imag &lt;&lt; 'i';
        else
            arg_os &lt;&lt; arg_c.m_real &lt;&lt; &quot; - &quot; &lt;&lt; (-1) * (arg_c.m_imag) &lt;&lt; 'i';
        return arg_os;
    }

    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Complex &amp;arg_c)
    {
        string str_x, str_y, temp;

        if (getline(arg_is, str_x, ' '))
        {
            if (getline(arg_is, str_y, '\n'))
            {
                arg_c.m_real = stod(str_x);
                arg_c.m_imag = stod(str_y);
            }
        }

        return arg_is;
    }
    friend class Complex_Calc;
};

// Complex calculator class declaration
class Complex_Calc
{
private:
    // define current value
    Complex m_curr_val;
    // define input value
    Complex m_input_val;
    // define operation
    // `+`, `-`, `*`, `/`, and `=`
    string m_op;
    // calculate result
    void _calc_result()
    {
        switch (m_op[0])
        {
        case '+':
            _add();
            break;
        case '-':
            _sub();
            break;
        case '*':
            _mul();
            break;
        case '/':
            _div();
            break;
        case '=':
            _assign();
            break;
        }
        return;
    }
    // operation functions
    // add the input value to the current value
    void _add()
    {
        m_curr_val += m_input_val;
        return;
    }
    // subtract the input value from the current value
    void _sub()
    {
        m_curr_val -= m_input_val;
        return;
    }
    // multiply the input value with the current value
    void _mul()
    {
        m_curr_val *= m_input_val;
        return;
    }
    // divide the current value by the input value
    void _div()
    {
        m_curr_val /= m_input_val;
        return;
    }
    // assign the input value to the current value
    void _assign()
    {
        m_curr_val = m_input_val;
        return;
    }

public:
    // Constructor
    Complex_Calc(const Complex &amp;arg_curr_val = Complex(0, 0),
                 const Complex &amp;arg_input_val = Complex(0, 0),
                 const string op = &quot;=&quot;)
    {
        m_curr_val = arg_curr_val;
        m_input_val = arg_input_val;
        m_op = op;
    }
    //(const Complex &amp;arg_curr_val = (0, 0),
    // const Complex &amp;arg_input_val = (0,0),
    // const char op = '=')
    // Copy constructor
    Complex_Calc(const Complex_Calc &amp;arg_int_calc)
    {
        m_curr_val = arg_int_calc.m_curr_val;
        m_input_val = arg_int_calc.m_input_val;
        m_op = arg_int_calc.m_op;
    }

    // Destructor
    ~Complex_Calc(){}; // no need to do anything

    // set input value or operation
    void set_input(const string &amp;arg_input);

    // cout `&lt;&lt;` operator for print calculator status
    // note: be careful about the format of output
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex_Calc &amp;arg_comp_calc)
    {
        arg_os &lt;&lt; arg_comp_calc.m_curr_val;
        return arg_os;
    }
};

// parse the test cases, do not modify belows
void error_and_exit()
{
    cout &lt;&lt; &quot;Error: Invalid input&quot; &lt;&lt; endl;
    exit(1);
}
void Complex_Calc::set_input(const string &amp;arg_input)
{
    // input is empty, read again
    if (arg_input.empty())
    {
        error_and_exit();
        return;
    }
    // input is a operation
    else if (arg_input == &quot;+&quot; || arg_input == &quot;-&quot; 
        || arg_input == &quot;*&quot; || arg_input == &quot;/&quot; || arg_input == &quot;=&quot;)
    {
        m_op = arg_input;
    }
    // input is a complex number
    // as the same as the user type a number
    // it performs as the same as the user pressed the '=' button
    // if the input is the first input
    // thus, we initialize the m_op to '='
    else
    {
        stringstream ss(arg_input);
        ss &gt;&gt; m_input_val;
        if (m_input_val.m_imag == 0 &amp;&amp; m_input_val.m_real == 0 &amp;&amp; m_op == &quot;/&quot;)
        {
            error_and_exit();
        }
        _calc_result();
    }
}

// main function
bool test(string input, int n)
{
    if (n % 2 == 0)
    {
        int t = 0;
        for (int i = 0; i &lt; input.size(); i++)
        {
            if (input[i] == ' ')
            {
                t++;
            }
        }
        if (t != 1)
        {
            return false;
        }

        double real, imag;
        stringstream ss(input);
        ss &gt;&gt; real;

        if (ss.fail()) // if fail return false
        {
            return false;
        }

        ss &gt;&gt; imag;
        if (ss.fail())
        {
            return false;
        }

        if (!ss.eof()) // if it is not the end of file return false
        {
            return false;
        }
    }
    else
    {
        if (input.size() != 1)
        {
            return false;
        }
        else if (input[0] != '+' &amp;&amp; input[0] != '-' 
            &amp;&amp; input[0] != '*' &amp;&amp; input[0] != '/')
        {
            return false;
        }
    }
    return true;
}
int main()
{
    int n = 0;
    // create an instance of the class
    Complex_Calc calc;
    string input;
    while (getline(cin, input))
    {
        if (!(test(input, n)))
        {
            error_and_exit();
        }
        calc.set_input(input);
        cout &lt;&lt; calc &lt;&lt; endl;
        n++;
    }
}
</code></pre>
<h4 id="陳誼倫110021127-1"><a class="header" href="#陳誼倫110021127-1">陳誼倫(110021127)</a></h4>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;

using namespace std;

class Complex_Calc;

class Complex
{
private:
    double m_real;
    double m_imag;

public:
    Complex(const double &amp;arg_real = 0.0, const double &amp;arg_imag = 0.0);
    Complex(const Complex &amp;arg_c);
    Complex &amp;operator=(const Complex &amp;arg_c);
    Complex &amp;operator+=(const Complex &amp;arg_c);
    Complex &amp;operator-=(const Complex &amp;arg_c);
    Complex &amp;operator*=(const Complex &amp;arg_c);
    Complex &amp;operator/=(const Complex &amp;arg_c);
    Complex operator+(const Complex &amp;arg_c) const
    {
        Complex res(*this);
        res += arg_c;
        return res;
    }
    Complex operator-(const Complex &amp;arg_c) const
    {
        Complex res(*this);
        res -= arg_c;
        return res;
    }
    Complex operator*(const Complex &amp;arg_c) const
    {
        Complex res(*this);
        res *= arg_c;
        return res;
    }
    Complex operator/(const Complex &amp;arg_c) const
    {
        Complex res(*this);
        res /= arg_c;
        return res;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex &amp;arg_c);
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Complex &amp;arg_c);
    friend class Complex_Calc;
};

Complex::Complex(const double &amp;arg_real, const double &amp;arg_imag)
    : m_real(arg_real), m_imag(arg_imag) {}

Complex::Complex(const Complex &amp;arg_point)
    : m_real(arg_point.m_real), m_imag(arg_point.m_imag) {}

Complex &amp;Complex::operator=(const Complex &amp;arg_c)
{
    this-&gt;m_real = arg_c.m_real;
    this-&gt;m_imag = arg_c.m_imag;
    return *this;
}

Complex &amp;Complex::operator+=(const Complex &amp;arg_c)
{
    this-&gt;m_real += arg_c.m_real;
    this-&gt;m_imag += arg_c.m_imag;
    return *this;
}
Complex &amp;Complex::operator-=(const Complex &amp;arg_c)
{
    this-&gt;m_real -= arg_c.m_real;
    this-&gt;m_imag -= arg_c.m_imag;
    return *this;
}
Complex &amp;Complex::operator*=(const Complex &amp;arg_c)
{
    double _real = this-&gt;m_real, _imag = this-&gt;m_imag;
    this-&gt;m_real = (_real * arg_c.m_real) - (_imag * arg_c.m_imag);
    this-&gt;m_imag = (_real * arg_c.m_imag) + (_imag * arg_c.m_real);
    return *this;
}
Complex &amp;Complex::operator/=(const Complex &amp;arg_c)
{
    double _real = this-&gt;m_real, _imag = this-&gt;m_imag;
    this-&gt;m_real = ((_real * arg_c.m_real) + (_imag * arg_c.m_imag)) 
        / ((arg_c.m_real * arg_c.m_real + arg_c.m_imag * arg_c.m_imag));
    this-&gt;m_imag = ((-_real * arg_c.m_imag) + (_imag * arg_c.m_real)) 
        / ((arg_c.m_real * arg_c.m_real + arg_c.m_imag * arg_c.m_imag));
    return *this;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;arg_os, const Complex &amp;arg_point)
{
    if (arg_point.m_imag == 0)
    {
        arg_os &lt;&lt; arg_point.m_real;
        return arg_os;
    }
    else if (arg_point.m_imag &lt; 0)
    {
        arg_os &lt;&lt; arg_point.m_real &lt;&lt; &quot; - &quot; &lt;&lt; -arg_point.m_imag &lt;&lt; &quot;i &quot;;
        return arg_os;
    }
    else
    {
        arg_os &lt;&lt; arg_point.m_real &lt;&lt; &quot; + &quot; &lt;&lt; arg_point.m_imag &lt;&lt; &quot;i &quot;;
        return arg_os;
    }
}

std::istream &amp;operator&gt;&gt;(std::istream &amp;arg_is, Complex &amp;arg_point)
{
    string str_x, str_y, temp;

    if (getline(arg_is, str_x, ' '))
    {
        if (getline(arg_is, str_y, ' '))
        {
            arg_point.m_real = stod(str_x);
            arg_point.m_imag = stod(str_y);
        }
    }

    return arg_is;
}

class Complex_Calc
{
private:
    Complex m_curr_val;
    Complex m_input_val;
    char m_op, op;
    int process = 0;

    void _calc_result()
    {
        switch (m_op)
        {
        case '+':
            m_curr_val += m_input_val;
            break;
        case '-':
            m_curr_val -= m_input_val;
            break;
        case '*':
            m_curr_val *= m_input_val;
            break;
        case '/':
            if (m_input_val.m_real == 0 &amp;&amp; m_input_val.m_imag == 0)
            {
                error_and_exit();
            }
            else
            {
                m_curr_val /= m_input_val;
                break;
            }
        case '=':
            m_curr_val = m_input_val;
            break;
        }
    }
    void _add()
    {
        m_op = '+';
    }
    void _sub()
    {
        m_op = '-';
    }
    void _mul()
    {
        m_op = '*';
    }
    void _div()
    {
        m_op = '/';
    }
    void _assign()
    {
        m_op = '=';
    }

public:
    Complex_Calc();
    Complex_Calc(const Complex_Calc &amp;arg_int_calc);
    ~Complex_Calc(){};

    void error_and_exit();

    void set_input(const string &amp;arg_input);

    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex_Calc &amp;arg_comp_calc);
};

Complex_Calc::Complex_Calc() : m_curr_val(), m_input_val(), m_op('=')
{
}

Complex_Calc::Complex_Calc(const Complex_Calc &amp;arg_int_calc)
    : m_curr_val(arg_int_calc.m_curr_val),
      m_input_val(arg_int_calc.m_input_val),
      m_op(arg_int_calc.m_op)
{
}

bool check_complex(const string &amp;input)
{
    string temp_str;
    vector&lt;string&gt; vec;
    stringstream terms_extractor(input);
    while (terms_extractor &gt;&gt; temp_str)
    {
        vec.push_back(temp_str);
    }
    if (vec.size() == 2)
    {
        if ((!isdigit(vec[0][0]) &amp;&amp; vec[0][0] != '-') 
            || (!isdigit(vec[1][0]) &amp;&amp; vec[1][0] != '-'))
        {
            return false;
        }

        for (int i = 1; i &lt; vec[0].size(); i++)
        {
            if (isdigit(vec[0][i]) || vec[0][i] == '.')
            {
                continue;
            }
            else
            {
                return false;
            }
        }
        for (int i = 1; i &lt; vec[1].size(); i++)
        {
            if (isdigit(vec[1][i]) || vec[1][i] == '.')
            {
                continue;
            }
            else
            {
                return false;
            }
        }
    }
    else
    {
        return false;
    }
    return true;
}

bool check_op(const string &amp;input)
{
    if (input == &quot;+&quot; || input == &quot;-&quot; || input == &quot;*&quot; || input == &quot;/&quot;)
    {
        return true;
    }
    else
    {
        return false;
    }
}

void Complex_Calc::set_input(const string &amp;arg_input)
{

    if ((process % 2 == 1) &amp;&amp; (check_op(arg_input) == true))
    {
        op = arg_input[0];
    }
    else if ((process % 2 == 0) &amp;&amp; (check_complex(arg_input) == true))
    {
        switch (op)
        {
        case '+':
            _add();
            break;
        case '-':
            _sub();
            break;
        case '*':
            _mul();
            break;
        case '/':
            _div();
            break;
        case '=':
            _assign();
            break;
        }
        stringstream ss(arg_input);
        ss &gt;&gt; m_input_val;
        _calc_result();
    }

    else
    {
        error_and_exit();
    }
    process = process + 1;
}

void Complex_Calc::error_and_exit()
{
    cout &lt;&lt; &quot;Error: Invalid input&quot; &lt;&lt; endl;
    exit(1);
}

std::ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex_Calc &amp;arg_comp_calc)
{
    arg_os &lt;&lt; arg_comp_calc.m_curr_val;
    return arg_os;
}
// main function

int main()
{
    // create an instance of the class
    Complex_Calc calc;
    string input;
    while (getline(cin, input))
    {
        calc.set_input(input);
        cout &lt;&lt; calc &lt;&lt; endl;
    }
}
</code></pre>
<h4 id="ta-2"><a class="header" href="#ta-2">TA</a></h4>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;cmath&gt;

using namespace std;

class Complex_Calc;

class Complex
{
private:
    // data members
    // save the real and imaginary parts of the complex number
    // with `double` precision
    double m_real;
    double m_imag;

public:
    // Constructor, initializes real and imaginary parts
    Complex(const double &amp;arg_real = 0.0, const double &amp;arg_imag = 0.0);
    // Copy constructor
    Complex(const Complex &amp;arg_c);
    // assignment operator
    Complex &amp;operator=(const Complex &amp;arg_c);
    // add assignment operator
    Complex &amp;operator+=(const Complex &amp;arg_c);
    // subtract assignment operator
    Complex &amp;operator-=(const Complex &amp;arg_c);
    // multiply assignment operator
    Complex &amp;operator*=(const Complex &amp;arg_c);
    // divide assignment operator
    Complex &amp;operator/=(const Complex &amp;arg_c);
    // add function
    Complex operator+(const Complex &amp;arg_c) const;
    // subtract function
    Complex operator-(const Complex &amp;arg_c) const;
    // multiply function
    Complex operator*(const Complex &amp;arg_c) const;
    // divide function
    Complex operator/(const Complex &amp;arg_c) const;
    // cout `&lt;&lt;` operator for print complex number
    // note: be careful about the format of output
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex &amp;arg_c);
    // cin `&gt;&gt;` operator for input complex number
    // note: use `&gt;&gt;` to parse the string to double,
    // use `istream::fail()` to check the conversion is successful
    // and use `istream::eof()` to check the is parse to the end of line
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Complex &amp;arg_c);

    friend class Complex_Calc;
};

// Complex calculator class declaration
class Complex_Calc
{
private:
    // define current value
    Complex m_curr_val;
    // define input value
    Complex m_input_val;
    // define operation
    // `+`, `-`, `*`, `/`, and `=`
    char m_op;
    // define input status, turns `op` for true and turns `value` for false
    bool m_op_input;
    // calculate result
    void _calc_result();
    // operation functions
    // set activation op to add
    void _add();
    // set activation op to subtract
    void _sub();
    // set activation op to multiply
    void _mul();
    // set activation op to divide
    void _div();
    // set activation op to assign
    void _assign();

public:
    // Constructor
    Complex_Calc();
    // Copy constructor
    Complex_Calc(const Complex_Calc &amp;arg_int_calc);

    // Destructor
    ~Complex_Calc(){}; // no need to do anything

    // set input value or operation
    // as the same as the user input number or operation
    // into the calculator
    void set_input(const string &amp;arg_input);

    // cout `&lt;&lt;` operator for print calculator status
    // note: be careful about the format of output
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex_Calc &amp;arg_comp_calc);
};

// error and exit
void error_and_exit()
{
    cerr &lt;&lt; &quot;Error: Invalid input&quot; &lt;&lt; endl;
    exit(1);
}

// Complex class implementation

// Constructor, initializes real and imaginary parts
// hint: as like as `modify` function in examples
// but use default constructor to implement
Complex::Complex(const double &amp;arg_real, const double &amp;arg_imag)
    : m_real(arg_real), m_imag(arg_imag)
{
}

// Copy constructor
Complex::Complex(const Complex &amp;arg_c)
    : m_real(arg_c.m_real), m_imag(arg_c.m_imag)
{
}

// assignment operator
Complex &amp;Complex::operator=(const Complex &amp;arg_c)
{
    if (this == &amp;arg_c) // self-assignment
        return *this;
    m_real = arg_c.m_real;
    m_imag = arg_c.m_imag;
    return *this;
}

// add assignment operator
Complex &amp;Complex::operator+=(const Complex &amp;arg_c)
{
    m_real += arg_c.m_real;
    m_imag += arg_c.m_imag;
    return *this;
}

// subtract assignment operator
Complex &amp;Complex::operator-=(const Complex &amp;arg_c)
{
    m_real -= arg_c.m_real;
    m_imag -= arg_c.m_imag;
    return *this;
}

// multiply assignment operator
Complex &amp;Complex::operator*=(const Complex &amp;arg_c)
{
    double real = m_real * arg_c.m_real - m_imag * arg_c.m_imag;
    double imag = m_real * arg_c.m_imag + m_imag * arg_c.m_real;
    m_real = real;
    m_imag = imag;
    return *this;
}

// divide assignment operator
Complex &amp;Complex::operator/=(const Complex &amp;arg_c)
{
    if (arg_c.m_real == 0 &amp;&amp; arg_c.m_imag == 0)
        error_and_exit();

    double real = (m_real * arg_c.m_real + m_imag * arg_c.m_imag) 
        / (arg_c.m_real * arg_c.m_real + arg_c.m_imag * arg_c.m_imag);
    double imag = (m_imag * arg_c.m_real - m_real * arg_c.m_imag) 
        / (arg_c.m_real * arg_c.m_real + arg_c.m_imag * arg_c.m_imag);
    m_real = real;
    m_imag = imag;
    return *this;
}

// add function
Complex Complex::operator+(const Complex &amp;arg_c) const
{
    Complex c(*this);
    c += arg_c;
    return c;
}

// subtract function
Complex Complex::operator-(const Complex &amp;arg_c) const
{
    Complex c(*this);
    c -= arg_c;
    return c;
}

// multiply function
Complex Complex::operator*(const Complex &amp;arg_c) const
{
    Complex c(*this);
    c *= arg_c;
    return c;
}

// divide function
Complex Complex::operator/(const Complex &amp;arg_c) const
{
    Complex c(*this);
    c /= arg_c;
    return c;
}

// cout `&lt;&lt;` operator for print complex number
// note: be careful about the format of output
ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex &amp;arg_c)
{
    if (arg_c.m_imag &gt; 0)
    {
        arg_os &lt;&lt; arg_c.m_real &lt;&lt; &quot; + &quot; &lt;&lt; arg_c.m_imag &lt;&lt; &quot;i&quot;;
    }
    else if (arg_c.m_imag &lt; 0)
    {
        arg_os &lt;&lt; arg_c.m_real &lt;&lt; &quot; - &quot; &lt;&lt; -arg_c.m_imag &lt;&lt; &quot;i&quot;;
    }
    else
    {
        arg_os &lt;&lt; arg_c.m_real;
    }
    return arg_os;
}

// cin `&gt;&gt;` operator for input complex number
// note: be careful about the format of input
istream &amp;operator&gt;&gt;(istream &amp;arg_is, Complex &amp;arg_c)
{
    double input_real, input_imag;
    arg_is &gt;&gt; input_real;
    if (arg_is.fail())
    {
        error_and_exit();
    }
    arg_is &gt;&gt; input_imag;
    if (arg_is.fail() || !arg_is.eof())
    {
        error_and_exit();
    }
    arg_c.m_real = input_real;
    arg_c.m_imag = input_imag;
    return arg_is;
}

// Complex_Calc class implementation

// Constructor
Complex_Calc::Complex_Calc()
    : m_curr_val(), m_input_val(), m_op('='), m_op_input(false)
{
}

// Copy constructor
Complex_Calc::Complex_Calc(const Complex_Calc &amp;arg_int_calc)
    : m_curr_val(arg_int_calc.m_curr_val),
      m_input_val(arg_int_calc.m_input_val),
      m_op(arg_int_calc.m_op),
      m_op_input(arg_int_calc.m_op_input)
{
}

void Complex_Calc::set_input(const string &amp;arg_input)
{
    // input is empty, read again
    if (arg_input.empty())
        return;

    // input is a operator in right turn
    else if (m_op_input &amp;&amp; (arg_input == &quot;+&quot; || arg_input == &quot;-&quot; 
        || arg_input == &quot;*&quot; || arg_input == &quot;/&quot; || arg_input == &quot;=&quot;))
    {
        // set the activated operation
        // as the same as the user press the op button
        switch (arg_input[0])
        {
        case '+':
            _add();
            break;
        case '-':
            _sub();
            break;
        case '*':
            _mul();
            break;
        case '/':
            _div();
            break;
        case '=':
            _assign();
            break;
        }
        // set to 'input a complex number' turn
        m_op_input = false;
    }

    // input is a complex number in right turn
    // as the same as the user type a number
    // it performs as the same as the user pressed the '=' button
    // if the input is the first input
    // thus, we initialize the m_op to '='
    else if (!m_op_input)
    {
        stringstream ss(arg_input);
        ss &gt;&gt; m_input_val;
        _calc_result();
        m_op_input = true;
    }

    // else, input is invalid
    else
    {
        error_and_exit();
    }
}

void Complex_Calc::_calc_result()
{
    switch (m_op)
    {
    case '+':
        m_curr_val += m_input_val;
        break;
    case '-':
        m_curr_val -= m_input_val;
        break;
    case '*':
        m_curr_val *= m_input_val;
        break;
    case '/':
        m_curr_val /= m_input_val;
        break;
    case '=':
        m_curr_val = m_input_val;
        break;
    }
}

// add the input value to the current value
void Complex_Calc::_add()
{
    m_op = '+';
}

// subtract the input value from the current value
void Complex_Calc::_sub()
{
    m_op = '-';
}

// multiply the input value with the current value
void Complex_Calc::_mul()
{
    m_op = '*';
}

// divide the current value by the input value
void Complex_Calc::_div()
{
    m_op = '/';
}

// assign the input value to the current value
void Complex_Calc::_assign()
{
    m_op = '=';
}

// cout `&lt;&lt;` operator for print calculator status
ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex_Calc &amp;arg_comp_calc)
{
    arg_os &lt;&lt; arg_comp_calc.m_curr_val;
    return arg_os;
}

// main function

int main()
{
    // create an instance of the class
    Complex_Calc calc;
    string input;
    while (getline(cin, input))
    {
        calc.set_input(input);
        cout &lt;&lt; calc &lt;&lt; endl;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!---
marp: true
author: Yi-Wen Hung
theme: default
headingDivider: 2
paginate: true
--->
<h1 id="introduction-to-object-oriented-programming--design"><a class="header" href="#introduction-to-object-oriented-programming--design">Introduction to Object Oriented Programming &amp; Design</a></h1>
<blockquote>
<p>Slides version: <a href="oop/./lecture7_slides.html">lecture7_slides.html</a>
Website version: <a href="oop/./lecture7.html">lecture7.html</a></p>
</blockquote>
<ul>
<li>What is Object Oriented Programming?</li>
</ul>
<ul>
<li>What is Object Oriented Analysis and Design?</li>
<li>Object Oriented Analysis
<ul>
<li>Example: Calculator
<ul>
<li>Use cases</li>
<li>Object models</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>Object Oriented Design
<ul>
<li>Example: Calculator
<ul>
<li>System Design</li>
<li>Object Design</li>
</ul>
</li>
</ul>
</li>
<li>Object Oriented Implementation
<ul>
<li>Example: Calculator</li>
</ul>
</li>
<li>Summary</li>
<li>Pratices</li>
</ul>
<h2 id="what-is-object-oriented-programming"><a class="header" href="#what-is-object-oriented-programming">What is Object Oriented Programming?</a></h2>
<p>Example: Calculator</p>
<table><thead><tr><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody>
<tr><td align="center">C</td><td align="center">±</td><td align="center">%</td><td align="center">/</td></tr>
<tr><td align="center">7</td><td align="center">8</td><td align="center">9</td><td align="center">*</td></tr>
<tr><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">-</td></tr>
<tr><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">+</td></tr>
<tr><td align="center">0</td><td align="center"></td><td align="center">.</td><td align="center">=</td></tr>
</tbody></table>
<hr />
<p>A calculator consists of a set of buttons, each of which has following functions:</p>
<ul>
<li>Numbers: <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code>, <code>9</code>, <code>0</code></li>
<li>Operations: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code></li>
<li>Symbols: ±(<code>p</code>lusminus), <code>%</code>, <code>.</code></li>
<li>Function: <code>=</code>, <code>C</code>(lear)</li>
</ul>
<hr />
<p>So, we can model the calculator as a class. For example:</p>
<pre><code class="language-c++">class Button
{
    // ...
};
class Calc_Controller
{
    // ...
};
class Calculator
{
    // ...
};
</code></pre>
<p>But, how?</p>
<h2 id="what-is-object-oriented-analysis-and-design"><a class="header" href="#what-is-object-oriented-analysis-and-design">What is Object Oriented Analysis and Design?</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Object-oriented_analysis_and_design">Object-oriented analysis and design - Wikipedia</a></p>
<blockquote>
<p>Object-oriented analysis and design (OOAD) is a technical approach for analyzing and designing an application, system, or business by applying object-oriented programming, as well as using visual modeling throughout the software development process to guide stakeholder communication and product quality.</p>
</blockquote>
<h2 id="object-oriented-analysis"><a class="header" href="#object-oriented-analysis">Object Oriented Analysis</a></h2>
<p>First, we need to review the use cases and list the object models.</p>
<h3 id="use-case-calculator"><a class="header" href="#use-case-calculator">Use case: Calculator</a></h3>
<ul>
<li>A calculator consists of a set of buttons, each of which has following functions:
<ul>
<li>Numbers: <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code>, <code>9</code>, <code>0</code></li>
<li>Operations: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code></li>
<li>Symbols: ±(<code>p</code>lusminus), <code>%</code>, <code>.</code></li>
<li>Function: <code>=</code>, <code>C</code>(lear)</li>
</ul>
</li>
</ul>
<hr />
<ol>
<li>User want to type in a number, user need to press number buttons or <code>.</code>, from left to right
<ol>
<li>If the number is a percentage, press <code>%</code> after finish typing a number</li>
<li>If the number is a negative number, press <code>±</code> after finish typing a number</li>
<li>If the typed number is wrong, press <code>C</code> to clear the number</li>
</ol>
</li>
<li>After finish typing a number, user need to press an operation button</li>
<li>perform the previous operation with the current result and the typed number
<ol>
<li>If the typed number is the first number, set the result with the typed number, as the same as the user press <code>=</code> in 2.</li>
</ol>
</li>
<li>Do 1. to 3. until user press <code>=</code></li>
</ol>
<hr />
<h3 id="object-models-calculator"><a class="header" href="#object-models-calculator">Object models: Calculator</a></h3>
<p>Next, we need to list the objects and their attributes.</p>
<p>Calculator:</p>
<ul>
<li>result: number</li>
<li>buttons:
<ul>
<li>Numbers: <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code>, <code>9</code>, <code>0</code></li>
<li>Operations: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code></li>
<li>Symbols: ±(<code>p</code>lusminus), <code>%</code>, <code>.</code></li>
<li>Function: <code>=</code>, <code>C</code>(lear)</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>controller
<ul>
<li>a button is pressed</li>
<li>a number is typed
<ul>
<li><code>C</code>lear is pressed</li>
<li><code>±</code> is pressed</li>
<li><code>%</code> is pressed</li>
<li><code>.</code> is pressed</li>
</ul>
</li>
<li>an operation is pressed</li>
<li><code>=</code> is pressed</li>
</ul>
</li>
</ul>
<h2 id="object-oriented-design"><a class="header" href="#object-oriented-design">Object Oriented Design</a></h2>
<p>After we have the object models, we can design the system and the objects.</p>
<h3 id="system-design"><a class="header" href="#system-design">System Design</a></h3>
<p>Calculator:</p>
<ul>
<li>input: buttons</li>
<li>output: result</li>
<li>status: result, controller, buttons</li>
</ul>
<hr />
<p>Use cases:</p>
<ul>
<li>send which button is pressed to controller</li>
<li>send result to controller as the input of previous operation</li>
<li>contoller will update the result of the calculator with the input number, operation, and the previous result</li>
</ul>
<hr />
<h3 id="object-design"><a class="header" href="#object-design">Object Design</a></h3>
<p>Botton:</p>
<ul>
<li>identify which button is pressed</li>
<li>send which button is pressed</li>
</ul>
<hr />
<p>Controller </p>
<ul>
<li>translate the pressed buttons to the corresponding actions:
<ul>
<li>a number is typed
<ul>
<li><code>C</code>lear is pressed</li>
<li><code>±</code> is pressed</li>
<li><code>%</code> is pressed</li>
</ul>
</li>
<li>an operation is pressed</li>
<li><code>=</code> is pressed</li>
</ul>
</li>
<li>get the previous result</li>
<li>send the result to the calculator</li>
</ul>
<h2 id="object-oriented-implementation"><a class="header" href="#object-oriented-implementation">Object Oriented Implementation</a></h2>
<p>Finally, we can implement the system and the objects.</p>
<h3 id="botton"><a class="header" href="#botton">Botton</a></h3>
<pre><code class="language-c++">class Button
{
protected:
    char symbol;

public:
    Button(char arg_btn_char)
        : symbol(arg_btn_char)
    {
    }
    virtual char press() const // polymorphism, will discuss in lecture 11
    {
        return '\0';
    }
};
</code></pre>
<hr />
<pre><code class="language-c++">class Num_Button : public Button // inherits from Button, will discuss in next lecture
{
public:
    Num_Button(char arg_btn_char = '\0') : Button(arg_btn_char)
    {
        // ...
    }
    char press() const
    {
        return symbol;
    }
};
class Op_Button : public Button
{
public:
    Op_Button(char arg_btn_char = '\0') : Button(arg_btn_char)
    {
        // ...
    }
    char press() const
    {
        return symbol;
    }
};
</code></pre>
<hr />
<pre><code class="language-c++">class Sym_Button : public Button
{
public:
    Sym_Button(char arg_btn_char = '\0') : Button(arg_btn_char)
    {
        // ...
    }
    char press() const
    {
        return symbol;
    }
};
class Func_button : public Button
{
public:
    Func_button(char arg_btn_char = '\0') : Button(arg_btn_char)
    {
        // ...
    }
    char press() const
    {
        return symbol;
    }
};
</code></pre>
<hr />
<h3 id="controller"><a class="header" href="#controller">Controller</a></h3>
<pre><code class="language-c++">class Calc_Controller
{
private:
    int status; // 0 = init, 1 = type num, 2 = press op or assign
    char next_op;
    char curr_op;
    bool decimal_pressed;
    double type_num;
    bool minus_pressed;
    int decimal_offset;
</code></pre>
<hr />
<pre><code class="language-c++">public:
    Calc_Controller()
        : status(0), next_op('='), curr_op('='), decimal_pressed(false),
          type_num(0), minus_pressed(false), decimal_offset(1)
    {
    }
    void button_pressed(Button &amp;arg_btn)
    {
        switch (status)
        {
        case 0:
            if (typeid(arg_btn) == typeid(Num_Button))
            {
                status = 1;
                type_num = arg_btn.press() - '0';
            }
            else if (typeid(arg_btn) == typeid(Op_Button))
            {
                status = 2;
                next_op = arg_btn.press();
            }
</code></pre>
<hr />
<pre><code class="language-c++">            else if (typeid(arg_btn) == typeid(Sym_Button))
            {
                status = 1;
                switch (arg_btn.press())
                {
                case '.':
                    decimal_pressed = true;
                    break;
                case 'p':
                    minus_pressed = true;
                    break;
                default:
                    break;
                }
            }
            else if (typeid(arg_btn) == typeid(Func_button))
            {
                status = 0;
                next_op = '=';
                arg_btn.press();
            }
            break;
</code></pre>
<hr />
<pre><code class="language-c++">        case 1:
            if (typeid(arg_btn) == typeid(Num_Button))
            {
                if (decimal_pressed)
                {
                    decimal_offset *= 10;
                }
                type_num *= 10;
                type_num += arg_btn.press() - '0';
            }
            else if (typeid(arg_btn) == typeid(Op_Button))
            {
                status = 2;
                curr_op = next_op;
                next_op = arg_btn.press();
                type_num = type_num * (minus_pressed ? -1 : 1) / decimal_offset;
            }
</code></pre>
<hr />
<pre><code class="language-c++">            else if (typeid(arg_btn) == typeid(Sym_Button))
            {
                switch (arg_btn.press())
                {
                case '.':
                    decimal_pressed = true;
                    break;
                case 'p':
                    minus_pressed = !minus_pressed;
                    break;
                case '%':
                    type_num = type_num * 0.01;
                    break;
                default:
                    break;
                }
            }
            else if (typeid(arg_btn) == typeid(Func_button))
            {
                switch (arg_btn.press())
                {
                case 'c':
                    type_num = 0;
                    break;
                case '=':
                    curr_op = next_op;
                    next_op = arg_btn.press();
                    status = 2;
                    type_num = type_num * (minus_pressed ? -1 : 1) / decimal_offset;
                }
            }
            break;
</code></pre>
<hr />
<pre><code class="language-c++">        case 2:
            if (typeid(arg_btn) == typeid(Num_Button))
            {
                status = 1;
                type_num = arg_btn.press() - '0';
            }
            else if (typeid(arg_btn) == typeid(Op_Button))
            {
                next_op = arg_btn.press();
            }
            else if (typeid(arg_btn) == typeid(Sym_Button))
            {
                status = 1;
                switch (arg_btn.press())
                {
                case '.':
                    decimal_pressed = true;
                    break;
                case 'p':
                    minus_pressed = !minus_pressed;
                    break;
                case '%':
                    type_num = type_num * 0.01;
                    break;
                default:
                    break;
                }
            }
</code></pre>
<hr />
<pre><code class="language-c++">            else if (typeid(arg_btn) == typeid(Func_button))
            {
                switch (arg_btn.press())
                {
                case 'c':
                    type_num = 0;
                    status = 0;
                    curr_op = '=';
                    next_op = '=';
                    break;
                case '=':
                    curr_op = '=';
                    next_op = '=';
                    break;
                }
            }
            break;
        }
    }
</code></pre>
<hr />
<pre><code class="language-c++">    double update_result(const double &amp;arg_result)
    {
        switch (status)
        {
        case 0:
            return arg_result;
        case 1:
            return arg_result;
        case 2:
            switch (curr_op)
            {
            case '+':
                return arg_result + type_num;
            case '-':
                return arg_result - type_num;
            case '*':
                return arg_result * type_num;
            case '/':
                return arg_result / type_num;
            case '=':
                return type_num;
            default:
                return arg_result;
            }
        }
        return arg_result;
    }
};
</code></pre>
<hr />
<h3 id="calculator"><a class="header" href="#calculator">Calculator</a></h3>
<pre><code class="language-c++">class Calculator
{
private:
    double result;
    Calc_Controller controller;
    Num_Button num_buttons[10];
    Op_Button op_buttons[4];
    Sym_Button sym_buttons[3];
    Func_button func_buttons[2];
    void _run()
    {
        controller.button_pressed(num_buttons[1]); // 1
        result = controller.update_result(result);
        controller.button_pressed(op_buttons[0]); // +
        result = controller.update_result(result);
        controller.button_pressed(num_buttons[2]); // 2
        result = controller.update_result(result);
        controller.button_pressed(func_buttons[1]); // =
        result = controller.update_result(result);
    }
</code></pre>
<hr />
<pre><code class="language-c++">public:
    Calculator() // like we turn on a calculator
        : result(0.0), controller()
    {
        // init num_buttons
        for (int i = 0; i &lt; 10; i++)
        {
            num_buttons[i] = Num_Button(i + '0');
        }
        // init op_buttons
        op_buttons[0] = Op_Button('+');
        op_buttons[1] = Op_Button('-');
        op_buttons[2] = Op_Button('*');
        op_buttons[3] = Op_Button('/');
        // init sym_buttons
        sym_buttons[0] = Sym_Button('.');
        sym_buttons[1] = Sym_Button('p');
        sym_buttons[2] = Sym_Button('%');
        // init func_buttons
        func_buttons[0] = Func_button('C');
        func_buttons[1] = Func_button('=');
        _run();
    }
    ~Calculator() // like we turn off a calculator
    {
    }
};

int main()
{
    Calculator calc;
    return 0;
}
</code></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>4 steps to perform object-oriented programming:</p>
<ol start="0">
<li>Define use cases</li>
<li>Define objects by use cases</li>
<li>Define whole system by objects</li>
<li>Detail define objects and their properties </li>
<li>Implement objects and system</li>
</ol>
<h2 id="pratices-3"><a class="header" href="#pratices-3">Pratices</a></h2>
<p>Use the workflow above to implement the following problems:</p>
<ol>
<li>Elevator system</li>
<li>Basketball game</li>
<li>Closet</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!---
marp: true
author: Yi-Wen Hung
theme: default
headingDivider: 2
paginate: true
--->
<h1 id="oop-inheritance-1"><a class="header" href="#oop-inheritance-1">OOP: Inheritance (1)</a></h1>
<blockquote>
<p>Slides version: <a href="oop/./lecture8_slides.html">lecture8_slides.html</a>
Website version: <a href="oop/./lecture8.html">lecture8.html</a></p>
</blockquote>
<ul>
<li>What is Inheritance? and Why do we need it?
<ul>
<li>Example: Bus, Car, and Truck.</li>
</ul>
</li>
</ul>
<ul>
<li>Syntax</li>
<li>Inheritance Mode
<ul>
<li>Public, Protected, Private
<ul>
<li>Example</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>Inheritance Type
<ul>
<li>Single</li>
<li>Multiple</li>
<li>Multi-level</li>
<li>Hierarchical (discuss in the next lecture)</li>
<li>Hybrid (Virtual) Inheritance (discuss in the next lecture)</li>
<li>Multipath inheritance (discuss in the next lecture)</li>
</ul>
</li>
<li>Example 1: Integer &amp; Real</li>
<li>Example 2: Complex Number</li>
<li>Example 3: Integer &amp; Real &amp; Complex Number</li>
<li>Pratices</li>
</ul>
<h2 id="what-is-inheritance-and-why-do-we-need-it"><a class="header" href="#what-is-inheritance-and-why-do-we-need-it">What is Inheritance? and Why do we need it?</a></h2>
<p>Ref: <a href="https://www.geeksforgeeks.org/inheritance-in-c/">Inheritance in C++</a></p>
<blockquote>
<p>The capability of a class to derive properties and characteristics from another class is called <strong>Inheritance</strong>.</p>
</blockquote>
<h3 id="example-bus-car-and-truck"><a class="header" href="#example-bus-car-and-truck">Example: Bus, Car, and Truck.</a></h3>
<p><img src="oop/./img/inheritance.png" alt="" /></p>
<hr />
<p>Because bus, car and truck are all vehicles, and they all have the same member functions, we can use inheritance to reduce the amount of code we need to write. For example, <code>class Vehicle</code>:</p>
<p><img src="oop/./img/inheritance2.png" alt="" /></p>
<h2 id="syntax-1"><a class="header" href="#syntax-1">Syntax</a></h2>
<pre><code class="language-c++">class subclass_name : access_mode base_class_name
{
  // body of subclass
};
</code></pre>
<hr />
<h3 id="example-bus-car-and-truck-1"><a class="header" href="#example-bus-car-and-truck-1">Example: Bus, Car, and Truck.</a></h3>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Vehicle
{
public:
    void run()
    {
        std::cout &lt;&lt; &quot;Vehicle is running&quot; &lt;&lt; std::endl;
    }
};
class Bus : public Vehicle
{
};
class Car : public Vehicle
{
};
</code></pre>
<hr />
<pre><code class="language-c++">class Truck : public Vehicle
{
};
int main()
{
    Bus bus;
    Car car;
    Truck truck;
    bus.run();
    car.run();
    truck.run();
    return 0;
}
</code></pre>
<p>Output:</p>
<pre><code class="language-console">$ ./a.out
Vehicle is running
Vehicle is running
Vehicle is running
</code></pre>
<hr />
<h3 id="example-parent--child"><a class="header" href="#example-parent--child">Example: Parent &amp; Child</a></h3>
<pre><code class="language-c++">// C++ program to demonstrate implementation
// of Inheritance

#include &lt;bits/stdc++.h&gt;
using namespace std;

// Base class
class Parent
{
public:
    int id_p;
};

// Sub class inheriting from Base Class(Parent)
class Child : public Parent
{
public:
    int id_c;
};
</code></pre>
<hr />
<pre><code class="language-c++">// main function
int main()
{
    Child obj1;

    // An object of class child has all data members
    // and member functions of class parent
    obj1.id_c = 7;
    obj1.id_p = 91;
    cout &lt;&lt; &quot;Child id is: &quot; &lt;&lt; obj1.id_c &lt;&lt; '\n';
    cout &lt;&lt; &quot;Parent id is: &quot; &lt;&lt; obj1.id_p &lt;&lt; '\n';

    return 0;
}
</code></pre>
<p>Output:</p>
<pre><code class="language-console">$ ./a.out
Child id is: 7
Parent id is: 91
</code></pre>
<h2 id="inheritance-mode"><a class="header" href="#inheritance-mode">Inheritance Mode</a></h2>
<table><thead><tr><th align="center">Class Member Type</th><th align="center">Type of</th><th align="center">Inheritence</th><th align="center"></th></tr></thead><tbody>
<tr><td align="center"></td><td align="center">Public</td><td align="center">Protected</td><td align="center">Private</td></tr>
<tr><td align="center">Public</td><td align="center"><strong>Public</strong></td><td align="center"><strong>Protected</strong></td><td align="center"><strong>Private</strong></td></tr>
<tr><td align="center">Protected</td><td align="center"><strong>Protected</strong></td><td align="center"><strong>Protected</strong></td><td align="center"><strong>Private</strong></td></tr>
<tr><td align="center">Private</td><td align="center"><strong>Not accessible</strong></td><td align="center"><strong>Not accessible</strong></td><td align="center"><strong>Not accessible</strong></td></tr>
</tbody></table>
<hr />
<h3 id="example-inheritance-mode"><a class="header" href="#example-inheritance-mode">Example: Inheritance Mode</a></h3>
<pre><code class="language-c++">// C++ Implementation to show that a derived class
// doesn’t inherit access to private data members.
// However, it does inherit a full parent object.
class A
{
public:
    int x;

protected:
    int y;

private:
    int z;
};
</code></pre>
<hr />
<pre><code class="language-c++">class B : public A
{
    // x is public
    // y is protected
    // z is not accessible from B
};

class C : protected A
{
    // x is protected
    // y is protected
    // z is not accessible from C
};

class D : private A // 'private' is default for classes
{
    // x is private
    // y is private
    // z is not accessible from D
};
</code></pre>
<h2 id="inheritance-type"><a class="header" href="#inheritance-type">Inheritance Type</a></h2>
<ul>
<li>Single</li>
<li>Multiple</li>
<li>Multi-level</li>
<li>Hierarchical (discuss in the next lecture)</li>
<li>Hybrid (Virtual) Inheritance (discuss in the next lecture)</li>
<li>Multipath inheritance (discuss in the next lecture)</li>
</ul>
<hr />
<h3 id="single-inheritance"><a class="header" href="#single-inheritance">Single Inheritance</a></h3>
<p><img src="oop/img/single-inheritance.png" alt="bg right fit" /></p>
<p>Syntax:</p>
<pre><code class="language-c++">class subclass_name : access_mode base_class
{
    // body of subclass
};
</code></pre>
<hr />
<h4 id="example-single-inheritance"><a class="header" href="#example-single-inheritance">Example: Single Inheritance</a></h4>
<p><img src="oop/img/single-inheritance.png" alt="bg right fit" /></p>
<pre><code class="language-c++">// C++ program to explain
// Single inheritance
#include &lt;iostream&gt;
using namespace std;

// base class
class Vehicle
{
public:
    Vehicle()
    {
        cout &lt;&lt; &quot;This is a Vehicle\n&quot;;
    }
};

// sub class derived from a single base classes
class Car : public Vehicle
{
};

// main function
int main()
{
    // Creating object of sub class will
    // invoke the constructor of base classes
    Car obj;
    return 0;
}
</code></pre>
<hr />
<h3 id="multiple-inheritance"><a class="header" href="#multiple-inheritance">Multiple Inheritance</a></h3>
<p><img src="oop/img/multiple-inheritance.png" alt="bg right fit" /></p>
<p>Syntax:</p>
<pre><code class="language-c++">class subclass_name : access_mode base_class1,
                      access_mode base_class2,
                      ....
{
    // body of subclass
};
</code></pre>
<hr />
<h4 id="example-multiple-inheritance"><a class="header" href="#example-multiple-inheritance">Example: Multiple Inheritance</a></h4>
<p><img src="oop/img/multiple-inheritance.png" alt="bg right fit" /></p>
<pre><code class="language-c++">// C++ program to explain
// multiple inheritance
#include &lt;iostream&gt;
using namespace std;

// first base class
class Vehicle
{
public:
    Vehicle()
    {
        cout &lt;&lt; &quot;This is a Vehicle\n&quot;;
    }
};

// second base class
class FourWheeler
{
public:
    FourWheeler()
    {
        cout &lt;&lt; &quot;This is a 4 wheeler Vehicle\n&quot;;
    }
};

// sub class derived from two base classes
class Car : public Vehicle, public FourWheeler
{
};

// main function
int main()
{
    // Creating object of sub class will
    // invoke the constructor of base classes.
    Car obj;
    return 0;
}
</code></pre>
<hr />
<h3 id="multi-level-inheritance"><a class="header" href="#multi-level-inheritance">Multi-level Inheritance</a></h3>
<p><img src="oop/img/multilevel-inheritance.png" alt="bg right fit" /></p>
<p>Syntax:</p>
<pre><code class="language-c++">class base_class_1 : access_mode base_class_2
{
    // body of base class 1
};
class subclass_name : access_mode base_class_1
{
    // body of subclass
};
</code></pre>
<hr />
<h4 id="example-multi-level-inheritance"><a class="header" href="#example-multi-level-inheritance">Example: Multi-level Inheritance</a></h4>
<p><img src="oop/img/multilevel-inheritance.png" alt="bg right fit" /></p>
<pre><code class="language-c++">// C++ program to implement
// Multilevel Inheritance
#include &lt;iostream&gt;
using namespace std;

// base class
class Vehicle
{
public:
    Vehicle()
    {
        cout &lt;&lt; &quot;This is a Vehicle\n&quot;;
    }
};

// first sub_class derived from class vehicle
class fourWheeler : public Vehicle
{
public:
    fourWheeler()
    {
        cout &lt;&lt; &quot;Objects with 4 wheels are vehicles\n&quot;;
    }
};
// sub class derived from the derived base class fourWheeler
class Car : public fourWheeler
{
public:
    Car()
    {
        cout &lt;&lt; &quot;Car has 4 Wheels\n&quot;;
    }
};

// main function
int main()
{
    // Creating object of sub class will
    // invoke the constructor of base classes.
    Car obj;
    return 0;
}
</code></pre>
<h2 id="example-1-integer--real-a-hrefooplecture8_ex1htmlsourcea"><a class="header" href="#example-1-integer--real-a-hrefooplecture8_ex1htmlsourcea">Example 1: Integer &amp; Real [<a href="oop/./lecture8_ex1.html">Source</a>]</a></h2>
<h2 id="example-2-complex-number-a-hrefooplecture8_ex2htmlsourcea"><a class="header" href="#example-2-complex-number-a-hrefooplecture8_ex2htmlsourcea">Example 2: Complex Number [<a href="oop/./lecture8_ex2.html">Source</a>]</a></h2>
<h2 id="example-3-integer--real--complex-number-a-hrefooplecture8_ex3htmlsourcea"><a class="header" href="#example-3-integer--real--complex-number-a-hrefooplecture8_ex3htmlsourcea">Example 3: Integer &amp; Real &amp; Complex Number [<a href="oop/./lecture8_ex3.html">Source</a>]</a></h2>
<h2 id="pratices-4"><a class="header" href="#pratices-4">Pratices</a></h2>
<ul>
<li>Design a class hierarchy for Fruit. Contains:
<ul>
<li>Grape</li>
<li>Apple</li>
<li>Orange</li>
</ul>
</li>
<li>Design a class hierarchy for Quadrilateral. Contains:
<ul>
<li>Square</li>
<li>Rectangle</li>
<li>Rhombus</li>
<li>Parallelogram</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-1-integer--real"><a class="header" href="#example-1-integer--real">Example 1: Integer &amp; Real</a></h1>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Integer
{
private:
    int m_int_value;

public:
    Integer(int arg_int_value)
    {
        m_int_value = arg_int_value;
    }
    int get_int_value()
    {
        return m_int_value;
    }
    void set_int_value(int arg_int_value)
    {
        m_int_value = arg_int_value;
    }
};

class Real : public Integer
{
private:
    double after_decimal;

public:
    Real(double arg_value) : Integer((int)arg_value),
                             after_decimal(arg_value - (int)arg_value)
    {
    }
    double get_real_value()
    {
        return after_decimal + get_int_value();
    }
    void set_real_value(double arg_value)
    {
        set_int_value((int)arg_value);
        after_decimal = arg_value - (int)arg_value;
    }
};

int main()
{
    Real r(3.14);
    cout &lt;&lt; r.get_int_value() &lt;&lt; endl;
    cout &lt;&lt; r.get_real_value() &lt;&lt; endl;
    r.set_real_value(3.1415);
    cout &lt;&lt; r.get_real_value() &lt;&lt; endl;
    r.set_int_value(4);
    cout &lt;&lt; r.get_real_value() &lt;&lt; endl;
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-2-complex-number"><a class="header" href="#example-2-complex-number">Example 2: Complex Number</a></h1>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Integer
{
private:
    int m_int_value;

public:
    Integer(int arg_int_value)
    {
        m_int_value = arg_int_value;
    }
    int get_int_value()
    {
        return m_int_value;
    }
    void set_int_value(int arg_int_value)
    {
        m_int_value = arg_int_value;
    }
};

class Real : public Integer
{
protected:
    double m_after_decimal;

public:
    Real(double arg_value) : Integer((int)arg_value),
                             m_after_decimal(arg_value - (int)arg_value)
    {
    }
    double get_real_value()
    {
        return m_after_decimal + get_int_value();
    }
    void set_real_value(double arg_value)
    {
        set_int_value((int)arg_value);
        m_after_decimal = arg_value - (int)arg_value;
    }
};

class Complex : protected Real
{
private:
    Real m_imaginary;

public:
    Complex(double arg_real_value,
            double arg_imaginary_value)
        : Real(arg_real_value),
          m_imaginary(arg_imaginary_value)
    {
    }
    double get_real_value()
    {
        return m_after_decimal + get_int_value();
    }
    double get_imaginary_value()
    {
        return m_imaginary.get_real_value();
    }
    void set_real_value(double arg_real_value)
    {
        Real::set_real_value(arg_real_value);
    }
    void set_imaginary_value(double arg_imaginary_value)
    {
        m_imaginary.set_real_value(arg_imaginary_value);
    }
};

int main()
{
    Complex c(1.5, 2.5);
    cout &lt;&lt; c.get_real_value() &lt;&lt; &quot; + &quot;
         &lt;&lt; c.get_imaginary_value() &lt;&lt; &quot;i&quot; &lt;&lt; endl;
    c.set_real_value(3.5);
    c.set_imaginary_value(4.5);
    cout &lt;&lt; c.get_real_value()
         &lt;&lt; &quot; + &quot; &lt;&lt; c.get_imaginary_value() &lt;&lt; &quot;i&quot; &lt;&lt; endl;
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-3-integer--real--complex-number"><a class="header" href="#example-3-integer--real--complex-number">Example 3: Integer &amp; Real &amp; Complex Number</a></h1>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Integer
{
private:
    int m_int_value;

public:
    Integer(int arg_int_value)
    {
        m_int_value = arg_int_value;
    }
    int get_int_value()
    {
        return m_int_value;
    }
    void set_int_value(int arg_int_value)
    {
        m_int_value = arg_int_value;
    }
};

class Real : public Integer
{
protected:
    double m_after_decimal;

public:
    Real(double arg_value) : Integer((int)arg_value),
                             m_after_decimal(arg_value - (int)arg_value)
    {
    }
    double get_real_value()
    {
        return m_after_decimal + get_int_value();
    }
    void set_real_value(double arg_value)
    {
        set_int_value((int)arg_value);
        m_after_decimal = arg_value - (int)arg_value;
    }
};

class Imaginary
{
protected:
    double m_imaginary_value;

public:
    Imaginary(double arg_imaginary_value)
    {
        m_imaginary_value = arg_imaginary_value;
    }
    double get_imaginary_value()
    {
        return m_imaginary_value;
    }
    void set_imaginary_value(double arg_imaginary_value)
    {
        m_imaginary_value = arg_imaginary_value;
    }
};

class Complex : public Real, public Imaginary
{
public:
    Complex(double arg_real_value,
            double arg_imaginary_value)
        : Real(arg_real_value),
          Imaginary(arg_imaginary_value)
    {
    }
    void print_complex_value()
    {
        cout &lt;&lt; get_real_value() &lt;&lt; &quot; + &quot; &lt;&lt; m_imaginary_value &lt;&lt; &quot;i&quot; &lt;&lt; endl;
    }
};

int main()
{
    Complex c(1.5, 2.5);
    c.print_complex_value();
    c.set_real_value(3.5);
    c.set_imaginary_value(4.5);
    c.print_complex_value();
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="midterm-project-big-positive-real-number-calculator"><a class="header" href="#midterm-project-big-positive-real-number-calculator">Midterm Project: Big Positive Real Number Calculator</a></h1>
<h2 id="midterm-1-big-positive-real-number-in-decimal-point-format-40"><a class="header" href="#midterm-1-big-positive-real-number-in-decimal-point-format-40">Midterm-1: Big Positive Real Number in Decimal Point Format (40%)</a></h2>
<ul>
<li>
<p>Inputs:</p>
<ol>
<li>Input a big positive real number in decimal point format, one line for one number.
<ol>
<li>digits before and after the decimal point are at most 9 digits, separated by a point character <code>.</code>.</li>
</ol>
</li>
<li>Input a operator, one line for one operator:
<ol>
<li><code>+</code>: add</li>
<li><code>*</code>: multiply</li>
</ol>
</li>
<li>The input is interleaved, one line for one number and one line for one operator after the number.</li>
<li>Input <kbd>Ctrl</kbd>+<kbd>D</kbd> to finish the input.
<ul>
<li>Windows: <kbd>Ctrl</kbd>+<kbd>Z</kbd> (will show <code>^Z</code> on the screen) then <kbd>Enter</kbd> (<code>⏎</code> in Format) to finish the input.</li>
</ul>
</li>
</ol>
</li>
<li>
<p>Outputs: </p>
<ol>
<li>The calculation result
<ol>
<li>The result is shown in decimal point format, with at most 18 digits before the decimal point, and 9 digits after the decimal point (<a href="https://en.wikipedia.org/wiki/Rounding#Round_half_toward_zero">rounding toward zero, truncate</a>).</li>
<li>The format please refer to the <a href="midterm-1.html#format">Format</a> section.</li>
</ol>
</li>
</ol>
</li>
<li>
<p>File name: <code>midterm-1_&lt;student_id&gt;.cpp</code> (e.g. <code>midterm-1_106062802.cpp</code>)</p>
</li>
<li>
<p>The program will not have any user prompts, only print the result.</p>
</li>
<li>
<p>The program does not need to handle invalid inputs.</p>
</li>
<li>
<p>The program should be finished within 10 seconds. Any test cases will garuntee the program is finished within 10 seconds.</p>
</li>
</ul>
<h2 id="format-7"><a class="header" href="#format-7">Format</a></h2>
<pre><code class="language-text">&lt;before dec 1&gt;.&lt;after dec 1&gt;⏎
&lt;op 1&gt;⏎
&lt;before dec 2&gt;.&lt;after dec 2&gt;⏎
&lt;op 2&gt;⏎
...
&lt;before dec n-1&gt;.&lt;after dec n-1&gt;⏎
&lt;op n-1&gt;⏎
&lt;before dec n&gt;.&lt;after dec n&gt;⏎
^Z⏎
&lt;before dec result&gt;.&lt;after dec result&gt;
</code></pre>
<h2 id="example-8"><a class="header" href="#example-8">Example</a></h2>
<pre><code class="language-console">$ ./a.out
1.0⏎
^Z⏎
1.000000000
$ ./a.out
0.2⏎
^Z⏎
0.200000000
$ ./a.out
1.0⏎
+⏎
2.0⏎
+
3.0⏎
*⏎
4.3⏎
^Z⏎
25.800000000
$ ./a.out
1.000000001⏎
+⏎
2.000000002⏎
^Z⏎
3.000000003
$ ./a.out
123456789.123456789⏎
+⏎
987654321.987654321⏎
^Z⏎
1111111111.111111110
$ ./a.out
1.000000001⏎
*⏎
2.000000002⏎
^Z⏎
2.000000004
$ ./a.out
123456789.123456789⏎
*⏎
987654321.987654321⏎
^Z⏎
121932631356500531.347203169
</code></pre>
<h2 id="reference"><a class="header" href="#reference">Reference</a></h2>
<ul>
<li><a href="https://www.calculator.net/big-number-calculator.html">Big Number Calculator</a></li>
</ul>
<h2 id="pseudo-code-7"><a class="header" href="#pseudo-code-7">Pseudo Code</a></h2>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;

using namespace std;

class BigReal
{
private:
    // data members
    // save the digits before and after the decimal point of a before_decimal number
    // with `long long` precision
    const long long m_dec_upperbound = 1000000000;
    long long m_before_decimal;
    long long m_after_decimal; // times 10^-9
    void _output_normalization();

public:
    // Constructor, initializes before_decimal and after_decimalinary parts
    // hint: as like as `modify` function in examples
    // but use default constructor to implement
    BigReal(const long long &amp;arg_before_decimal = 0.0,
            const long long &amp;arg_after_decimal = 0.0);
    // Copy constructor
    BigReal(const BigReal &amp;arg_big_real);
    // assignment operator
    BigReal &amp;operator=(const BigReal &amp;arg_big_real);
    // add assignment operator
    BigReal &amp;operator+=(const BigReal &amp;arg_big_real);
    // multiply assignment operator
    BigReal &amp;operator*=(const BigReal &amp;arg_big_real);
    // add function
    BigReal operator+(const BigReal &amp;arg_big_real) const;
    // multiply function
    BigReal operator*(const BigReal &amp;arg_big_real) const;
    // cout `&lt;&lt;` operator for print BigReal number
    // note: be careful about the format of output
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const BigReal &amp;arg_big_real);
    // cin `&gt;&gt;` operator for input BigReal number
    // note: be careful about the format of input
    // hint: use string `+=` to append digits
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, BigReal &amp;arg_big_real);
};

int main()
{
    string input;
    BigReal result_complex;
    char op = '=';

    while (getline(cin, input))
    {
        // input is a operation
        if (input == &quot;+&quot; || input == &quot;*&quot;)
        {
            op = input[0];
            continue;
        }
        else if (input.empty())
        {
            continue;
        }
        // input is a BigReal number
        else
        {
            stringstream ss(input);
            BigReal current_complex;
            ss &gt;&gt; current_complex;
            switch (op)
            {
            case '+':
                result_complex += current_complex;
                break;
            case '*':
                result_complex *= current_complex;
                break;
            case '=':
                result_complex = current_complex;
                break;
            default:
                cerr &lt;&lt; &quot;Error: unknown operation&quot; &lt;&lt; endl;
                return 1;
            }
        }
    }
    cout &lt;&lt; endl;
    cout &lt;&lt; result_complex &lt;&lt; endl;
    return 0;
}
</code></pre>
<h2 id="ta-version-code"><a class="header" href="#ta-version-code">TA Version Code</a></h2>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;

using namespace std;

class BigReal
{
private:
    // data members
    // save the digits before and after the decimal point of a before_decimal number
    // with `long long` precision
    const long long m_dec_upperbound = 1000000000;
    long long m_before_decimal;
    long long m_after_decimal; // times 10^-9
    void _output_normalization()
    {
        if (m_after_decimal &lt; 0)
        {
            m_before_decimal -= 1;
            m_after_decimal += m_dec_upperbound;
        }
        if (m_after_decimal &gt; m_dec_upperbound)
        {
            m_before_decimal += m_after_decimal / m_dec_upperbound;
            m_after_decimal = m_after_decimal % m_dec_upperbound;
        }
    }

public:
    // Constructor, initializes before_decimal and after_decimalinary parts
    // hint: as like as `modify` function in examples
    // but use default constructor to implement
    BigReal(const long long &amp;arg_before_decimal = 0.0,
            const long long &amp;arg_after_decimal = 0.0)
        : m_before_decimal(arg_before_decimal), m_after_decimal(arg_after_decimal)
    {
    }
    // Copy constructor
    BigReal(const BigReal &amp;arg_big_real)
        : m_before_decimal(arg_big_real.m_before_decimal),
          m_after_decimal(arg_big_real.m_after_decimal)
    {
    }
    // assignment operator
    BigReal &amp;operator=(const BigReal &amp;arg_big_real)
    {
        if (this == &amp;arg_big_real) // self-assignment
            return *this;
        m_before_decimal = arg_big_real.m_before_decimal;
        m_after_decimal = arg_big_real.m_after_decimal;
        return *this;
    }
    // add assignment operator
    BigReal &amp;operator+=(const BigReal &amp;arg_big_real)
    {
        m_before_decimal += arg_big_real.m_before_decimal;
        m_after_decimal += arg_big_real.m_after_decimal;
        _output_normalization();
        return *this;
    }
    // multiply assignment operator
    BigReal &amp;operator*=(const BigReal &amp;arg_big_real)
    {
        long long before_decimal = m_before_decimal * arg_big_real.m_before_decimal;
        long long after_decimal = m_after_decimal * arg_big_real.m_after_decimal / m_dec_upperbound;
        after_decimal += m_before_decimal * arg_big_real.m_after_decimal;
        after_decimal += m_after_decimal * arg_big_real.m_before_decimal;
        m_before_decimal = before_decimal;
        m_after_decimal = after_decimal;
        _output_normalization();
        return *this;
    }
    // add function
    BigReal operator+(const BigReal &amp;arg_big_real) const
    {
        BigReal c(*this);
        c += arg_big_real;
        return c;
    }
    // multiply function
    BigReal operator*(const BigReal &amp;arg_big_real) const
    {
        BigReal c(*this);
        c *= arg_big_real;
        return c;
    }
    // cout `&lt;&lt;` operator for print BigReal number
    // note: be careful about the format of output
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const BigReal &amp;arg_big_real)
    {
        arg_os &lt;&lt; arg_big_real.m_before_decimal &lt;&lt; '.'
               &lt;&lt; setfill('0') &lt;&lt; setw(9) &lt;&lt; arg_big_real.m_after_decimal;
        return arg_os;
    }
    // cin `&gt;&gt;` operator for input BigReal number
    // note: be careful about the format of input
    // hint: use string `+=` to append digits
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, BigReal &amp;arg_big_real)
    {
        string str_before_decimal, str_after_decimal;
        getline(arg_is, str_before_decimal, '.');
        getline(arg_is, str_after_decimal);
        str_after_decimal = str_after_decimal.substr(0, 9);
        for (int i = 0; i &lt; 9; i++)
            if (i &gt;= str_after_decimal.size())
                str_after_decimal += '0';
        arg_big_real.m_before_decimal = stoll(str_before_decimal);
        arg_big_real.m_after_decimal = stoll(str_after_decimal);
        return arg_is;
    }
};

int main()
{
    string input;
    BigReal result_complex;
    char op = '=';

    while (getline(cin, input))
    {
        // input is a operation
        if (input == &quot;+&quot; || input == &quot;*&quot;)
        {
            op = input[0];
            continue;
        }
        else if (input.empty())
        {
            continue;
        }
        // input is a BigReal number
        else
        {
            stringstream ss(input);
            BigReal current_complex;
            ss &gt;&gt; current_complex;
            switch (op)
            {
            case '+':
                result_complex += current_complex;
                break;
            case '*':
                result_complex *= current_complex;
                break;
            case '=':
                result_complex = current_complex;
                break;
            default:
                cerr &lt;&lt; &quot;Error: unknown operation&quot; &lt;&lt; endl;
                return 1;
            }
        }
    }
    cout &lt;&lt; endl;
    cout &lt;&lt; result_complex &lt;&lt; endl;
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="midterm-2-simple-big-positive-real-number-calculator-40"><a class="header" href="#midterm-2-simple-big-positive-real-number-calculator-40">Midterm-2: Simple Big Positive Real Number Calculator (40%)</a></h2>
<ul>
<li>
<p>Inputs:</p>
<ol>
<li>Input a big positive real number in decimal point format, one line for one number.
<ol>
<li>digits before and after the decimal point are at most 9 digits, separated by a point character <code>.</code>.</li>
</ol>
</li>
<li>Input a operator, one line for one operator:
<ol>
<li><code>+</code>: add</li>
<li><code>*</code>: multiply</li>
</ol>
</li>
<li>The input is interleaved, one line for one number and one line for one operator after the number.</li>
<li>Input <kbd>Ctrl</kbd>+<kbd>D</kbd> to finish the input.
<ul>
<li>Windows: <kbd>Ctrl</kbd>+<kbd>Z</kbd> (will show <code>^Z</code> on the screen) then <kbd>Enter</kbd> (<code>⏎</code> in Format) to finish the input.</li>
</ul>
</li>
</ol>
</li>
<li>
<p>Outputs: </p>
<ol>
<li>The calculation result
<ol>
<li>The result is shown in decimal point format, with at most 18 digits before the decimal point, and 9 digits after the decimal point (<a href="https://en.wikipedia.org/wiki/Rounding#Round_half_toward_zero">rounding toward zero, truncate</a>).</li>
<li>If the input is an operator, the program should print the current result in the following line. The format please refer to the <a href="midterm-2.html#example">Example</a> section.</li>
</ol>
</li>
</ol>
</li>
<li>
<p>File name: <code>midterm-2_&lt;student_id&gt;.cpp</code> (e.g. <code>midterm-2_106062802.cpp</code>)</p>
</li>
<li>
<p>The program will not have any user prompts, only print the result.</p>
</li>
<li>
<p>The program does not need to handle invalid inputs.</p>
</li>
<li>
<p>Please use <code>main</code> and <code>BigReal_Calc::set_input</code> that provided in the pseudo code to handle the input and output.</p>
</li>
<li>
<p>The program should be finished within 10 seconds. Any test cases will garuntee the program is finished within 10 seconds.</p>
</li>
</ul>
<h2 id="format-8"><a class="header" href="#format-8">Format</a></h2>
<pre><code class="language-text">&lt;before dec 1&gt;.&lt;after dec 1&gt;⏎
&lt;result 1&gt;
&lt;op 1&gt;⏎
&lt;result 1&gt;
&lt;before dec 2&gt;.&lt;after dec 2&gt;⏎
&lt;result 2&gt;
&lt;op 2&gt;⏎
&lt;result 2&gt;
...
&lt;before dec n-1&gt;.&lt;after dec n-1&gt;⏎
&lt;result n-1&gt;
&lt;op n-1&gt;⏎
&lt;result n-1&gt;
&lt;before dec n&gt;.&lt;after dec n&gt;⏎
&lt;result n&gt;
^Z⏎
</code></pre>
<h2 id="example-9"><a class="header" href="#example-9">Example</a></h2>
<pre><code class="language-console">$ ./a.out
1.0⏎
1.000000000
^Z⏎
$ ./a.out
0.2⏎
0.200000000
^Z⏎
$ ./a.out
1.0⏎
1.000000000
+⏎
1.000000000
2.0⏎
3.000000000
+⏎
3.000000000
3.0⏎
6.000000000
*⏎
6.000000000
4.3⏎
25.800000000
^Z⏎
$ ./a.out
1.000000001⏎
1.000000001
+⏎
1.000000001
2.000000002⏎
3.000000003
^Z⏎
$ ./a.out
123456789.123456789⏎
123456789.123456789
+⏎
123456789.123456789
987654321.987654321⏎
1111111111.111111110
^Z⏎
$ ./a.out
1.000000001⏎
1.000000001
*⏎
1.000000001
2.000000002⏎
2.000000004
^Z⏎
$ ./a.out
123456789.123456789⏎
123456789.123456789
*⏎
123456789.123456789
987654321.987654321⏎
121932631356500531.347203169
^Z⏎
</code></pre>
<h2 id="reference-1"><a class="header" href="#reference-1">Reference</a></h2>
<ul>
<li><a href="https://www.calculator.net/big-number-calculator.html">Big Number Calculator</a></li>
</ul>
<h2 id="pseudo-code-8"><a class="header" href="#pseudo-code-8">Pseudo Code</a></h2>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;cmath&gt;
#include &lt;iomanip&gt;

using namespace std;

class BigReal_Calc;

class BigReal
{
private:
    // data members
    // save the digits before and after the decimal point of a before_decimal number
    // with `long long` precision
    const long long m_dec_upperbound = 1000000000;
    long long m_before_decimal;
    long long m_after_decimal; // times 10^-9
    void _output_normalization();

public:
    // Constructor, initializes before_decimal and after_decimalinary parts
    // hint: as like as `modify` function in examples
    // but use default constructor to implement
    BigReal(const long long &amp;arg_before_decimal = 0.0,
            const long long &amp;arg_after_decimal = 0.0);
    // Copy constructor
    BigReal(const BigReal &amp;arg_big_real);
    // assignment operator
    BigReal &amp;operator=(const BigReal &amp;arg_big_real);
    // add assignment operator
    BigReal &amp;operator+=(const BigReal &amp;arg_big_real);
    // multiply assignment operator
    BigReal &amp;operator*=(const BigReal &amp;arg_big_real);
    // add function
    BigReal operator+(const BigReal &amp;arg_big_real) const;
    // multiply function
    BigReal operator*(const BigReal &amp;arg_big_real) const;
    // cout `&lt;&lt;` operator for print BigReal number
    // note: be careful about the format of output
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const BigReal &amp;arg_big_real);
    // cin `&gt;&gt;` operator for input BigReal number
    // note: be careful about the format of input
    // hint: use string `+=` to append digits
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, BigReal &amp;arg_big_real);
};

// BigReal calculator class declaration
class BigReal_Calc
{
private:
    // define current value
    BigReal m_curr_val;
    // define input value
    BigReal m_input_val;
    // define operation
    // `+`, `*`, and `=`
    char m_op;
    // calculate result
    void _calc_result();
    // operation functions
    // add the input value to the current value
    void _add();
    // subtract the input value from the current value
    void _mul();
    // divide the current value by the input value
    void _assign();

public:
    // Constructor
    BigReal_Calc();
    // Copy constructor
    BigReal_Calc(const BigReal_Calc &amp;arg_int_calc);

    // Destructor
    ~BigReal_Calc(){}; // no need to do anything

    // set input value or operation
    void set_input(const string &amp;arg_input);

    // cout `&lt;&lt;` operator for print calculator status
    // note: be careful about the format of output
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const BigReal_Calc &amp;arg_comp_calc);
};

// parse the test cases, do not modify belows

void BigReal_Calc::set_input(const string &amp;arg_input)
{
    // input is empty, read again
    if (arg_input.empty())
    {
        return;
    }
    // input is a operation
    else if (arg_input == &quot;+&quot; || arg_input == &quot;*&quot; || arg_input == &quot;=&quot;)
    {
        // set the activated operation
        // as the same as the user press the op button
        switch (arg_input[0])
        {
        case '+':
            _add();
            break;
        case '*':
            _mul();
            break;
        case '=':
            _assign();
            break;
        }
    }
    // input is a complex number
    // as the same as the user type a number
    // it performs as the same as the user pressed the '=' button
    // if the input is the first input
    // thus, we initialize the m_op to '='
    else
    {
        stringstream ss(arg_input);
        ss &gt;&gt; m_input_val;
        _calc_result();
    }
}

// main function

int main()
{
    // create an instance of the class
    BigReal_Calc calc;
    string input;
    while (getline(cin, input))
    {
        calc.set_input(input);
        cout &lt;&lt; calc &lt;&lt; endl;
    }
}
</code></pre>
<h2 id="ta-version-code-1"><a class="header" href="#ta-version-code-1">TA Version Code</a></h2>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;cmath&gt;
#include &lt;iomanip&gt;

using namespace std;

class BigReal_Calc;

class BigReal
{
private:
    // data members
    // save the digits before and after the decimal point of a before_decimal number
    // with `long long` precision
    const long long m_dec_upperbound = 1000000000;
    long long m_before_decimal;
    long long m_after_decimal; // times 10^-9
    void _output_normalization();

public:
    // Constructor, initializes before_decimal and after_decimalinary parts
    // hint: as like as `modify` function in examples
    // but use default constructor to implement
    BigReal(const long long &amp;arg_before_decimal = 0.0,
            const long long &amp;arg_after_decimal = 0.0);
    // Copy constructor
    BigReal(const BigReal &amp;arg_big_real);
    // assignment operator
    BigReal &amp;operator=(const BigReal &amp;arg_big_real);
    // add assignment operator
    BigReal &amp;operator+=(const BigReal &amp;arg_big_real);
    // multiply assignment operator
    BigReal &amp;operator*=(const BigReal &amp;arg_big_real);
    // add function
    BigReal operator+(const BigReal &amp;arg_big_real) const;
    // multiply function
    BigReal operator*(const BigReal &amp;arg_big_real) const;
    // cout `&lt;&lt;` operator for print BigReal number
    // note: be careful about the format of output
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const BigReal &amp;arg_big_real);
    // cin `&gt;&gt;` operator for input BigReal number
    // note: be careful about the format of input
    // hint: use string `+=` to append digits
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, BigReal &amp;arg_big_real);
};

// BigReal calculator class declaration
class BigReal_Calc
{
private:
    // define current value
    BigReal m_curr_val;
    // define input value
    BigReal m_input_val;
    // define operation
    // `+`, `*`, and `=`
    char m_op;
    // calculate result
    void _calc_result();
    // operation functions
    // add the input value to the current value
    void _add();
    // subtract the input value from the current value
    void _mul();
    // divide the current value by the input value
    void _assign();

public:
    // Constructor
    BigReal_Calc();
    // Copy constructor
    BigReal_Calc(const BigReal_Calc &amp;arg_int_calc);

    // Destructor
    ~BigReal_Calc(){}; // no need to do anything

    // set input value or operation
    void set_input(const string &amp;arg_input);

    // cout `&lt;&lt;` operator for print calculator status
    // note: be careful about the format of output
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const BigReal_Calc &amp;arg_comp_calc);
};

// BigReal class implementation

void BigReal::_output_normalization()
{
    if (m_after_decimal &lt; 0)
    {
        m_before_decimal -= 1;
        m_after_decimal += m_dec_upperbound;
    }
    if (m_after_decimal &gt; m_dec_upperbound)
    {
        m_before_decimal += m_after_decimal / m_dec_upperbound;
        m_after_decimal = m_after_decimal % m_dec_upperbound;
    }
}

// Constructor, initializes before_decimal and after_decimalinary parts
// hint: as like as `modify` function in examples
// but use default constructor to implement
BigReal::BigReal(const long long &amp;arg_before_decimal,
                 const long long &amp;arg_after_decimal)
    : m_before_decimal(arg_before_decimal), m_after_decimal(arg_after_decimal)
{
}
// Copy constructor
BigReal::BigReal(const BigReal &amp;arg_big_real)
    : m_before_decimal(arg_big_real.m_before_decimal),
      m_after_decimal(arg_big_real.m_after_decimal)
{
}
// assignment operator
BigReal &amp;BigReal::operator=(const BigReal &amp;arg_big_real)
{
    if (this == &amp;arg_big_real) // self-assignment
        return *this;
    m_before_decimal = arg_big_real.m_before_decimal;
    m_after_decimal = arg_big_real.m_after_decimal;
    return *this;
}
// add assignment operator
BigReal &amp;BigReal::operator+=(const BigReal &amp;arg_big_real)
{
    m_before_decimal += arg_big_real.m_before_decimal;
    m_after_decimal += arg_big_real.m_after_decimal;
    _output_normalization();
    return *this;
}
// multiply assignment operator
BigReal &amp;BigReal::operator*=(const BigReal &amp;arg_big_real)
{
    long long before_decimal = m_before_decimal * arg_big_real.m_before_decimal;
    long long after_decimal = m_after_decimal * arg_big_real.m_after_decimal / m_dec_upperbound;
    after_decimal += m_before_decimal * arg_big_real.m_after_decimal;
    after_decimal += m_after_decimal * arg_big_real.m_before_decimal;
    m_before_decimal = before_decimal;
    m_after_decimal = after_decimal;
    _output_normalization();
    return *this;
}
// add function
BigReal BigReal::operator+(const BigReal &amp;arg_big_real) const
{
    BigReal c(*this);
    c += arg_big_real;
    return c;
}
// multiply function
BigReal BigReal::operator*(const BigReal &amp;arg_big_real) const
{
    BigReal c(*this);
    c *= arg_big_real;
    return c;
}
// cout `&lt;&lt;` operator for print BigReal number
// note: be careful about the format of output
ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const BigReal &amp;arg_big_real)
{
    arg_os &lt;&lt; arg_big_real.m_before_decimal &lt;&lt; '.'
           &lt;&lt; setfill('0') &lt;&lt; setw(9) &lt;&lt; arg_big_real.m_after_decimal;
    return arg_os;
}
// cin `&gt;&gt;` operator for input BigReal number
// note: be careful about the format of input
// hint: use string `+=` to append digits
istream &amp;operator&gt;&gt;(istream &amp;arg_is, BigReal &amp;arg_big_real)
{
    string str_before_decimal, str_after_decimal;
    getline(arg_is, str_before_decimal, '.');
    getline(arg_is, str_after_decimal);
    str_after_decimal = str_after_decimal.substr(0, 9);
    for (int i = 0; i &lt; 9; i++)
        if (i &gt;= str_after_decimal.size())
            str_after_decimal += '0';
    stringstream ss_before_decimal(str_before_decimal);
    ss_before_decimal &gt;&gt; arg_big_real.m_before_decimal;
    stringstream ss_after_decimal(str_after_decimal);
    ss_after_decimal &gt;&gt; arg_big_real.m_after_decimal;
    return arg_is;
}

// BigReal_Calc class implementation

// Constructor
BigReal_Calc::BigReal_Calc()
    : m_curr_val(), m_input_val(), m_op('=')
{
}

// Copy constructor
BigReal_Calc::BigReal_Calc(const BigReal_Calc &amp;arg_int_calc)
    : m_curr_val(arg_int_calc.m_curr_val),
      m_input_val(arg_int_calc.m_input_val),
      m_op(arg_int_calc.m_op)
{
}

// calculate the result
void BigReal_Calc::_calc_result()
{
    switch (m_op)
    {
    case '+':
        m_curr_val += m_input_val;
        break;
    case '*':
        m_curr_val *= m_input_val;
        break;
    case '=':
        m_curr_val = m_input_val;
        break;
    default:
        break;
    }
}

// add the input value to the current value
void BigReal_Calc::_add()
{
    m_op = '+';
}

// multiply the input value with the current value
void BigReal_Calc::_mul()
{
    m_op = '*';
}

// assign the input value to the current value
void BigReal_Calc::_assign()
{
    m_op = '=';
}

// cout `&lt;&lt;` operator for print calculator status
ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const BigReal_Calc &amp;arg_comp_calc)
{
    arg_os &lt;&lt; arg_comp_calc.m_curr_val;
    return arg_os;
}

// parse the test cases, do not modify belows

void BigReal_Calc::set_input(const string &amp;arg_input)
{
    // input is empty, read again
    if (arg_input.empty())
    {
        return;
    }
    // input is a operation
    else if (arg_input == &quot;+&quot; || arg_input == &quot;*&quot; || arg_input == &quot;=&quot;)
    {
        // set the activated operation
        // as the same as the user press the op button
        switch (arg_input[0])
        {
        case '+':
            _add();
            break;
        case '*':
            _mul();
            break;
        case '=':
            _assign();
            break;
        }
    }
    // input is a complex number
    // as the same as the user type a number
    // it performs as the same as the user pressed the '=' button
    // if the input is the first input
    // thus, we initialize the m_op to '='
    else
    {
        stringstream ss(arg_input);
        ss &gt;&gt; m_input_val;
        _calc_result();
    }
}

// main function

int main()
{
    // create an instance of the class
    BigReal_Calc calc;
    string input;
    while (getline(cin, input))
    {
        calc.set_input(input);
        cout &lt;&lt; calc &lt;&lt; endl;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="midterm-3-enhanced-big-positive-real-number-calculator-20"><a class="header" href="#midterm-3-enhanced-big-positive-real-number-calculator-20">Midterm-3: Enhanced Big Positive Real Number Calculator (20%)</a></h2>
<ul>
<li>
<p>Inputs:</p>
<ol>
<li>Input a big positive real number in decimal point format, one line for one number.
<ol>
<li>digits before and after the decimal point are at most 9 digits, separated by a point character <code>.</code>.</li>
</ol>
</li>
<li>Input a operator, one line for one operator:
<ol>
<li><code>+</code>: add</li>
<li><code>*</code>: multiply</li>
</ol>
</li>
<li>The input is interleaved, one line for one number and one line for one operator after the number.</li>
<li>Input <kbd>Ctrl</kbd>+<kbd>D</kbd> to finish the input.
<ul>
<li>Windows: <kbd>Ctrl</kbd>+<kbd>Z</kbd> (will show <code>^Z</code> on the screen) then <kbd>Enter</kbd> (<code>⏎</code> in Format) to finish the input.</li>
</ul>
</li>
<li>The input is any valid <code>string</code> type.</li>
</ol>
</li>
<li>
<p>Outputs: </p>
<ol>
<li>The calculation result
<ol>
<li>The result is shown in decimal point format, with at most 18 digits before the decimal point, and 9 digits after the decimal point (<a href="https://en.wikipedia.org/wiki/Rounding#Round_half_toward_zero">rounding toward zero, truncate</a>).</li>
<li>If the input is an operator, the program should print the current result in the following line. The format please refer to the <a href="midterm-3.html#example">Example</a> section.</li>
<li>If the input operand or operator is invalid, the program should print the error message <code>Error: Invalid input</code> and terminate the program.</li>
</ol>
</li>
</ol>
</li>
<li>
<p>File name: <code>midterm-3_&lt;student_id&gt;.cpp</code> (e.g. <code>midterm-3_106062802.cpp</code>)</p>
</li>
<li>
<p>The program will not have any user prompts, only print the result.</p>
</li>
<li>
<p>The program only need to handle invalid inputs, i.e., invalid operand or operator. Other errors will be ingored.</p>
</li>
<li>
<p>Please based on <code>main</code> and <code>BigReal_Calc::set_input</code> that provided in the pseudo code to handle the input and output.</p>
</li>
<li>
<p>The program should be finished within 10 seconds. Any test cases will garuntee the program is finished within 10 seconds.</p>
</li>
</ul>
<h2 id="format-9"><a class="header" href="#format-9">Format</a></h2>
<pre><code class="language-text">&lt;before dec 1&gt;.&lt;after dec 1&gt;⏎
&lt;result 1&gt;
&lt;op 1&gt;⏎
&lt;result 1&gt;
&lt;before dec 2&gt;.&lt;after dec 2&gt;⏎
&lt;result 2&gt;
&lt;op 2&gt;⏎
&lt;result 2&gt;
...
&lt;before dec n-1&gt;.&lt;after dec n-1&gt;⏎
&lt;result n-1&gt;
&lt;op n-1&gt;⏎
&lt;result n-1&gt;
&lt;before dec n&gt;.&lt;after dec n&gt;⏎
&lt;result n&gt;
^Z⏎
</code></pre>
<h2 id="example-10"><a class="header" href="#example-10">Example</a></h2>
<h3 id="normal-2"><a class="header" href="#normal-2">Normal</a></h3>
<pre><code class="language-console">$ ./a.out
1.0⏎
1.000000000
^Z⏎
$ ./a.out
0.2⏎
0.200000000
^Z⏎
$ ./a.out
000000000.000000000⏎
0.000000000
^Z⏎
$ ./a.out
1.0⏎
1.000000000
+⏎
1.000000000
2.0⏎
3.000000000
+⏎
3.000000000
3.0⏎
6.000000000
*⏎
6.000000000
4.3⏎
25.800000000
^Z⏎
$ ./a.out
1.000000001⏎
1.000000001
+⏎
1.000000001
2.000000002⏎
3.000000003
^Z⏎
$ ./a.out
123456789.123456789⏎
123456789.123456789
+⏎
123456789.123456789
987654321.987654321⏎
1111111111.111111110
^Z⏎
$ ./a.out
1.000000001⏎
1.000000001
*⏎
1.000000001
2.000000002⏎
2.000000004
^Z⏎
$ ./a.out
123456789.123456789⏎
123456789.123456789
*⏎
123456789.123456789
987654321.987654321⏎
121932631356500531.347203169
^Z⏎
</code></pre>
<h3 id="exception-handling-2"><a class="header" href="#exception-handling-2">Exception Handling</a></h3>
<pre><code class="language-console">$ ./a.out
+⏎
Error: Invalid input
$
$ ./a.out
1.0⏎
1.000000000
1.0⏎
Error: Invalid input
$
$ ./a.out
1.0⏎
1.000000000
+⏎
1.000000000
+⏎
Error: Invalid input
$
$ ./a.out
1.0 2.0⏎
Error: Invalid input
$
$ ./a.out
1234567890.0⏎
Error: Invalid input
$
$ ./a.out
0000000000.0⏎
Error: Invalid input
$
$ ./a.out
123456789.1234567890⏎
Error: Invalid input
$
$ ./a.out
 123456789.0⏎
Error: Invalid input
$
$ ./a.out
1.0⏎
1.000000000
sdafsdagret⏎
Error: Invalid input
$
$ ./a.out
sdoifjwepoirjpwoie⏎
Error: Invalid input
$
$ ./a.out
1.⏎
Error: Invalid input
$
$ ./a.out
.90⏎
Error: Invalid input
$
</code></pre>
<h2 id="reference-2"><a class="header" href="#reference-2">Reference</a></h2>
<ul>
<li><a href="https://www.calculator.net/big-number-calculator.html">Big Number Calculator</a></li>
</ul>
<h2 id="pseudo-code-9"><a class="header" href="#pseudo-code-9">Pseudo Code</a></h2>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;cmath&gt;
#include &lt;iomanip&gt;
#include &lt;cctype&gt;

using namespace std;

class BigReal_Calc;

class BigReal
{
private:
    // data members
    // save the digits before and after the decimal point of a before_decimal number
    // with `long long` precision
    const long long m_dec_upperbound = 1000000000;
    long long m_before_decimal;
    long long m_after_decimal; // times 10^-9
    void _output_normalization();

public:
    // Constructor, initializes before_decimal and after_decimalinary parts
    // hint: as like as `modify` function in examples
    // but use default constructor to implement
    BigReal(const long long &amp;arg_before_decimal = 0.0,
            const long long &amp;arg_after_decimal = 0.0);
    // Copy constructor
    BigReal(const BigReal &amp;arg_big_real);
    // assignment operator
    BigReal &amp;operator=(const BigReal &amp;arg_big_real);
    // add assignment operator
    BigReal &amp;operator+=(const BigReal &amp;arg_big_real);
    // multiply assignment operator
    BigReal &amp;operator*=(const BigReal &amp;arg_big_real);
    // add function
    BigReal operator+(const BigReal &amp;arg_big_real) const;
    // multiply function
    BigReal operator*(const BigReal &amp;arg_big_real) const;
    // cout `&lt;&lt;` operator for print BigReal number
    // note: be careful about the format of output
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const BigReal &amp;arg_big_real);
    // cin `&gt;&gt;` operator for input BigReal number
    // note: be careful about the format of input
    // hint: use string `+=` to append digits
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, BigReal &amp;arg_big_real);
};

// BigReal calculator class declaration
class BigReal_Calc
{
private:
    // define current value
    BigReal m_curr_val;
    // define input value
    BigReal m_input_val;
    // define operation
    // `+`, `*`, and `=`
    char m_op;
    // define input status, truns `op` for true and turns `value` for false
    bool m_op_input;
    // calculate result
    void _calc_result();
    // operation functions
    // set activation op to add
    void _add();
    // set activation op to subtract
    void _mul();
    // set activation op to divide
    void _assign();

public:
    // Constructor
    BigReal_Calc();
    // Copy constructor
    BigReal_Calc(const BigReal_Calc &amp;arg_int_calc);

    // Destructor
    ~BigReal_Calc(){}; // no need to do anything

    // set input value or operation
    // as the same as the user input number or operation
    // into the calculator
    void set_input(const string &amp;arg_input);

    // cout `&lt;&lt;` operator for print calculator status
    // note: be careful about the format of output
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const BigReal_Calc &amp;arg_comp_calc);
};

// error and exit
void error_and_exit()
{
    cerr &lt;&lt; &quot;Error: Invalid input&quot; &lt;&lt; endl;
    exit(1);
}

void BigReal_Calc::set_input(const string &amp;arg_input)
{
    if (arg_input.empty())
    {
        return;
    }
    // input is a operation
    else if ()
    {
        // set the activated operation
        // as the same as the user press the op button
        switch (arg_input[0])
        {
        case '+':
            _add();
            break;
        case '*':
            _mul();
            break;
        case '=':
            _assign();
            break;
        }
        // set to 'input a complex number' turn
        
    }
    // input is a complex number
    // as the same as the user type a number
    // it performs as the same as the user pressed the '=' button
    // if the input is the first input
    // thus, we initialize the m_op to '='
    else if ()
    {
        stringstream ss(arg_input);
        ss &gt;&gt; m_input_val;
        _calc_result();
        // set to 'input a op' turn
        
    }
    else
    {
        error_and_exit();
    }
}

// main function

int main()
{
    // create an instance of the class
    BigReal_Calc calc;
    string input;
    while (getline(cin, input))
    {
        calc.set_input(input);
        cout &lt;&lt; calc &lt;&lt; endl;
    }
}
</code></pre>
<h2 id="ta-version-code-2"><a class="header" href="#ta-version-code-2">TA Version Code</a></h2>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;cmath&gt;
#include &lt;iomanip&gt;
#include &lt;cctype&gt;

using namespace std;

class BigReal_Calc;

class BigReal
{
private:
    // data members
    // save the digits before and after the decimal point of a before_decimal number
    // with `long long` precision
    const long long m_dec_upperbound = 1000000000;
    long long m_before_decimal;
    long long m_after_decimal; // times 10^-9
    void _output_normalization();

public:
    // Constructor, initializes before_decimal and after_decimalinary parts
    // hint: as like as `modify` function in examples
    // but use default constructor to implement
    BigReal(const long long &amp;arg_before_decimal = 0.0,
            const long long &amp;arg_after_decimal = 0.0);
    // Copy constructor
    BigReal(const BigReal &amp;arg_big_real);
    // assignment operator
    BigReal &amp;operator=(const BigReal &amp;arg_big_real);
    // add assignment operator
    BigReal &amp;operator+=(const BigReal &amp;arg_big_real);
    // multiply assignment operator
    BigReal &amp;operator*=(const BigReal &amp;arg_big_real);
    // add function
    BigReal operator+(const BigReal &amp;arg_big_real) const;
    // multiply function
    BigReal operator*(const BigReal &amp;arg_big_real) const;
    // cout `&lt;&lt;` operator for print BigReal number
    // note: be careful about the format of output
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const BigReal &amp;arg_big_real);
    // cin `&gt;&gt;` operator for input BigReal number
    // note: be careful about the format of input
    // hint: use string `+=` to append digits
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, BigReal &amp;arg_big_real);
};

// BigReal calculator class declaration
class BigReal_Calc
{
private:
    // define current value
    BigReal m_curr_val;
    // define input value
    BigReal m_input_val;
    // define operation
    // `+`, `*`, and `=`
    char m_op;
    // define input status, truns `op` for true and turns `value` for false
    bool m_op_input;
    // calculate result
    void _calc_result();
    // operation functions
    // set activation op to add
    void _add();
    // set activation op to subtract
    void _mul();
    // set activation op to divide
    void _assign();

public:
    // Constructor
    BigReal_Calc();
    // Copy constructor
    BigReal_Calc(const BigReal_Calc &amp;arg_int_calc);

    // Destructor
    ~BigReal_Calc(){}; // no need to do anything

    // set input value or operation
    // as the same as the user input number or operation
    // into the calculator
    void set_input(const string &amp;arg_input);

    // cout `&lt;&lt;` operator for print calculator status
    // note: be careful about the format of output
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const BigReal_Calc &amp;arg_comp_calc);
};

// error and exit
void error_and_exit()
{
    cerr &lt;&lt; &quot;Error: Invalid input&quot; &lt;&lt; endl;
    exit(1);
}

// BigReal class implementation

void BigReal::_output_normalization()
{
    if (m_after_decimal &lt; 0)
    {
        m_before_decimal -= 1;
        m_after_decimal += m_dec_upperbound;
    }
    if (m_after_decimal &gt; m_dec_upperbound)
    {
        m_before_decimal += m_after_decimal / m_dec_upperbound;
        m_after_decimal = m_after_decimal % m_dec_upperbound;
    }
}

// Constructor, initializes before_decimal and after_decimalinary parts
// hint: as like as `modify` function in examples
// but use default constructor to implement
BigReal::BigReal(const long long &amp;arg_before_decimal,
                 const long long &amp;arg_after_decimal)
    : m_before_decimal(arg_before_decimal), m_after_decimal(arg_after_decimal)
{
}
// Copy constructor
BigReal::BigReal(const BigReal &amp;arg_big_real)
    : m_before_decimal(arg_big_real.m_before_decimal),
      m_after_decimal(arg_big_real.m_after_decimal)
{
}
// assignment operator
BigReal &amp;BigReal::operator=(const BigReal &amp;arg_big_real)
{
    if (this == &amp;arg_big_real) // self-assignment
        return *this;
    m_before_decimal = arg_big_real.m_before_decimal;
    m_after_decimal = arg_big_real.m_after_decimal;
    return *this;
}
// add assignment operator
BigReal &amp;BigReal::operator+=(const BigReal &amp;arg_big_real)
{
    m_before_decimal += arg_big_real.m_before_decimal;
    m_after_decimal += arg_big_real.m_after_decimal;
    _output_normalization();
    return *this;
}
// multiply assignment operator
BigReal &amp;BigReal::operator*=(const BigReal &amp;arg_big_real)
{
    long long before_decimal = m_before_decimal * arg_big_real.m_before_decimal;
    long long after_decimal = m_after_decimal * arg_big_real.m_after_decimal / m_dec_upperbound;
    after_decimal += m_before_decimal * arg_big_real.m_after_decimal;
    after_decimal += m_after_decimal * arg_big_real.m_before_decimal;
    m_before_decimal = before_decimal;
    m_after_decimal = after_decimal;
    _output_normalization();
    return *this;
}
// add function
BigReal BigReal::operator+(const BigReal &amp;arg_big_real) const
{
    BigReal c(*this);
    c += arg_big_real;
    return c;
}
// multiply function
BigReal BigReal::operator*(const BigReal &amp;arg_big_real) const
{
    BigReal c(*this);
    c *= arg_big_real;
    return c;
}
// cout `&lt;&lt;` operator for print BigReal number
// note: be careful about the format of output
ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const BigReal &amp;arg_big_real)
{
    arg_os &lt;&lt; arg_big_real.m_before_decimal &lt;&lt; '.'
           &lt;&lt; setfill('0') &lt;&lt; setw(9) &lt;&lt; arg_big_real.m_after_decimal;
    return arg_os;
}
// cin `&gt;&gt;` operator for input BigReal number
// note: be careful about the format of input
// hint: use string `+=` to append digits
istream &amp;operator&gt;&gt;(istream &amp;arg_is, BigReal &amp;arg_big_real)
{
    string str_before_decimal, str_after_decimal;
    getline(arg_is, str_before_decimal, '.');
    if (str_before_decimal.empty() || str_before_decimal.size() &gt; 9)
    {
        error_and_exit();
    }
    getline(arg_is, str_after_decimal);
    if (str_after_decimal.empty() || str_after_decimal.size() &gt; 9 || !arg_is.eof())
    {
        error_and_exit();
    }
    for (int i = 0; i &lt; 9; i++)
    {
        if (i &gt;= str_after_decimal.size())
        {
            str_after_decimal += '0';
        }
        else if (!isdigit(str_after_decimal[i]))
        {
            error_and_exit();
        }
    }
    stringstream ss_before_decimal(str_before_decimal);
    ss_before_decimal &gt;&gt; arg_big_real.m_before_decimal;
    if (ss_before_decimal.fail())
    {
        error_and_exit();
    }
    stringstream ss_after_decimal(str_after_decimal);
    ss_after_decimal &gt;&gt; arg_big_real.m_after_decimal;
    if (ss_after_decimal.fail())
    {
        error_and_exit();
    }
    return arg_is;
}

// BigReal_Calc class implementation

// Constructor
BigReal_Calc::BigReal_Calc()
    : m_curr_val(), m_input_val(), m_op('='), m_op_input(false)
{
}

// Copy constructor
BigReal_Calc::BigReal_Calc(const BigReal_Calc &amp;arg_int_calc)
    : m_curr_val(arg_int_calc.m_curr_val),
      m_input_val(arg_int_calc.m_input_val),
      m_op(arg_int_calc.m_op),
      m_op_input(arg_int_calc.m_op_input)
{
}

// calculate the result
void BigReal_Calc::_calc_result()
{
    switch (m_op)
    {
    case '+':
        m_curr_val += m_input_val;
        break;
    case '*':
        m_curr_val *= m_input_val;
        break;
    case '=':
        m_curr_val = m_input_val;
        break;
    default:
        error_and_exit();
    }
}

// set activation op to add
void BigReal_Calc::_add()
{
    m_op = '+';
}

// set activation op to multiply
void BigReal_Calc::_mul()
{
    m_op = '*';
}

// set activation op to assign
void BigReal_Calc::_assign()
{
    m_op = '=';
}

// cout `&lt;&lt;` operator for print calculator status
ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const BigReal_Calc &amp;arg_comp_calc)
{
    arg_os &lt;&lt; arg_comp_calc.m_curr_val;
    return arg_os;
}

void BigReal_Calc::set_input(const string &amp;arg_input)
{
    if (arg_input.empty())
    {
        return;
    }
    // input is a operation
    else if (m_op_input &amp;&amp; (arg_input == &quot;+&quot; || arg_input == &quot;*&quot; || arg_input == &quot;=&quot;))
    {
        // set the activated operation
        // as the same as the user press the op button
        switch (arg_input[0])
        {
        case '+':
            _add();
            break;
        case '*':
            _mul();
            break;
        case '=':
            _assign();
            break;
        }
        // set to 'input a complex number' turn
        m_op_input = false;
    }
    // input is a complex number
    // as the same as the user type a number
    // it performs as the same as the user pressed the '=' button
    // if the input is the first input
    // thus, we initialize the m_op to '='
    else if (!m_op_input)
    {
        stringstream ss(arg_input);
        ss &gt;&gt; m_input_val;
        _calc_result();
        // set to 'input a op' turn
        m_op_input = true;
    }
    else
    {
        error_and_exit();
    }
}

// main function

int main()
{
    // create an instance of the class
    BigReal_Calc calc;
    string input;
    while (getline(cin, input))
    {
        calc.set_input(input);
        cout &lt;&lt; calc &lt;&lt; endl;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!---
marp: true
author: Yi-Wen Hung
theme: default
headingDivider: 2
paginate: true
--->
<h1 id="oop-inheritance-2"><a class="header" href="#oop-inheritance-2">OOP: Inheritance (2)</a></h1>
<blockquote>
<p>Slides version: <a href="oop/./lecture10_slides.html">lecture10_slides.html</a>
Website version: <a href="oop/./lecture10.html">lecture10.html</a></p>
</blockquote>
<ul>
<li>Recap Inheritance
<ul>
<li>Example: Bus, Car, and Truck</li>
<li>Inheritance Mode
<ul>
<li>Friend function &amp; Inheritance (public, protected, private)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Inheritance Type
<ul>
<li>Single, Multiple, Multi-level (discuss in the previous lecture)</li>
<li>Hierarchical</li>
<li>Hybrid</li>
<li>Multipath inheritance</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>Inheritance in Software Engineering
<ul>
<li>Reusable &amp; Efficient</li>
<li>Is a (Inheritance) &amp; Has a (Composition)</li>
</ul>
</li>
<li>Example 1: Integer &amp; Real &amp; Complex Number Calculator</li>
<li>Example 2: Complex Number &amp; Triangle</li>
<li>Example 3: Complex Number &amp; Triangles</li>
</ul>
<h2 id="recap-inheritance"><a class="header" href="#recap-inheritance">Recap Inheritance</a></h2>
<p>Ref: <a href="https://www.geeksforgeeks.org/inheritance-in-c/">Inheritance in C++</a></p>
<h3 id="example-bus-car-and-truck-2"><a class="header" href="#example-bus-car-and-truck-2">Example: Bus, Car, and Truck.</a></h3>
<p><img src="oop/./img/inheritance.png" alt="" /></p>
<hr />
<p>Because bus, car and truck are all vehicles, and they all have the same member functions, we can use inheritance to reduce the amount of code we need to write. For example, <code>class Vehicle</code>:</p>
<p><img src="oop/./img/inheritance2.png" alt="" /></p>
<hr />
<h3 id="example-bus-car-and-truck-3"><a class="header" href="#example-bus-car-and-truck-3">Example: Bus, Car, and Truck.</a></h3>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Vehicle
{
public:
    void run()
    {
        std::cout &lt;&lt; &quot;Vehicle is running&quot; &lt;&lt; std::endl;
    }
};
class Bus : public Vehicle
{
};
class Car : public Vehicle
{
};
</code></pre>
<hr />
<pre><code class="language-c++">class Truck : public Vehicle
{
};
int main()
{
    Bus bus;
    Car car;
    Truck truck;
    bus.run();
    car.run();
    truck.run();
    return 0;
}
</code></pre>
<p>Output:</p>
<pre><code class="language-console">$ ./a.out
Vehicle is running
Vehicle is running
Vehicle is running
</code></pre>
<hr />
<h3 id="inheritance-mode-1"><a class="header" href="#inheritance-mode-1">Inheritance Mode</a></h3>
<table><thead><tr><th align="center">Class Member Type</th><th align="center">Type of</th><th align="center">Inheritence</th><th align="center"></th></tr></thead><tbody>
<tr><td align="center"></td><td align="center">Public</td><td align="center">Protected</td><td align="center">Private</td></tr>
<tr><td align="center">Public</td><td align="center"><strong>Public</strong></td><td align="center"><strong>Protected</strong></td><td align="center"><strong>Private</strong></td></tr>
<tr><td align="center">Protected</td><td align="center"><strong>Protected</strong></td><td align="center"><strong>Protected</strong></td><td align="center"><strong>Private</strong></td></tr>
<tr><td align="center">Private</td><td align="center"><strong>Not accessible</strong></td><td align="center"><strong>Not accessible</strong></td><td align="center"><strong>Not accessible</strong></td></tr>
</tbody></table>
<hr />
<h3 id="friend-function--inheritance"><a class="header" href="#friend-function--inheritance">Friend function &amp; Inheritance</a></h3>
<pre><code class="language-c++">class A
{
public:
    int x;
    friend void f_x(A &amp;a)
    {
        a.x = 1;
    }

protected:
    int y;
    friend void f_y(A &amp;a)
    {
        a.y = 2;
    }

private:
    int z;
    friend void f_z(A &amp;a)
    {
        a.z = 3;
    }
};
</code></pre>
<hr />
<pre><code class="language-c++">class B : public A
{
    // x is public
    // y is protected
    // z is not accessible from B
};

class C : protected A
{
    // x is protected
    // y is protected
    // z is not accessible from C
};

class D : private A // 'private' is default for classes
{
    // x is private
    // y is private
    // z is not accessible from D
};
</code></pre>
<hr />
<pre><code class="language-c++">int main()
{
    A a;
    B b;
    C c;
    D d;

    f_x(a);
    f_y(a);
    f_z(a);

    f_x(b);
    f_y(b);
    f_z(b);

    f_x(c); // error: not accessible
    f_y(c); // error: not accessible
    f_z(c); // error: not accessible

    f_x(d); // error: not accessible
    f_y(d); // error: not accessible
    f_z(d); // error: not accessible

    return 0;
}
</code></pre>
<h2 id="inheritance-type-1"><a class="header" href="#inheritance-type-1">Inheritance Type</a></h2>
<ul>
<li>Single (discuss in the previous lecture)</li>
<li>Multiple (discuss in the previous lecture)</li>
<li>Multi-level (discuss in the previous lecture)</li>
<li>Hierarchical </li>
<li>Hybrid (Virtual) Inheritance </li>
<li>Multipath inheritance </li>
</ul>
<hr />
<h3 id="hierarchical-inheritance"><a class="header" href="#hierarchical-inheritance">Hierarchical Inheritance</a></h3>
<p><img src="oop/img/hierarchical-inheritance.png" alt="bg right fit" /></p>
<pre><code class="language-c++">// C++ program to implement
// Hierarchical Inheritance
#include &lt;iostream&gt;
using namespace std;

// base class
class Vehicle
{
public:
    Vehicle()
    {
        cout &lt;&lt; &quot;This is a Vehicle\n&quot;;
    }
};

// first sub class
class Car : public Vehicle
{
};

// second sub class
class Bus : public Vehicle
{
};

// main function
int main()
{
    // Creating object of sub class will
    // invoke the constructor of base class.
    Car obj1;
    Bus obj2;
    return 0;
}
</code></pre>
<hr />
<h3 id="hybrid-virtual-inheritance"><a class="header" href="#hybrid-virtual-inheritance">Hybrid (Virtual) Inheritance</a></h3>
<p><img src="oop/img/Hybrid-Inheritance.png" alt="bg right fit" /></p>
<pre><code class="language-c++">// C++ program to explain
// multiple inheritance
#include &lt;iostream&gt;
using namespace std;

// first base class
class Vehicle
{
public:
    Vehicle()
    {
        cout &lt;&lt; &quot;This is a Vehicle\n&quot;;
    }
};

// second base class
class FourWheeler
{
public:
    FourWheeler()
    {
        cout &lt;&lt; &quot;This is a 4 wheeler Vehicle\n&quot;;
    }
};

// sub class derived from two base classes
class Car : public Vehicle, public FourWheeler
{
};

// main function
int main()
{
    // Creating object of sub class will
    // invoke the constructor of base classes.
    Car obj;
    return 0;
}
</code></pre>
<hr />
<h3 id="multipath-inheritance"><a class="header" href="#multipath-inheritance">Multipath inheritance</a></h3>
<p><img src="oop/img/multipath-Inheritance.png" alt="bg right fit" /></p>
<pre><code class="language-c++">#include &lt;iostream&gt;

class ClassA
{
public:
    int a;
};

class ClassB : virtual public ClassA
{
public:
    int b;
};

class ClassC : virtual public ClassA
{
public:
    int c;
};

class ClassD : public ClassB, public ClassC
{
public:
    int d;
};

int main()
{
    ClassD obj;

    obj.a = 10;  // Statement 3
    obj.a = 100; // Statement 4

    obj.b = 20;
    obj.c = 30;
    obj.d = 40;

    cout &lt;&lt; &quot;\n a : &quot; &lt;&lt; obj.a;
    cout &lt;&lt; &quot;\n b : &quot; &lt;&lt; obj.b;
    cout &lt;&lt; &quot;\n c : &quot; &lt;&lt; obj.c;
    cout &lt;&lt; &quot;\n d : &quot; &lt;&lt; obj.d &lt;&lt; '\n';
}
</code></pre>
<h2 id="inheritance-in-software-engineering"><a class="header" href="#inheritance-in-software-engineering">Inheritance in Software Engineering</a></h2>
<p>Why use inheritance?</p>
<blockquote>
<p>Inheritance is used all the time when writing object-oriented code.
In most OO languages, (with C++ being a prominent exception,) all objects have a single &quot;base object&quot; class that they derive from that provides common functionality, so literally everything that uses an object uses inheritance.</p>
</blockquote>
<p>Ref: <a href="https://softwareengineering.stackexchange.com/a/190788">Mason Wheeler</a></p>
<hr />
<p>Why use inheritance?</p>
<ul>
<li>Reuse code
<ul>
<li>You can reuse code by inheriting from a class without having to copy/paste the code.</li>
<li>Also, you can reuse pre-built codes with inheritance.</li>
</ul>
</li>
<li>Code integrity
<ul>
<li>You can ensure that your code is consistent, i.e. the structure of the code is the same for all derived classes.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="pros-of-inheritance"><a class="header" href="#pros-of-inheritance">Pros of Inheritance</a></h3>
<p>Advantages:</p>
<ul>
<li>Inheritance promotes reusability. When a class inherits or derives another class, it can access all the functionality of inherited class.</li>
</ul>
<ul>
<li>Reusability enhanced reliability. The base class code will be already tested and debugged.</li>
<li>As the existing code is reused, it leads to less development and maintenance costs.</li>
<li>Inheritance makes the sub classes follow a standard interface.</li>
<li>Inheritance helps to reduce code redundancy and supports code extensibility.</li>
<li>Inheritance facilitates creation of class libraries.</li>
</ul>
<p>Ref: <a href="https://practice.geeksforgeeks.org/problems/what-are-advantages-and-disadvantages-of-using-inheritance">vaishali bhatia</a></p>
<hr />
<h3 id="cons-of-inheritance"><a class="header" href="#cons-of-inheritance">Cons of Inheritance</a></h3>
<p>Disadvantages:</p>
<ul>
<li>Inherited functions work slower than normal function as there is indirection.</li>
</ul>
<ul>
<li>Improper use of inheritance may lead to wrong solutions.</li>
<li>Often, data members in the base class are left unused which may lead to memory wastage.</li>
<li>Inheritance increases the coupling between base class and derived class. A change in base class will affect all the child classes.</li>
</ul>
<p>Ref: <a href="https://practice.geeksforgeeks.org/problems/what-are-advantages-and-disadvantages-of-using-inheritance">vaishali bhatia</a></p>
<hr />
<h3 id="is-a-inheritance--has-a-composition"><a class="header" href="#is-a-inheritance--has-a-composition">Is a (Inheritance) &amp; Has a (Composition)</a></h3>
<p>When to use inheritance?</p>
<ul>
<li>If object B is an object A, then inheritance is used.</li>
<li>e.g. an apple is a fruit, so inheritance is used.</li>
</ul>
<p>When to use composition?</p>
<ul>
<li>If object B has object A, then composition is used.</li>
<li>e.g. a car has a engine, so composition is used.</li>
</ul>
<hr />
<h3 id="pitfall-use-inheritance-in-has-a-relationship"><a class="header" href="#pitfall-use-inheritance-in-has-a-relationship">Pitfall: Use Inheritance in Has-a Relationship</a></h3>
<pre><code class="language-c++">class Legs
{
public:
    void WalkAround() {... code for walking around goes here... }
};

class Arms
{
public:
    void GrabThings() {... code for grabbing things goes here... }
};

class InheritanceRobot : public Legs, public Arms
{
public:
    // WalkAround() and GrabThings() methods are implicitly
    // defined for this class since it inherited those
    // methods from its two superclasses
};

class CompositionRobot
{
public:
    void WalkAround() { legs.WalkAround(); }
    void GrabThings() { arms.GrabThings(); }

private:
    Legs legs;
    Arms arms;
};
</code></pre>
<p>Ref: <a href="https://stackoverflow.com/a/49890573/7319728">Jeremy Friesner</a></p>
<h2 id="example-1-integer--real--complex-number-calculator-a-hrefooplecture10_ex1htmlsourcea"><a class="header" href="#example-1-integer--real--complex-number-calculator-a-hrefooplecture10_ex1htmlsourcea">Example 1: Integer &amp; Real &amp; Complex Number Calculator [<a href="oop/./lecture10_ex1.html">Source</a>]</a></h2>
<h2 id="example-2-complex-number--triangle-a-hrefooplecture10_ex2htmlsourcea"><a class="header" href="#example-2-complex-number--triangle-a-hrefooplecture10_ex2htmlsourcea">Example 2: Complex Number &amp; Triangle [<a href="oop/./lecture10_ex2.html">Source</a>]</a></h2>
<h2 id="example-3-complex-number--triangles-a-hrefooplecture10_ex3htmlsourcea"><a class="header" href="#example-3-complex-number--triangles-a-hrefooplecture10_ex3htmlsourcea">Example 3: Complex Number &amp; Triangles [<a href="oop/./lecture10_ex3.html">Source</a>]</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-1-integer--real--complex-number-calculator"><a class="header" href="#example-1-integer--real--complex-number-calculator">Example 1: Integer &amp; Real &amp; Complex Number Calculator</a></h1>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

using namespace std;

class Integer
{
protected:
    int m_int_value;

public:
    Integer(int arg_int_value = 0) : m_int_value(arg_int_value)
    {
    }
    Integer(const Integer &amp;arg_int) : m_int_value(arg_int.m_int_value)
    {
    }
    operator int() const
    {
        return m_int_value;
    }
    Integer &amp;operator=(const Integer &amp;arg_int)
    {
        m_int_value = arg_int.m_int_value;
        return *this;
    }
    void set_int_value(int arg_int_value)
    {
        m_int_value = arg_int_value;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Integer &amp;arg_integer)
    {
        arg_os &lt;&lt; arg_integer.m_int_value;
        return arg_os;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Integer &amp;arg_integer)
    {
        arg_is &gt;&gt; arg_integer.m_int_value;
        return arg_is;
    }
    friend Integer operator+(const Integer &amp;arg_integer1, const Integer &amp;arg_integer2)
    {
        Integer temp_integer(arg_integer1.m_int_value + arg_integer2.m_int_value);
        return temp_integer;
    }
    friend Integer operator-(const Integer &amp;arg_integer1, const Integer &amp;arg_integer2)
    {
        Integer temp_integer(arg_integer1.m_int_value - arg_integer2.m_int_value);
        return temp_integer;
    }
    friend Integer operator*(const Integer &amp;arg_integer1, const Integer &amp;arg_integer2)
    {
        Integer temp_integer(arg_integer1.m_int_value * arg_integer2.m_int_value);
        return temp_integer;
    }
    friend Integer operator/(const Integer &amp;arg_integer1, const Integer &amp;arg_integer2)
    {
        Integer temp_integer(arg_integer1.m_int_value / arg_integer2.m_int_value);
        return temp_integer;
    }
};

// Real is a Integer
class Real : public Integer
{
protected:
    double m_after_decimal;

public:
    Real(double arg_value = 0.0) : Integer((int)arg_value),
                                   m_after_decimal(arg_value - (int)arg_value)
    {
    }
    Real(const Real &amp;arg_real) : Integer(arg_real),
                                 m_after_decimal(arg_real.m_after_decimal)
    {
    }
    operator double() const
    {
        return m_after_decimal + (double)m_int_value;
    }
    Real &amp;operator=(const Real &amp;arg_real)
    {
        m_int_value = arg_real.m_int_value;
        m_after_decimal = arg_real.m_after_decimal;
        return *this;
    }
    void set_real_value(double arg_value)
    {
        m_int_value = (int)arg_value;
        m_after_decimal = arg_value - m_int_value;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Real &amp;arg_real)
    {
        arg_os &lt;&lt; (double)arg_real;
        return arg_os;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Real &amp;arg_real)
    {
        double temp_double;
        arg_is &gt;&gt; temp_double;
        arg_real.set_real_value(temp_double);
        return arg_is;
    }
    friend Real operator+(const Real &amp;arg_real1, const Real &amp;arg_real2)
    {
        // call the Integer operator+ to add the Integer part
        Integer temp_integer((Integer)arg_real1 + (Integer)arg_real2);
        Real temp_real(arg_real1.m_after_decimal + arg_real2.m_after_decimal);
        temp_real.set_int_value((int)temp_integer + (int)temp_real);
        return temp_real;
    }
    friend Real operator-(const Real &amp;arg_real1, const Real &amp;arg_real2)
    {
        Real temp_real((double)arg_real1 - (double)arg_real2);
        return temp_real;
    }
    friend Real operator*(const Real &amp;arg_real1, const Real &amp;arg_real2)
    {
        Real temp_real((double)arg_real1 * (double)arg_real2);
        return temp_real;
    }
    friend Real operator/(const Real &amp;arg_real1, const Real &amp;arg_real2)
    {
        Real temp_real((double)arg_real1 / (double)arg_real2);
        return temp_real;
    }
};

class Imaginary
{
protected:
    double m_imaginary_value;

public:
    Imaginary(double arg_imaginary_value = 0.0) : m_imaginary_value(arg_imaginary_value)
    {
    }
    Imaginary(const Imaginary &amp;arg_imaginary) : m_imaginary_value(arg_imaginary.m_imaginary_value)
    {
    }
    Imaginary &amp;operator=(const Imaginary &amp;arg_imaginary)
    {
        m_imaginary_value = arg_imaginary.m_imaginary_value;
        return *this;
    }
    double get_imaginary_value() const
    {
        return m_imaginary_value;
    }
    void set_imaginary_value(double arg_imaginary_value)
    {
        m_imaginary_value = arg_imaginary_value;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Imaginary &amp;arg_imaginary)
    {
        arg_os &lt;&lt; arg_imaginary.m_imaginary_value &lt;&lt; &quot;i&quot;;
        return arg_os;
    }
    friend Imaginary operator+(const Imaginary &amp;arg_imaginary1, const Imaginary &amp;arg_imaginary2)
    {
        Imaginary temp_imaginary(arg_imaginary1.m_imaginary_value + arg_imaginary2.m_imaginary_value);
        return temp_imaginary;
    }
    friend Imaginary operator-(const Imaginary &amp;arg_imaginary1, const Imaginary &amp;arg_imaginary2)
    {
        Imaginary temp_imaginary(arg_imaginary1.m_imaginary_value - arg_imaginary2.m_imaginary_value);
        return temp_imaginary;
    }
};

class Complex : public Real, public Imaginary
{
public:
    Complex(double arg_real_value = 0.0,
            double arg_imaginary_value = 0.0)
        : Real(arg_real_value),
          Imaginary(arg_imaginary_value)
    {
    }
    Complex(const Complex &amp;arg_complex)
        : Real(arg_complex),
          Imaginary(arg_complex)
    {
    }
    Complex &amp;operator=(const Complex &amp;arg_complex)
    {
        Real::operator=(arg_complex);
        Imaginary::operator=(arg_complex);
        return *this;
    }
    Complex reciprocal() const
    {
        Complex temp_complex(*this);
        double temp_real_value = temp_complex;
        double temp_imaginary_value = temp_complex.get_imaginary_value();
        double temp_denominator = temp_real_value * temp_real_value + temp_imaginary_value * temp_imaginary_value;
        temp_complex.set_real_value(temp_real_value / temp_denominator);
        temp_complex.set_imaginary_value(-temp_imaginary_value / temp_denominator);
        return temp_complex;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex &amp;arg_complex)
    {
        arg_os &lt;&lt; (Real)arg_complex &lt;&lt; &quot; + &quot; &lt;&lt; (Imaginary)arg_complex;
        return arg_os;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Complex &amp;arg_complex)
    {
        string temp_string;
        getline(arg_is, temp_string);
        size_t plus_pos = temp_string.find(&quot;+&quot;);
        if (plus_pos != string::npos)
        {
            arg_complex.set_real_value(atof(temp_string.substr(0, plus_pos).c_str()));
        }
        size_t i_pos = temp_string.find(&quot;i&quot;);
        if (i_pos != string::npos)
        {
            arg_complex.set_imaginary_value(
                atof(temp_string.substr(plus_pos + 1, i_pos - plus_pos - 1)
                         .c_str()));
        }
        return arg_is;
    }
    friend Complex operator+(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        Complex temp_complex((double)arg_complex1 + (double)arg_complex2,
                             arg_complex1.get_imaginary_value() + arg_complex2.get_imaginary_value());
        return temp_complex;
    }
    friend Complex operator-(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        Complex temp_complex((double)arg_complex1 - (double)arg_complex2,
                             arg_complex1.get_imaginary_value() - arg_complex2.get_imaginary_value());
        return temp_complex;
    }
    friend Complex operator*(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        Complex temp_complex((double)arg_complex1 * (double)arg_complex2 -
                                 arg_complex1.get_imaginary_value() * arg_complex2.get_imaginary_value(),
                             (double)arg_complex1 * arg_complex2.get_imaginary_value() +
                                 arg_complex1.get_imaginary_value() * (double)arg_complex2);
        return temp_complex;
    }
    friend Complex operator/(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        Complex temp_complex(arg_complex1 * arg_complex2.reciprocal());
        return temp_complex;
    }
};

// Complex calculator class declaration
class Complex_Calc
{
private:
    // define current value
    Complex m_curr_val;
    // define input value
    Complex m_input_val;
    // define operation
    // `+`, `-`, `*`, `/`, and `=`
    char m_op;
    // define input status, turns `op` for true and turns `value` for false
    bool m_op_input;
    // calculate result
    void _calc_result()
    {
        switch (m_op)
        {
        case '+':
            m_curr_val = m_curr_val + m_input_val;
            break;
        case '-':
            m_curr_val = m_curr_val - m_input_val;
            break;
        case '*':
            m_curr_val = m_curr_val * m_input_val;
            break;
        case '/':
            m_curr_val = m_curr_val / m_input_val;
            break;
        case '=':
            m_curr_val = m_input_val;
            break;
        default:
            break;
        }
    }
    // operation functions
    // set activation op to add
    void _add()
    {
        m_op = '+';
        m_op_input = false;
    }
    // set activation op to subtract
    void _sub()
    {
        m_op = '-';
        m_op_input = false;
    }
    // set activation op to multiply
    void _mul()
    {
        m_op = '*';
        m_op_input = false;
    }
    // set activation op to divide
    void _div()
    {
        m_op = '/';
        m_op_input = false;
    }
    // set activation op to assign
    void _assign()
    {
        m_op = '=';
        m_op_input = false;
    }

public:
    // Constructor
    Complex_Calc()
        : m_curr_val(), m_input_val(), m_op('='), m_op_input(false)
    {
    }

    // Copy constructor
    Complex_Calc(const Complex_Calc &amp;arg_comp_calc)
        : m_curr_val(arg_comp_calc.m_curr_val), m_input_val(arg_comp_calc.m_input_val),
          m_op(arg_comp_calc.m_op), m_op_input(arg_comp_calc.m_op_input)
    {
    }

    // Destructor
    ~Complex_Calc(){}; // no need to do anything

    // cin `&gt;&gt;` operator for set input value or operation
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Complex_Calc &amp;arg_comp_calc)
    {
        string temp_string;
        getline(arg_is, temp_string);
        if (temp_string == &quot;+&quot;)
        {
            arg_comp_calc._add();
        }
        else if (temp_string == &quot;-&quot;)
        {
            arg_comp_calc._sub();
        }
        else if (temp_string == &quot;*&quot;)
        {
            arg_comp_calc._mul();
        }
        else if (temp_string == &quot;/&quot;)
        {
            arg_comp_calc._div();
        }
        else if (temp_string == &quot;=&quot;)
        {
            arg_comp_calc._assign();
        }
        else
        {
            stringstream temp_string_stream(temp_string);
            temp_string_stream &gt;&gt; arg_comp_calc.m_input_val;
            arg_comp_calc.m_op_input = true;
            arg_comp_calc._calc_result();
        }
        return arg_is;
    }

    // cout `&lt;&lt;` operator for print calculator status
    // note: be careful about the format of output
    // cout `&lt;&lt;` operator for print calculator status
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex_Calc &amp;arg_comp_calc)
    {
        arg_os &lt;&lt; arg_comp_calc.m_curr_val;
        return arg_os;
    }
};

int main()
{
    // create an instance of the class
    Complex_Calc calc;
    while (cin &gt;&gt; calc)
    {
        cout &lt;&lt; calc &lt;&lt; endl;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-2-complex-number--triangle"><a class="header" href="#example-2-complex-number--triangle">Example 2: Complex Number &amp; Triangle</a></h1>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

using namespace std;

class Triangle_Complex; // forward declaration

class Integer
{
protected:
    int m_int_value;

public:
    Integer(int arg_int_value = 0) : m_int_value(arg_int_value)
    {
    }
    Integer(const Integer &amp;arg_int) : m_int_value(arg_int.m_int_value)
    {
    }
    operator int() const
    {
        return m_int_value;
    }
    Integer &amp;operator=(const Integer &amp;arg_int)
    {
        m_int_value = arg_int.m_int_value;
        return *this;
    }
    void set_int_value(int arg_int_value)
    {
        m_int_value = arg_int_value;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Integer &amp;arg_integer)
    {
        arg_os &lt;&lt; arg_integer.m_int_value;
        return arg_os;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Integer &amp;arg_integer)
    {
        arg_is &gt;&gt; arg_integer.m_int_value;
        return arg_is;
    }
    friend Integer operator+(const Integer &amp;arg_integer1, const Integer &amp;arg_integer2)
    {
        Integer temp_integer(arg_integer1.m_int_value + arg_integer2.m_int_value);
        return temp_integer;
    }
    friend Integer operator-(const Integer &amp;arg_integer1, const Integer &amp;arg_integer2)
    {
        Integer temp_integer(arg_integer1.m_int_value - arg_integer2.m_int_value);
        return temp_integer;
    }
    friend Integer operator*(const Integer &amp;arg_integer1, const Integer &amp;arg_integer2)
    {
        Integer temp_integer(arg_integer1.m_int_value * arg_integer2.m_int_value);
        return temp_integer;
    }
    friend Integer operator/(const Integer &amp;arg_integer1, const Integer &amp;arg_integer2)
    {
        Integer temp_integer(arg_integer1.m_int_value / arg_integer2.m_int_value);
        return temp_integer;
    }
};

// Real is a Integer
class Real : public Integer
{
protected:
    double m_after_decimal;

public:
    Real(double arg_value = 0.0) : Integer((int)arg_value),
                                   m_after_decimal(arg_value - (int)arg_value)
    {
    }
    Real(const Real &amp;arg_real) : Integer(arg_real),
                                 m_after_decimal(arg_real.m_after_decimal)
    {
    }
    operator double() const
    {
        return m_after_decimal + (double)m_int_value;
    }
    Real &amp;operator=(const Real &amp;arg_real)
    {
        m_int_value = arg_real.m_int_value;
        m_after_decimal = arg_real.m_after_decimal;
        return *this;
    }
    void set_real_value(double arg_value)
    {
        m_int_value = (int)arg_value;
        m_after_decimal = arg_value - m_int_value;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Real &amp;arg_real)
    {
        arg_os &lt;&lt; (double)arg_real;
        return arg_os;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Real &amp;arg_real)
    {
        double temp_double;
        arg_is &gt;&gt; temp_double;
        arg_real.set_real_value(temp_double);
        return arg_is;
    }
    friend Real operator+(const Real &amp;arg_real1, const Real &amp;arg_real2)
    {
        // call the Integer operator+ to add the Integer part
        Integer temp_integer((Integer)arg_real1 + (Integer)arg_real2);
        Real temp_real(arg_real1.m_after_decimal + arg_real2.m_after_decimal);
        temp_real.set_int_value((int)temp_integer + (int)temp_real);
        return temp_real;
    }
    friend Real operator-(const Real &amp;arg_real1, const Real &amp;arg_real2)
    {
        Real temp_real((double)arg_real1 - (double)arg_real2);
        return temp_real;
    }
    friend Real operator*(const Real &amp;arg_real1, const Real &amp;arg_real2)
    {
        Real temp_real((double)arg_real1 * (double)arg_real2);
        return temp_real;
    }
    friend Real operator/(const Real &amp;arg_real1, const Real &amp;arg_real2)
    {
        Real temp_real((double)arg_real1 / (double)arg_real2);
        return temp_real;
    }
};

class Imaginary
{
protected:
    double m_imaginary_value;

public:
    Imaginary(double arg_imaginary_value = 0.0) : m_imaginary_value(arg_imaginary_value)
    {
    }
    Imaginary(const Imaginary &amp;arg_imaginary) : m_imaginary_value(arg_imaginary.m_imaginary_value)
    {
    }
    Imaginary &amp;operator=(const Imaginary &amp;arg_imaginary)
    {
        m_imaginary_value = arg_imaginary.m_imaginary_value;
        return *this;
    }
    double get_imaginary_value() const
    {
        return m_imaginary_value;
    }
    void set_imaginary_value(double arg_imaginary_value)
    {
        m_imaginary_value = arg_imaginary_value;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Imaginary &amp;arg_imaginary)
    {
        arg_os &lt;&lt; arg_imaginary.m_imaginary_value &lt;&lt; &quot;i&quot;;
        return arg_os;
    }
    friend Imaginary operator+(const Imaginary &amp;arg_imaginary1, const Imaginary &amp;arg_imaginary2)
    {
        Imaginary temp_imaginary(arg_imaginary1.m_imaginary_value + arg_imaginary2.m_imaginary_value);
        return temp_imaginary;
    }
    friend Imaginary operator-(const Imaginary &amp;arg_imaginary1, const Imaginary &amp;arg_imaginary2)
    {
        Imaginary temp_imaginary(arg_imaginary1.m_imaginary_value - arg_imaginary2.m_imaginary_value);
        return temp_imaginary;
    }
};

class Complex : public Real, public Imaginary
{
public:
    Complex(double arg_real_value = 0.0,
            double arg_imaginary_value = 0.0)
        : Real(arg_real_value),
          Imaginary(arg_imaginary_value)
    {
    }
    Complex(const Complex &amp;arg_complex)
        : Real(arg_complex),
          Imaginary(arg_complex)
    {
    }
    Complex &amp;operator=(const Complex &amp;arg_complex)
    {
        Real::operator=(arg_complex);
        Imaginary::operator=(arg_complex);
        return *this;
    }
    Complex reciprocal() const
    {
        Complex temp_complex(*this);
        double temp_real_value = temp_complex;
        double temp_imaginary_value = temp_complex.get_imaginary_value();
        double temp_denominator = temp_real_value * temp_real_value + temp_imaginary_value * temp_imaginary_value;
        temp_complex.set_real_value(temp_real_value / temp_denominator);
        temp_complex.set_imaginary_value(-temp_imaginary_value / temp_denominator);
        return temp_complex;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex &amp;arg_complex)
    {
        arg_os &lt;&lt; (Real)arg_complex &lt;&lt; &quot; + &quot; &lt;&lt; (Imaginary)arg_complex;
        return arg_os;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Complex &amp;arg_complex)
    {
        string temp_string;
        getline(arg_is, temp_string, '+');
        arg_complex.set_real_value(stod(temp_string));
        getline(arg_is, temp_string, 'i');
        arg_complex.set_imaginary_value(stod(temp_string));
        return arg_is;
    }
    friend Complex operator+(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        Complex temp_complex((double)arg_complex1 + (double)arg_complex2,
                             arg_complex1.get_imaginary_value() + arg_complex2.get_imaginary_value());
        return temp_complex;
    }
    friend Complex operator-(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        Complex temp_complex((double)arg_complex1 - (double)arg_complex2,
                             arg_complex1.get_imaginary_value() - arg_complex2.get_imaginary_value());
        return temp_complex;
    }
    friend Complex operator*(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        Complex temp_complex((double)arg_complex1 * (double)arg_complex2 -
                                 arg_complex1.get_imaginary_value() * arg_complex2.get_imaginary_value(),
                             (double)arg_complex1 * arg_complex2.get_imaginary_value() +
                                 arg_complex1.get_imaginary_value() * (double)arg_complex2);
        return temp_complex;
    }
    friend Complex operator/(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        Complex temp_complex(arg_complex1 * arg_complex2.reciprocal());
        return temp_complex;
    }
    friend bool operator==(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        return ((double)arg_complex1 == (double)arg_complex2) &amp;&amp;
               (arg_complex1.get_imaginary_value() == arg_complex2.get_imaginary_value());
    }
    friend bool operator!=(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        return !(arg_complex1 == arg_complex2);
    }
    friend bool operator&lt;(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        return ((double)arg_complex1 &lt; (double)arg_complex2) ||
               ((double)arg_complex1 == (double)arg_complex2 &amp;&amp;
                arg_complex1.get_imaginary_value() &lt; arg_complex2.get_imaginary_value());
    }
    friend bool operator&gt;(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        return arg_complex2 &lt; arg_complex1;
    }
    friend bool operator&lt;=(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        return !(arg_complex1 &gt; arg_complex2);
    }
    friend bool operator&gt;=(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        return !(arg_complex1 &lt; arg_complex2);
    }
    friend class Triangle_Complex;
};

// Triangle_Complex class declaration
class Triangle_Complex
{
private:
    // define three points of the Triangle_Complex
    // Triangle 'has-a' Complex, so it use composition
    Complex m_point[3];

    // check &amp; correct the Triangle_Complex points to counterclockwise order
    void _check_points()
    {
        // if the area is negative, swap the points
        if (area() &lt; 0.0)
        {
            Complex temp = m_point[0];
            m_point[0] = m_point[1];
            m_point[1] = temp;
        }
    }

public:
    // Constructor
    Triangle_Complex(const Complex &amp;arg_point1,
                     const Complex &amp;arg_point2,
                     const Complex &amp;arg_point3)
        : m_point{arg_point1, arg_point2, arg_point3}
    {
        _check_points();
    }

    // Copy constructor
    Triangle_Complex(const Triangle_Complex &amp;arg_triangle)
        : m_point{arg_triangle.m_point[0], arg_triangle.m_point[1], arg_triangle.m_point[2]}
    {
    }

    // Destructor
    ~Triangle_Complex() {} // do nothing

    // modify the three points of the Triangle_Complex
    void set_points(const Complex &amp;arg_point1,
                    const Complex &amp;arg_point2,
                    const Complex &amp;arg_point3)
    {
        m_point[0] = arg_point1;
        m_point[1] = arg_point2;
        m_point[2] = arg_point3;
        _check_points();
    }
    void set_point1(const Complex &amp;arg_point1)
    {
        m_point[0] = arg_point1;
        _check_points();
    }
    void set_point2(const Complex &amp;arg_point2)
    {
        m_point[1] = arg_point2;
        _check_points();
    }
    void set_point3(const Complex &amp;arg_point3)
    {
        m_point[2] = arg_point3;
        _check_points();
    }
    // get the three points of the Triangle_Complex
    Complex get_point1() const
    {
        return m_point[0];
    }
    Complex get_point2() const
    {
        return m_point[1];
    }
    Complex get_point3() const
    {
        return m_point[2];
    }

    // calculate the area of the Triangle_Complex
    double area()
    {
        double area = 0.0;
        for (int i = 0; i &lt; 3; i++)
        {
            area += (double)m_point[i] * m_point[(i + 1) % 3].get_imaginary_value();
            area -= m_point[i].get_imaginary_value() * (double)m_point[(i + 1) % 3];
        }
        return area / 2.0;
    }

    // print the Triangle_Complex
    // format: (c1, c2, c3)
    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;arg_os, const Triangle_Complex &amp;arg_tri)
    {
        arg_os &lt;&lt; &quot;(&quot;;
        for (int i = 0; i &lt; 3; i++)
        {
            arg_os &lt;&lt; arg_tri.m_point[i];
            if (i &lt; 2)
                arg_os &lt;&lt; &quot;, &quot;;
        }
        arg_os &lt;&lt; &quot;)&quot;;
        return arg_os;
    }
    // read the coordinate of a point from the input,
    // format: (c1, c2, c3) and ignore space
    friend std::istream &amp;operator&gt;&gt;(std::istream &amp;arg_is, Triangle_Complex &amp;arg_tri)
    {
        string temp;
        if (getline(arg_is, temp, '(')) // ignore the first '('
        {
            for (int i = 0; i &lt; 3; i++)
            {
                arg_is &gt;&gt; arg_tri.m_point[i];
                if (i &lt; 2)
                {
                    getline(arg_is, temp, ','); // ignore the ','
                }
            }
            getline(arg_is, temp, ')'); // ignore the last ')'
        }

        // check &amp; correct the Triangle_Complex points to counterclockwise order
        arg_tri._check_points();

        return arg_is;
    }
};

// main function

int main()
{
    Triangle_Complex t(Complex(1, 1), Complex(2, 2), Complex(0, 3));
    cout &lt;&lt; t &lt;&lt; endl;
    cout &lt;&lt; &quot;Area: &quot; &lt;&lt; t.area() &lt;&lt; endl;

    // change the points of the Triangle_Complex
    cin &gt;&gt; t;
    cout &lt;&lt; t &lt;&lt; endl;
    cout &lt;&lt; &quot;Area: &quot; &lt;&lt; t.area() &lt;&lt; endl;

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-3-complex-number--triangles"><a class="header" href="#example-3-complex-number--triangles">Example 3: Complex Number &amp; Triangles</a></h1>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;cmath&gt;

using namespace std;

class Triangle_Complex; // forward declaration

class Integer
{
protected:
    int m_int_value;

public:
    Integer(int arg_int_value = 0) : m_int_value(arg_int_value)
    {
    }
    Integer(const Integer &amp;arg_int) : m_int_value(arg_int.m_int_value)
    {
    }
    operator int() const
    {
        return m_int_value;
    }
    Integer &amp;operator=(const Integer &amp;arg_int)
    {
        m_int_value = arg_int.m_int_value;
        return *this;
    }
    void set_int_value(int arg_int_value)
    {
        m_int_value = arg_int_value;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Integer &amp;arg_integer)
    {
        arg_os &lt;&lt; arg_integer.m_int_value;
        return arg_os;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Integer &amp;arg_integer)
    {
        arg_is &gt;&gt; arg_integer.m_int_value;
        return arg_is;
    }
    friend Integer operator+(const Integer &amp;arg_integer1, const Integer &amp;arg_integer2)
    {
        Integer temp_integer(arg_integer1.m_int_value + arg_integer2.m_int_value);
        return temp_integer;
    }
    friend Integer operator-(const Integer &amp;arg_integer1, const Integer &amp;arg_integer2)
    {
        Integer temp_integer(arg_integer1.m_int_value - arg_integer2.m_int_value);
        return temp_integer;
    }
    friend Integer operator*(const Integer &amp;arg_integer1, const Integer &amp;arg_integer2)
    {
        Integer temp_integer(arg_integer1.m_int_value * arg_integer2.m_int_value);
        return temp_integer;
    }
    friend Integer operator/(const Integer &amp;arg_integer1, const Integer &amp;arg_integer2)
    {
        Integer temp_integer(arg_integer1.m_int_value / arg_integer2.m_int_value);
        return temp_integer;
    }
};

// Real is a Integer
class Real : public Integer
{
protected:
    double m_after_decimal;

public:
    Real(double arg_value = 0.0) : Integer((int)arg_value),
                                   m_after_decimal(arg_value - (int)arg_value)
    {
    }
    Real(const Real &amp;arg_real) : Integer(arg_real),
                                 m_after_decimal(arg_real.m_after_decimal)
    {
    }
    operator double() const
    {
        return m_after_decimal + (double)m_int_value;
    }
    Real &amp;operator=(const Real &amp;arg_real)
    {
        m_int_value = arg_real.m_int_value;
        m_after_decimal = arg_real.m_after_decimal;
        return *this;
    }
    void set_real_value(double arg_value)
    {
        m_int_value = (int)arg_value;
        m_after_decimal = arg_value - m_int_value;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Real &amp;arg_real)
    {
        arg_os &lt;&lt; (double)arg_real;
        return arg_os;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Real &amp;arg_real)
    {
        double temp_double;
        arg_is &gt;&gt; temp_double;
        arg_real.set_real_value(temp_double);
        return arg_is;
    }
    friend Real operator+(const Real &amp;arg_real1, const Real &amp;arg_real2)
    {
        // call the Integer operator+ to add the Integer part
        Integer temp_integer((Integer)arg_real1 + (Integer)arg_real2);
        Real temp_real(arg_real1.m_after_decimal + arg_real2.m_after_decimal);
        temp_real.set_int_value((int)temp_integer + (int)temp_real);
        return temp_real;
    }
    friend Real operator-(const Real &amp;arg_real1, const Real &amp;arg_real2)
    {
        Real temp_real((double)arg_real1 - (double)arg_real2);
        return temp_real;
    }
    friend Real operator*(const Real &amp;arg_real1, const Real &amp;arg_real2)
    {
        Real temp_real((double)arg_real1 * (double)arg_real2);
        return temp_real;
    }
    friend Real operator/(const Real &amp;arg_real1, const Real &amp;arg_real2)
    {
        Real temp_real((double)arg_real1 / (double)arg_real2);
        return temp_real;
    }
};

class Imaginary
{
protected:
    double m_imaginary_value;

public:
    Imaginary(double arg_imaginary_value = 0.0) : m_imaginary_value(arg_imaginary_value)
    {
    }
    Imaginary(const Imaginary &amp;arg_imaginary) : m_imaginary_value(arg_imaginary.m_imaginary_value)
    {
    }
    Imaginary &amp;operator=(const Imaginary &amp;arg_imaginary)
    {
        m_imaginary_value = arg_imaginary.m_imaginary_value;
        return *this;
    }
    double get_imaginary_value() const
    {
        return m_imaginary_value;
    }
    void set_imaginary_value(double arg_imaginary_value)
    {
        m_imaginary_value = arg_imaginary_value;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Imaginary &amp;arg_imaginary)
    {
        arg_os &lt;&lt; arg_imaginary.m_imaginary_value &lt;&lt; &quot;i&quot;;
        return arg_os;
    }
    friend Imaginary operator+(const Imaginary &amp;arg_imaginary1, const Imaginary &amp;arg_imaginary2)
    {
        Imaginary temp_imaginary(arg_imaginary1.m_imaginary_value + arg_imaginary2.m_imaginary_value);
        return temp_imaginary;
    }
    friend Imaginary operator-(const Imaginary &amp;arg_imaginary1, const Imaginary &amp;arg_imaginary2)
    {
        Imaginary temp_imaginary(arg_imaginary1.m_imaginary_value - arg_imaginary2.m_imaginary_value);
        return temp_imaginary;
    }
};

class Complex : public Real, public Imaginary
{
public:
    Complex(double arg_real_value = 0.0,
            double arg_imaginary_value = 0.0)
        : Real(arg_real_value),
          Imaginary(arg_imaginary_value)
    {
    }
    Complex(const Complex &amp;arg_complex)
        : Real(arg_complex),
          Imaginary(arg_complex)
    {
    }
    Complex &amp;operator=(const Complex &amp;arg_complex)
    {
        Real::operator=(arg_complex);
        Imaginary::operator=(arg_complex);
        return *this;
    }
    Complex reciprocal() const
    {
        Complex temp_complex(*this);
        double temp_real_value = temp_complex;
        double temp_imaginary_value = temp_complex.get_imaginary_value();
        double temp_denominator = temp_real_value * temp_real_value + temp_imaginary_value * temp_imaginary_value;
        temp_complex.set_real_value(temp_real_value / temp_denominator);
        temp_complex.set_imaginary_value(-temp_imaginary_value / temp_denominator);
        return temp_complex;
    }
    double get_magnitude() const
    {
        Real temp_real(*this);
        return sqrt((double)(temp_real * temp_real) + get_imaginary_value() * get_imaginary_value());
    }
    Complex get_argument() const
    {
        double magnitude = get_magnitude();
        Complex temp_complex((double)(*this) / magnitude, get_imaginary_value() / magnitude);
        return temp_complex;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex &amp;arg_complex)
    {
        arg_os &lt;&lt; (Real)arg_complex &lt;&lt; &quot; + &quot; &lt;&lt; (Imaginary)arg_complex;
        return arg_os;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Complex &amp;arg_complex)
    {
        string temp_string;
        getline(arg_is, temp_string, '+');
        arg_complex.set_real_value(stod(temp_string));
        getline(arg_is, temp_string, 'i');
        arg_complex.set_imaginary_value(stod(temp_string));
        return arg_is;
    }
    friend Complex operator+(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        Complex temp_complex((double)arg_complex1 + (double)arg_complex2,
                             arg_complex1.get_imaginary_value() + arg_complex2.get_imaginary_value());
        return temp_complex;
    }
    friend Complex operator-(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        Complex temp_complex((double)arg_complex1 - (double)arg_complex2,
                             arg_complex1.get_imaginary_value() - arg_complex2.get_imaginary_value());
        return temp_complex;
    }
    friend Complex operator*(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        Complex temp_complex((double)arg_complex1 * (double)arg_complex2 -
                                 arg_complex1.get_imaginary_value() * arg_complex2.get_imaginary_value(),
                             (double)arg_complex1 * arg_complex2.get_imaginary_value() +
                                 arg_complex1.get_imaginary_value() * (double)arg_complex2);
        return temp_complex;
    }
    friend Complex operator/(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        Complex temp_complex(arg_complex1 * arg_complex2.reciprocal());
        return temp_complex;
    }
    friend bool operator==(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        return ((double)arg_complex1 == (double)arg_complex2) &amp;&amp;
               (arg_complex1.get_imaginary_value() == arg_complex2.get_imaginary_value());
    }
    friend bool operator!=(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        return !(arg_complex1 == arg_complex2);
    }
    friend bool operator&lt;(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        return ((double)arg_complex1 &lt; (double)arg_complex2) ||
               ((double)arg_complex1 == (double)arg_complex2 &amp;&amp;
                arg_complex1.get_imaginary_value() &lt; arg_complex2.get_imaginary_value());
    }
    friend bool operator&gt;(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        return arg_complex2 &lt; arg_complex1;
    }
    friend bool operator&lt;=(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        return !(arg_complex1 &gt; arg_complex2);
    }
    friend bool operator&gt;=(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        return !(arg_complex1 &lt; arg_complex2);
    }
    friend class Triangle_Complex;
};

// Triangle_Complex class declaration
class Triangle_Complex
{
protected:
    // define three points of the Triangle_Complex
    // Triangle 'has-a' Complex, so it use composition
    Complex m_point[3];

    // check &amp; correct the Triangle_Complex points to counterclockwise order
    void _check_points()
    {
        // if the area is negative, swap the points
        if (area() &lt; 0.0)
        {
            Complex temp = m_point[0];
            m_point[0] = m_point[1];
            m_point[1] = temp;
        }
    }

public:
    // Constructor
    Triangle_Complex(const Complex &amp;arg_point1,
                     const Complex &amp;arg_point2,
                     const Complex &amp;arg_point3)
        : m_point{arg_point1, arg_point2, arg_point3}
    {
        _check_points();
    }

    // Copy constructor
    Triangle_Complex(const Triangle_Complex &amp;arg_triangle)
        : m_point{arg_triangle.m_point[0], arg_triangle.m_point[1], arg_triangle.m_point[2]}
    {
    }

    // Destructor
    ~Triangle_Complex() {} // do nothing

    // modify the three points of the Triangle_Complex
    void set_points(const Complex &amp;arg_point1,
                    const Complex &amp;arg_point2,
                    const Complex &amp;arg_point3)
    {
        m_point[0] = arg_point1;
        m_point[1] = arg_point2;
        m_point[2] = arg_point3;
        _check_points();
    }
    void set_point1(const Complex &amp;arg_point1)
    {
        m_point[0] = arg_point1;
        _check_points();
    }
    void set_point2(const Complex &amp;arg_point2)
    {
        m_point[1] = arg_point2;
        _check_points();
    }
    void set_point3(const Complex &amp;arg_point3)
    {
        m_point[2] = arg_point3;
        _check_points();
    }
    // get the three points of the Triangle_Complex
    Complex get_point1() const
    {
        return m_point[0];
    }
    Complex get_point2() const
    {
        return m_point[1];
    }
    Complex get_point3() const
    {
        return m_point[2];
    }

    // calculate the area of the Triangle_Complex
    double area()
    {
        double area = 0.0;
        for (int i = 0; i &lt; 3; i++)
        {
            area += (double)m_point[i] * m_point[(i + 1) % 3].get_imaginary_value();
            area -= m_point[i].get_imaginary_value() * (double)m_point[(i + 1) % 3];
        }
        return area / 2.0;
    }

    // print the Triangle_Complex
    // format: (c1, c2, c3)
    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;arg_os, const Triangle_Complex &amp;arg_tri)
    {
        arg_os &lt;&lt; &quot;(&quot;;
        for (int i = 0; i &lt; 3; i++)
        {
            arg_os &lt;&lt; arg_tri.m_point[i];
            if (i &lt; 2)
                arg_os &lt;&lt; &quot;, &quot;;
        }
        arg_os &lt;&lt; &quot;)&quot;;
        return arg_os;
    }
    // read the coordinate of a point from the input,
    // format: (c1, c2, c3) and ignore space
    friend std::istream &amp;operator&gt;&gt;(std::istream &amp;arg_is, Triangle_Complex &amp;arg_tri)
    {
        string temp;
        if (getline(arg_is, temp, '(')) // ignore the first '('
        {
            for (int i = 0; i &lt; 3; i++)
            {
                arg_is &gt;&gt; arg_tri.m_point[i];
                if (i &lt; 2)
                {
                    getline(arg_is, temp, ','); // ignore the ','
                }
            }
            getline(arg_is, temp, ')'); // ignore the last ')'
        }

        // check &amp; correct the Triangle_Complex points to counterclockwise order
        arg_tri._check_points();

        return arg_is;
    }
};

class Equilateral_Triangle_Complex : public Triangle_Complex
// Equilateral Triangle `is-a' Triangle_Complex, so it use inheritance
// use function overloading to implement the different function
// of Equilateral_Triangle_Complex
// details will be discussed in polymorphism (next chapter)
{
public:
    Equilateral_Triangle_Complex(const Complex &amp;arg_point1,
                                 const Complex &amp;arg_point2)
        : Triangle_Complex(arg_point1, arg_point2, arg_point1)
    {
        Complex temp = arg_point2 - arg_point1;
        temp = temp * Complex(0.5, sqrt(3.0) / 2.0); // rotate 60 degree
        m_point[2] = arg_point1 + temp;              // calculate the third point
        _check_points();
    }

    void set_points(const Complex &amp;arg_point1,
                    const Complex &amp;arg_point2)
    {
        m_point[0] = arg_point1;
        m_point[1] = arg_point2;
        Complex temp = arg_point2 - arg_point1;
        temp = temp * Complex(0.5, sqrt(3.0) / 2.0); // rotate 60 degree
        m_point[2] = arg_point1 + temp;              // calculate the third point
        _check_points();
    }

    void set_point1(const Complex &amp;arg_point1)
    {
        // invalid operation
    }
    void set_point2(const Complex &amp;arg_point2)
    {
        // invalid operation
    }
    void set_point3(const Complex &amp;arg_point3)
    {
        // invalid operation
    }
    // read the coordinate of a point from the input,
    // format: (c1, c2, c3) and ignore c3 and spaces
    friend std::istream &amp;operator&gt;&gt;(std::istream &amp;arg_is,
                                    Equilateral_Triangle_Complex &amp;arg_tri)
    {
        string temp;
        if (getline(arg_is, temp, '(')) // ignore the first '('
        {
            for (int i = 0; i &lt; 3; i++)
            {
                if (i &lt; 2)
                {
                    arg_is &gt;&gt; arg_tri.m_point[i];
                    getline(arg_is, temp, ','); // ignore the ','
                }
            }
            getline(arg_is, temp, ')'); // ignore the c3 and last ')'
        }

        // check &amp; correct the Triangle_Complex points to counterclockwise order
        arg_tri._check_points();

        return arg_is;
    }
};

// main function

int main()
{
    Equilateral_Triangle_Complex t(Complex(1, 1), Complex(2, 2));
    cout &lt;&lt; t &lt;&lt; endl;
    cout &lt;&lt; &quot;Area: &quot; &lt;&lt; t.area() &lt;&lt; endl;

    // change the points of the Triangle_Complex
    cin &gt;&gt; t;
    cout &lt;&lt; t &lt;&lt; endl;
    cout &lt;&lt; &quot;Area: &quot; &lt;&lt; t.area() &lt;&lt; endl;

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!---
marp: true
author: Yi-Wen Hung
theme: default
headingDivider: 2
paginate: true
--->
<h1 id="oop-polymorphism-1"><a class="header" href="#oop-polymorphism-1">OOP: Polymorphism (1)</a></h1>
<blockquote>
<p>Slides version: <a href="oop/./lecture11_slides.html">lecture11_slides.html</a>
Website version: <a href="oop/./lecture11.html">lecture11.html</a></p>
</blockquote>
<ul>
<li>What is Polymorphism? and Why do we need it?
<ul>
<li>Example: Bus, Car, and Truck.</li>
</ul>
</li>
</ul>
<ul>
<li>Polymorphism Types
<ul>
<li>Compile time</li>
<li>Run time</li>
</ul>
</li>
<li>Virtual Function
<ul>
<li>Syntax: <code>virtual</code> member function &amp; object pointer</li>
<li>Example:</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>Example 1: Integer &amp; Real</li>
<li>Example 2: Complex Number</li>
<li>Example 3: Integer &amp; Real &amp; Complex Number</li>
<li>Pratices</li>
</ul>
<h2 id="what-is-polymorphism-and-why-do-we-need-it"><a class="header" href="#what-is-polymorphism-and-why-do-we-need-it">What is Polymorphism? and Why do we need it?</a></h2>
<p>Ref: https://www.geeksforgeeks.org/polymorphism-in-c/</p>
<blockquote>
<p>The word polymorphism means having many forms. In simple words, we can define polymorphism as the ability of a message to be displayed in more than one form. 
A real-life example of polymorphism, a person at the same time can have different characteristics. Like a man at the same time is a father, a husband, an employee. 
So the same person posses different behavior in different situations. This is called polymorphism.</p>
</blockquote>
<hr />
<h3 id="example-bus-car-and-truck-4"><a class="header" href="#example-bus-car-and-truck-4">Example: Bus, Car, and Truck</a></h3>
<ul>
<li>A Bus:
<ul>
<li>has 4 wheels</li>
<li>has 20 seats</li>
<li>has 2 doors</li>
<li>has 20 windows</li>
</ul>
</li>
<li>A Car:
<ul>
<li>has 4 wheels</li>
<li>has 4 seats</li>
<li>has 4 doors</li>
<li>has 4 windows</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>A Truck:
<ul>
<li>has 6 wheels</li>
<li>has 2 seats</li>
<li>has 2 doors</li>
<li>has 2 windows</li>
</ul>
</li>
</ul>
<hr />
<h4 id="function-overloading"><a class="header" href="#function-overloading">function overloading</a></h4>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Vehicle
{
public:
    void wheels() {}
    void seats() {}
    void doors() {}
    void windows() {}
};
</code></pre>
<hr />
<pre><code class="language-c++">class Bus : public Vehicle
{
public:
    void wheels()
    {
        cout &lt;&lt; &quot;Wheels: 4&quot; &lt;&lt; endl;
    }
    void seats()
    {
        cout &lt;&lt; &quot;Seats: 20&quot; &lt;&lt; endl;
    }
    void doors()
    {
        cout &lt;&lt; &quot;Doors: 2&quot; &lt;&lt; endl;
    }
    void windows()
    {
        cout &lt;&lt; &quot;Windows: 20&quot; &lt;&lt; endl;
    }
};
</code></pre>
<hr />
<pre><code class="language-c++">class Car : public Vehicle
{
public:
    void wheels()
    {
        cout &lt;&lt; &quot;Wheels: 4&quot; &lt;&lt; endl;
    }
    void seats()
    {
        cout &lt;&lt; &quot;Seats: 4&quot; &lt;&lt; endl;
    }
    void doors()
    {
        cout &lt;&lt; &quot;Doors: 4&quot; &lt;&lt; endl;
    }
    void windows()
    {
        cout &lt;&lt; &quot;Windows: 4&quot; &lt;&lt; endl;
    }
};
</code></pre>
<hr />
<pre><code class="language-c++">class Truck : public Vehicle
{
public:
    void wheels()
    {
        cout &lt;&lt; &quot;Wheels: 6&quot; &lt;&lt; endl;
    }
    void seats()
    {
        cout &lt;&lt; &quot;Seats: 2&quot; &lt;&lt; endl;
    }
    void doors()
    {
        cout &lt;&lt; &quot;Doors: 2&quot; &lt;&lt; endl;
    }
    void windows()
    {
        cout &lt;&lt; &quot;Windows: 2&quot; &lt;&lt; endl;
    }
};
</code></pre>
<hr />
<pre><code class="language-c++">int main()
{
    Bus b;
    Car c;
    Truck t;

    b.wheels();
    b.seats();
    b.doors();
    b.windows();

    c.wheels();
    c.seats();
    c.doors();
    c.windows();

    t.wheels();
    t.seats();
    t.doors();
    t.windows();
}
</code></pre>
<hr />
<p>Output:</p>
<pre><code class="language-console">$ ./a.out
Wheels: 4
Seats: 20
Doors: 2
Windows: 20
Wheels: 4
Seats: 4
Doors: 4
Windows: 4
Wheels: 6
Seats: 2
Doors: 2
Windows: 2
</code></pre>
<hr />
<h4 id="virtual-member-function"><a class="header" href="#virtual-member-function"><code>virtual</code> member function</a></h4>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Vehicle
{
public:
    virtual void wheels() {}
    virtual void seats() {}
    virtual void doors() {}
    virtual void windows() {}
};
</code></pre>
<hr />
<pre><code class="language-c++">class Bus : public Vehicle
{
public:
    void wheels()
    {
        cout &lt;&lt; &quot;Wheels: 4&quot; &lt;&lt; endl;
    }
    void seats()
    {
        cout &lt;&lt; &quot;Seats: 20&quot; &lt;&lt; endl;
    }
    void doors()
    {
        cout &lt;&lt; &quot;Doors: 2&quot; &lt;&lt; endl;
    }
    void windows()
    {
        cout &lt;&lt; &quot;Windows: 20&quot; &lt;&lt; endl;
    }
};
</code></pre>
<hr />
<pre><code class="language-c++">class Car : public Vehicle
{
public:
    void wheels()
    {
        cout &lt;&lt; &quot;Wheels: 4&quot; &lt;&lt; endl;
    }
    void seats()
    {
        cout &lt;&lt; &quot;Seats: 4&quot; &lt;&lt; endl;
    }
    void doors()
    {
        cout &lt;&lt; &quot;Doors: 4&quot; &lt;&lt; endl;
    }
    void windows()
    {
        cout &lt;&lt; &quot;Windows: 4&quot; &lt;&lt; endl;
    }
};
</code></pre>
<hr />
<pre><code class="language-c++">class Truck : public Vehicle
{
public:
    void wheels()
    {
        cout &lt;&lt; &quot;Wheels: 6&quot; &lt;&lt; endl;
    }
    void seats()
    {
        cout &lt;&lt; &quot;Seats: 2&quot; &lt;&lt; endl;
    }
    void doors()
    {
        cout &lt;&lt; &quot;Doors: 2&quot; &lt;&lt; endl;
    }
    void windows()
    {
        cout &lt;&lt; &quot;Windows: 2&quot; &lt;&lt; endl;
    }
};
</code></pre>
<hr />
<pre><code class="language-c++">int main()
{
    Vehicle *v[3];    // array of pointers to Vehicle
                      // used for polymorphism
    v[0] = new Bus;   // dynamically allocate Bus
    v[1] = new Car;   // dynamically allocate Car
    v[2] = new Truck; // dynamically allocate Truck

    for (int i = 0; i &lt; 3; i++)
    {
        v[i]-&gt;wheels();
        v[i]-&gt;seats();
        v[i]-&gt;doors();
        v[i]-&gt;windows();
    }
    
    for (int i = 0; i &lt; 3; i++)
    {
        delete v[i];
    }
}
</code></pre>
<hr />
<p>Output:</p>
<pre><code class="language-console">$ ./a.out
Wheels: 4
Seats: 20
Doors: 2
Windows: 20
Wheels: 4
Seats: 4
Doors: 4
Windows: 4
Wheels: 6
Seats: 2
Doors: 2
Windows: 2
</code></pre>
<h2 id="polymorphism-types"><a class="header" href="#polymorphism-types">Polymorphism Types</a></h2>
<ul>
<li>In C++ polymorphism is mainly divided into two types:
<ul>
<li>Compile time Polymorphism</li>
<li>Runtime Polymorphism</li>
</ul>
</li>
</ul>
<p><img src="oop/img/Polymorphism-in-CPP.png" alt="bg right fit" /></p>
<hr />
<h3 id="compile-time-polymorphism-functionoperator-overloading"><a class="header" href="#compile-time-polymorphism-functionoperator-overloading">Compile time Polymorphism (Function/Operator Overloading)</a></h3>
<pre><code class="language-c++">// C++ program for function overloading
#include &lt;iostream&gt;

using namespace std;
class Geeks
{
public:
    // function with 1 int parameter
    void func(int x)
    {
        cout &lt;&lt; &quot;value of x is &quot; &lt;&lt; x &lt;&lt; endl;
    }

    // function with same name but 1 double parameter
    void func(double x)
    {
        cout &lt;&lt; &quot;value of x is &quot; &lt;&lt; x &lt;&lt; endl;
    }

    // function with same name and 2 int parameters
    void func(int x, int y)
    {
        cout &lt;&lt; &quot;value of x and y is &quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; endl;
    }
};
</code></pre>
<hr />
<pre><code class="language-c++">int main()
{

    Geeks obj1;

    // Which function is called will depend on the parameters passed
    // The first 'func' is called
    obj1.func(7);

    // The second 'func' is called
    obj1.func(9.132);

    // The third 'func' is called
    obj1.func(85, 64);
    return 0;
}
</code></pre>
<hr />
<h3 id="runtime-polymorphism-virtual-function-with-object-pointer"><a class="header" href="#runtime-polymorphism-virtual-function-with-object-pointer">Runtime Polymorphism (Virtual Function with object pointer)</a></h3>
<pre><code class="language-c++">// C++ program for function overriding

#include &lt;iostream&gt;
using namespace std;

class base
{
public:
    virtual void print()
    {
        cout &lt;&lt; &quot;print base class&quot; &lt;&lt; endl;
    }

    void show()
    {
        cout &lt;&lt; &quot;show base class&quot; &lt;&lt; endl;
    }
};
</code></pre>
<hr />
<pre><code class="language-c++">class derived : public base
{
public:
    void print() // print () is already virtual function in derived class,
                 // we could also declared as virtual void print () explicitly
    {
        cout &lt;&lt; &quot;print derived class&quot; &lt;&lt; endl;
    }

    void show()
    {
        cout &lt;&lt; &quot;show derived class&quot; &lt;&lt; endl;
    }
};
</code></pre>
<hr />
<pre><code class="language-c++">// main function
int main()
{
    base *bptr;
    derived d;
    bptr = &amp;d;

    // virtual function, binded at runtime (Runtime polymorphism)
    bptr-&gt;print();

    // Non-virtual function, binded at compile time
    bptr-&gt;show();

    return 0;
}
</code></pre>
<h2 id="virtual-function"><a class="header" href="#virtual-function">Virtual Function</a></h2>
<p>Ref: https://www.geeksforgeeks.org/virtual-functions-and-runtime-polymorphism-in-c-set-1-introduction/</p>
<blockquote>
<p>A <strong>virtual</strong> function is a <em>member</em> function which is declared in the <em>base</em> class using the keyword <code>virtual</code> and is re-defined (Overriden) by the <em>derived</em> class.</p>
</blockquote>
<hr />
<h3 id="syntax-virtual-member-function--object-pointer"><a class="header" href="#syntax-virtual-member-function--object-pointer">Syntax: <code>virtual</code> member function &amp; object pointer</a></h3>
<pre><code class="language-c++">class base
{
public:
    virtual void a() {} // virtual function
};
class derived : public base
{
public:
    void a() {} // non-virtual function, overridden by derived class
};
</code></pre>
<hr />
<pre><code class="language-c++">int main()
{
    base *b_ptr;
    derived d;
    b_ptr = &amp;d; // object pointer of derived class

    // virtual function, binded at runtime (Runtime polymorphism)
    b_ptr-&gt;a();

    return 0;
}
</code></pre>
<hr />
<h3 id="example-1"><a class="header" href="#example-1">Example 1:</a></h3>
<pre><code class="language-c++">// C++ program for function overriding

#include &lt;iostream&gt;
using namespace std;

class base
{
public:
    virtual void print()
    {
        cout &lt;&lt; &quot;print base class&quot; &lt;&lt; endl;
    }

    void show()
    {
        cout &lt;&lt; &quot;show base class&quot; &lt;&lt; endl;
    }
};
</code></pre>
<hr />
<pre><code class="language-c++">class derived : public base
{
public:
    void print() // print () is already virtual function in derived class,
                 // we could also declared as virtual void print () explicitly
    {
        cout &lt;&lt; &quot;print derived class&quot; &lt;&lt; endl;
    }

    void show()
    {
        cout &lt;&lt; &quot;show derived class&quot; &lt;&lt; endl;
    }
};
</code></pre>
<hr />
<pre><code class="language-c++">// main function
int main()
{
    base *bptr;
    derived d;
    bptr = &amp;d;

    // virtual function, binded at runtime (Runtime polymorphism)
    bptr-&gt;print();

    // Non-virtual function, binded at compile time
    bptr-&gt;show();

    return 0;
}
</code></pre>
<hr />
<h3 id="example-2"><a class="header" href="#example-2">Example 2:</a></h3>
<pre><code class="language-c++">class Employee
{
public:
    virtual void raiseSalary()
    {
        /* common raise salary code */
    }

    virtual void promote()
    { 
        /* common promote code */
    }
};
</code></pre>
<hr />
<pre><code class="language-c++">class Manager : public Employee
{
    virtual void raiseSalary()
    {
        /* Manager specific raise salary code, may contain
        increment of manager specific incentives */
    }

    virtual void promote()
    {
        /* Manager specific promote */
    }
};

// Similarly, there may be other types of employees
</code></pre>
<hr />
<pre><code class="language-c++">// We need a very simple function
// to increment the salary of all employees
// Note that emp[] is an array of pointers
// and actual pointed objects can
// be any type of employees.
// This function should ideally
// be in a class like Organization,
// we have made it global to keep things simple
void globalRaiseSalary(Employee *emp[], int n)
{
    for (int i = 0; i &lt; n; i++)
    {
        // Polymorphic Call: Calls raiseSalary()
        // according to the actual object, not
        // according to the type of pointer
        emp[i]-&gt;raiseSalary();
    }
}
</code></pre>
<h2 id="example-1-integer--real-a-hrefooplecture11_ex1htmlsourcea"><a class="header" href="#example-1-integer--real-a-hrefooplecture11_ex1htmlsourcea">Example 1: Integer &amp; Real [<a href="oop/./lecture11_ex1.html">Source</a>]</a></h2>
<h2 id="example-2-complex-number-a-hrefooplecture11_ex2htmlsourcea"><a class="header" href="#example-2-complex-number-a-hrefooplecture11_ex2htmlsourcea">Example 2: Complex Number [<a href="oop/./lecture11_ex2.html">Source</a>]</a></h2>
<h2 id="example-3-integer--real--complex-number-a-hrefooplecture11_ex3htmlsourcea"><a class="header" href="#example-3-integer--real--complex-number-a-hrefooplecture11_ex3htmlsourcea">Example 3: Integer &amp; Real &amp; Complex Number [<a href="oop/./lecture11_ex3.html">Source</a>]</a></h2>
<h2 id="pratices-5"><a class="header" href="#pratices-5">Pratices</a></h2>
<ul>
<li>
<p>Design a class hierarchy for Fruit.</p>
<ul>
<li>Contains: Grape, Apple, Orange</li>
<li>Implement with based class <code>Fruit</code></li>
<li>Use <code>virtual</code> function to provide universal <code>print()</code>, <code>color()</code> functions</li>
</ul>
</li>
<li>
<p>Design a class hierarchy for Quadrilateral. </p>
<ul>
<li>Contains: Square, Rectangle, Rhombus, Parallelogram</li>
<li>Implement with based class <code>Quadrilateral</code></li>
<li>Use <code>virtual</code> function to provide universal <code>print()</code>, <code>area()</code> functions</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-1-integer--real-1"><a class="header" href="#example-1-integer--real-1">Example 1: Integer &amp; Real</a></h1>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

using namespace std;

class Number
{
public:
    Number()
    {
    }
    virtual double get_value() const
    {
        return 0.0;
    }
    virtual string get_string() const
    {
        return &quot;&quot;;
    }
    virtual void set_value(double value)
    {
    }
};

class Integer : public Number
{
protected:
    int m_int_value;

public:
    Integer(int arg_int_value = 0) : m_int_value(arg_int_value)
    {
    }
    Integer(const Integer &amp;arg_int) : m_int_value(arg_int.m_int_value)
    {
    }
    operator int() const
    {
        return m_int_value;
    }
    operator double() const
    {
        return (double)m_int_value;
    }
    double get_value() const
    {
        return (double)m_int_value;
    }
    string get_string() const
    {
        return to_string(m_int_value);
    }
    Integer &amp;operator=(const Integer &amp;arg_int)
    {
        m_int_value = arg_int.m_int_value;
        return *this;
    }
    void set_value(int arg_int_value) // int version
    {
        m_int_value = arg_int_value;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Integer &amp;arg_integer)
    {
        arg_os &lt;&lt; arg_integer.get_string();
        return arg_os;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Integer &amp;arg_integer)
    {
        arg_is &gt;&gt; arg_integer.m_int_value;
        return arg_is;
    }
};

// Real is a Integer
class Real : public Integer
{
protected:
    double m_after_decimal;

public:
    Real(double arg_value = 0.0) : Integer((int)arg_value),
                                   m_after_decimal(arg_value - (int)arg_value)
    {
    }
    Real(const Real &amp;arg_real) : Integer(arg_real),
                                 m_after_decimal(arg_real.m_after_decimal)
    {
    }
    operator double() const
    {
        return m_after_decimal + (double)m_int_value;
    }
    double get_value() const
    {
        return m_after_decimal + (double)m_int_value;
    }
    string get_string() const
    {
        return to_string(Real::get_value());
    }
    Real &amp;operator=(const Real &amp;arg_real)
    {
        m_int_value = arg_real.m_int_value;
        m_after_decimal = arg_real.m_after_decimal;
        return *this;
    }
    void set_value(double arg_value) // double version
    {
        m_int_value = (int)arg_value;
        m_after_decimal = arg_value - m_int_value;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Real &amp;arg_real)
    {
        arg_os &lt;&lt; (double)arg_real;
        return arg_os;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Real &amp;arg_real)
    {
        double temp_double;
        arg_is &gt;&gt; temp_double;
        arg_real.set_value(temp_double);
        return arg_is;
    }
};

int main()
{
    Number *p[2];

    p[0] = new Integer(10);
    p[1] = new Real(10.5);

    cout &lt;&lt; &quot;virtual function call&quot; &lt;&lt; endl;
    for (int i = 0; i &lt; 2; i++)
    {
        cout &lt;&lt; &quot;p[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; p[i]-&gt;get_string() &lt;&lt; endl;
    }

    cout &lt;&lt; &quot;address of object&quot; &lt;&lt; endl;
    for (int i = 0; i &lt; 2; i++)
    {
        cout &lt;&lt; &quot;p[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; p[i] &lt;&lt; endl;
    }

    for (int i = 0; i &lt; 2; i++)
    {
        delete p[i];
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-2-complex-number-1"><a class="header" href="#example-2-complex-number-1">Example 2: Complex Number</a></h1>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

using namespace std;

class Number
{
public:
    Number()
    {
    }
    virtual double get_value() const
    {
        return 0.0;
    }
    virtual string get_string() const
    {
        return &quot;&quot;;
    }
    virtual void set_value(string arg_s)
    {
    }
};

class Integer : public Number
{
protected:
    int m_int_value;

public:
    Integer(int arg_int_value = 0) : m_int_value(arg_int_value)
    {
    }
    Integer(const Integer &amp;arg_int) : m_int_value(arg_int.m_int_value)
    {
    }
    operator int() const
    {
        return m_int_value;
    }
    operator double() const
    {
        return (double)m_int_value;
    }
    double get_value() const
    {
        return (double)m_int_value;
    }
    string get_string() const
    {
        return to_string(m_int_value);
    }
    Integer &amp;operator=(const Integer &amp;arg_int)
    {
        m_int_value = arg_int.m_int_value;
        return *this;
    }
    void set_value(string arg_int_value) // int version
    {
        stringstream ss(arg_int_value); // use operator&gt;&gt; to convert string to Integer
        ss &gt;&gt; m_int_value;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Integer &amp;arg_integer)
    {
        arg_os &lt;&lt; arg_integer.get_string();
        return arg_os;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Integer &amp;arg_integer)
    {
        arg_is &gt;&gt; arg_integer.m_int_value;
        return arg_is;
    }
};

// Real is a Integer
class Real : public Integer
{
protected:
    double m_after_decimal;

public:
    Real(double arg_value = 0.0) : Integer((int)arg_value),
                                   m_after_decimal(arg_value - (int)arg_value)
    {
    }
    Real(const Real &amp;arg_real) : Integer(arg_real),
                                 m_after_decimal(arg_real.m_after_decimal)
    {
    }
    operator double() const
    {
        return m_after_decimal + (double)m_int_value;
    }
    double get_value() const
    {
        return m_after_decimal + (double)m_int_value;
    }
    string get_string() const
    {
        return to_string(Real::get_value());
    }
    Real &amp;operator=(const Real &amp;arg_real)
    {
        m_int_value = arg_real.m_int_value;
        m_after_decimal = arg_real.m_after_decimal;
        return *this;
    }
    void set_value(string arg_value) // double version
    {
        double temp_double;
        temp_double = stod(arg_value);
        m_int_value = (int)temp_double;
        m_after_decimal = temp_double - (double)m_int_value;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Real &amp;arg_real)
    {
        arg_os &lt;&lt; (double)arg_real;
        return arg_os;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Real &amp;arg_real)
    {
        string temp_string;
        arg_is &gt;&gt; temp_string;
        arg_real.set_value(temp_string);
        return arg_is;
    }
};

class Complex : public Real
{
private:
    Real m_imaginary;

public:
    Complex(double arg_real_value = 0.0,
            double arg_imaginary_value = 0.0)
        : Real(arg_real_value),
          m_imaginary(arg_imaginary_value)
    {
    }
    Complex(const Complex &amp;arg_complex)
        : Real(arg_complex),
          m_imaginary(arg_complex.m_imaginary)
    {
    }
    double get_value() const
    {
        cout &lt;&lt; &quot;not implemented&quot; &lt;&lt; endl;
        return 0.0;
    }
    string get_string() const
    {
        return to_string((double)*this) + &quot; + &quot; + m_imaginary.get_string() + &quot;i&quot;;
    }
    Complex &amp;operator=(const Complex &amp;arg_complex)
    {
        Real::operator=(arg_complex);
        m_imaginary = arg_complex.m_imaginary;
        return *this;
    }
    void set_value(string arg_value) // complex version
    {
        size_t plus_pos = arg_value.find(&quot;+&quot;);
        if (plus_pos != string::npos)
        {
            Real::set_value(arg_value.substr(0, plus_pos));
        }
        size_t i_pos = arg_value.find(&quot;i&quot;);
        if (i_pos != string::npos)
        {
            m_imaginary.set_value(arg_value.substr(plus_pos + 1, i_pos - plus_pos - 1));
        }
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex &amp;arg_complex)
    {
        arg_os &lt;&lt; arg_complex.get_string();
        return arg_os;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Complex &amp;arg_complex)
    {
        string temp_string;
        getline(arg_is, temp_string);
        arg_complex.set_value(temp_string);
        return arg_is;
    }
};

int main()
{
    Number *p[3];

    p[0] = new Integer(10);
    p[1] = new Real(10.5);
    p[2] = new Complex(10.5, 3.5);

    cout &lt;&lt; &quot;virtual function call&quot; &lt;&lt; endl;
    for (int i = 0; i &lt; 3; i++)
    {
        cout &lt;&lt; &quot;p[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; p[i]-&gt;get_string() &lt;&lt; endl;
    }

    cout &lt;&lt; &quot;address of object&quot; &lt;&lt; endl;
    for (int i = 0; i &lt; 3; i++)
    {
        cout &lt;&lt; &quot;p[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; p[i] &lt;&lt; endl;
    }

    p[0]-&gt;set_value(&quot;20&quot;);
    p[1]-&gt;set_value(&quot;20.5&quot;);
    p[2]-&gt;set_value(&quot;20.5 + 3.5i&quot;);

    cout &lt;&lt; &quot;set value by virtual function&quot; &lt;&lt; endl;
    for (int i = 0; i &lt; 3; i++)
    {
        cout &lt;&lt; &quot;p[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; p[i]-&gt;get_string() &lt;&lt; endl;
    }

    for (int i = 0; i &lt; 3; i++)
    {
        delete p[i];
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-3-integer--real--complex-number-1"><a class="header" href="#example-3-integer--real--complex-number-1">Example 3: Integer &amp; Real &amp; Complex Number</a></h1>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

using namespace std;

class Number
{
public:
    Number()
    {
    }
    virtual double get_value() const
    {
        return 0.0;
    }
    virtual string get_string() const
    {
        return &quot;&quot;;
    }
    virtual void set_value(string arg_s)
    {
    }
};

class Integer : public Number
{
protected:
    int m_int_value;

public:
    Integer(int arg_int_value = 0) : m_int_value(arg_int_value)
    {
    }
    Integer(const Integer &amp;arg_int) : m_int_value(arg_int.m_int_value)
    {
    }
    operator int() const
    {
        return m_int_value;
    }
    operator double() const
    {
        return (double)m_int_value;
    }
    double get_value() const
    {
        return (double)m_int_value;
    }
    string get_string() const
    {
        return to_string(m_int_value);
    }
    Integer &amp;operator=(const Integer &amp;arg_int)
    {
        m_int_value = arg_int.m_int_value;
        return *this;
    }
    void set_value(string arg_int_value) // int version
    {
        stringstream ss(arg_int_value); // use operator&gt;&gt; to convert string to Integer
        ss &gt;&gt; m_int_value;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Integer &amp;arg_integer)
    {
        arg_os &lt;&lt; arg_integer.get_string();
        return arg_os;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Integer &amp;arg_integer)
    {
        arg_is &gt;&gt; arg_integer.m_int_value;
        return arg_is;
    }
};

// Real is a Integer
class Real : public Integer
{
protected:
    double m_after_decimal;

public:
    Real(double arg_value = 0.0) : Integer((int)arg_value),
                                   m_after_decimal(arg_value - (int)arg_value)
    {
    }
    Real(const Real &amp;arg_real) : Integer(arg_real),
                                 m_after_decimal(arg_real.m_after_decimal)
    {
    }
    operator double() const
    {
        return m_after_decimal + (double)m_int_value;
    }
    double get_value() const
    {
        return m_after_decimal + (double)m_int_value;
    }
    string get_string() const
    {
        return to_string(Real::get_value());
    }
    Real &amp;operator=(const Real &amp;arg_real)
    {
        m_int_value = arg_real.m_int_value;
        m_after_decimal = arg_real.m_after_decimal;
        return *this;
    }
    void set_value(string arg_value) // double version
    {
        double temp_double;
        temp_double = stod(arg_value);
        m_int_value = (int)temp_double;
        m_after_decimal = temp_double - (double)m_int_value;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Real &amp;arg_real)
    {
        arg_os &lt;&lt; (double)arg_real;
        return arg_os;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Real &amp;arg_real)
    {
        string temp_string;
        arg_is &gt;&gt; temp_string;
        arg_real.set_value(temp_string);
        return arg_is;
    }
};

class Imaginary
{
protected:
    double m_imaginary_value;

public:
    Imaginary(double arg_imaginary_value = 0.0) : m_imaginary_value(arg_imaginary_value)
    {
    }
    Imaginary(const Imaginary &amp;arg_imaginary) : m_imaginary_value(arg_imaginary.m_imaginary_value)
    {
    }
    Imaginary &amp;operator=(const Imaginary &amp;arg_imaginary)
    {
        m_imaginary_value = arg_imaginary.m_imaginary_value;
        return *this;
    }
    double get_value() const // use the same function as Number to
                             // maintain the same interface
    {
        return m_imaginary_value;
    }
    string get_string() const
    {
        return to_string(m_imaginary_value) + &quot;i&quot;;
    }
    void set_value(string arg_imaginary_value)
    {
        m_imaginary_value = stod(arg_imaginary_value);
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Imaginary &amp;arg_imaginary)
    {
        arg_os &lt;&lt; arg_imaginary.get_string();
        return arg_os;
    }
};

class Complex : public Real, public Imaginary
{
public:
    Complex(double arg_real_value = 0.0,
            double arg_imaginary_value = 0.0)
        : Real(arg_real_value),
          Imaginary(arg_imaginary_value)
    {
    }
    Complex(const Complex &amp;arg_complex)
        : Real(arg_complex),
          Imaginary(arg_complex)
    {
    }
    double get_value() const
    {
        cout &lt;&lt; &quot;not implemented&quot; &lt;&lt; endl;
        return 0.0;
    }
    string get_string() const
    {
        return Real::get_string() + &quot; + &quot; + Imaginary::get_string();
    }
    Complex &amp;operator=(const Complex &amp;arg_complex)
    {
        Real::operator=(arg_complex);
        Imaginary::operator=(arg_complex);
        return *this;
    }
    void set_value(string arg_value) // complex version
    {
        size_t plus_pos = arg_value.find(&quot;+&quot;);
        if (plus_pos != string::npos)
        {
            Real::set_value(arg_value.substr(0, plus_pos));
        }
        size_t i_pos = arg_value.find(&quot;i&quot;);
        if (i_pos != string::npos)
        {
            Imaginary::set_value(arg_value.substr(plus_pos + 1, i_pos - plus_pos - 1));
        }
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex &amp;arg_complex)
    {
        arg_os &lt;&lt; arg_complex.get_string();
        return arg_os;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Complex &amp;arg_complex)
    {
        string temp_string;
        getline(arg_is, temp_string);
        arg_complex.set_value(temp_string);
        return arg_is;
    }
};

int main()
{
    Number *p[3];

    p[0] = new Integer(10);
    p[1] = new Real(10.5);
    p[2] = new Complex(10.5, 3.5);

    cout &lt;&lt; &quot;virtual function call&quot; &lt;&lt; endl;
    for (int i = 0; i &lt; 3; i++)
    {
        cout &lt;&lt; &quot;p[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; p[i]-&gt;get_string() &lt;&lt; endl;
    }

    cout &lt;&lt; &quot;address of object&quot; &lt;&lt; endl;
    for (int i = 0; i &lt; 3; i++)
    {
        cout &lt;&lt; &quot;p[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; p[i] &lt;&lt; endl;
    }

    p[0]-&gt;set_value(&quot;20&quot;);
    p[1]-&gt;set_value(&quot;20.5&quot;);
    p[2]-&gt;set_value(&quot;20.5 + 3.5i&quot;);

    cout &lt;&lt; &quot;set value by virtual function&quot; &lt;&lt; endl;
    for (int i = 0; i &lt; 3; i++)
    {
        cout &lt;&lt; &quot;p[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; p[i]-&gt;get_string() &lt;&lt; endl;
    }

    for (int i = 0; i &lt; 3; i++)
    {
        delete p[i];
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!---
marp: true
author: Yi-Wen Hung
theme: default
headingDivider: 2
paginate: true
--->
<h1 id="oop-polymorphism-2"><a class="header" href="#oop-polymorphism-2">OOP: Polymorphism (2)</a></h1>
<blockquote>
<p>Slides version: <a href="oop/./lecture12_slides.html">lecture12_slides.html</a>
Website version: <a href="oop/./lecture12.html">lecture12.html</a></p>
</blockquote>
<ul>
<li>Recap Polymorphism
<ul>
<li>Example: Bus, Car, and Truck.</li>
<li>Polymorphism Types
<ul>
<li>Compile time, Run time</li>
</ul>
</li>
<li>Pointer to Polymorphic Objects
<ul>
<li>What is a pointer? and how to use it?</li>
<li>How a pointer to a polymorphic object works? (Late binding)</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>Polymorphism in Software Engineering
<ul>
<li>Pros &amp; Cons</li>
<li>Compile time &amp; Run time</li>
</ul>
</li>
<li>Example 1: Integer &amp; Real &amp; Complex Number Calculator</li>
<li>Example 2: Complex Number &amp; Triangles</li>
<li>Lab 6: Complex Number Calculator</li>
</ul>
<h2 id="recap-polymorphism"><a class="header" href="#recap-polymorphism">Recap Polymorphism</a></h2>
<h3 id="example-bus-car-and-truck-5"><a class="header" href="#example-bus-car-and-truck-5">Example: Bus, Car, and Truck</a></h3>
<ul>
<li>A Bus:
<ul>
<li>has 4 wheels</li>
<li>has 20 seats</li>
<li>has 2 doors</li>
<li>has 20 windows</li>
</ul>
</li>
<li>A Car:
<ul>
<li>has 4 wheels</li>
<li>has 4 seats</li>
<li>has 4 doors</li>
<li>has 4 windows</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>A Truck:
<ul>
<li>has 6 wheels</li>
<li>has 2 seats</li>
<li>has 2 doors</li>
<li>has 2 windows</li>
</ul>
</li>
</ul>
<hr />
<h3 id="polymorphism-types-1"><a class="header" href="#polymorphism-types-1">Polymorphism Types</a></h3>
<ul>
<li>In C++ polymorphism is mainly divided into two types:
<ul>
<li>Compile time Polymorphism</li>
<li>Runtime Polymorphism</li>
</ul>
</li>
</ul>
<p><img src="oop/img/Polymorphism-in-CPP.png" alt="bg right fit" /></p>
<hr />
<h3 id="compile-time-polymorphism-functionoperator-overloading-1"><a class="header" href="#compile-time-polymorphism-functionoperator-overloading-1">Compile time Polymorphism (Function/Operator Overloading)</a></h3>
<pre><code class="language-c++">// C++ program for function overloading
#include &lt;iostream&gt;

using namespace std;
class Geeks
{
public:
    // function with 1 int parameter
    void func(int x)
    {
        cout &lt;&lt; &quot;value of x is &quot; &lt;&lt; x &lt;&lt; endl;
    }

    // function with same name but 1 double parameter
    void func(double x)
    {
        cout &lt;&lt; &quot;value of x is &quot; &lt;&lt; x &lt;&lt; endl;
    }

    // function with same name and 2 int parameters
    void func(int x, int y)
    {
        cout &lt;&lt; &quot;value of x and y is &quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; endl;
    }
};
</code></pre>
<hr />
<pre><code class="language-c++">int main()
{

    Geeks obj1;

    // Which function is called will depend on the parameters passed
    // The first 'func' is called
    obj1.func(7);

    // The second 'func' is called
    obj1.func(9.132);

    // The third 'func' is called
    obj1.func(85, 64);
    return 0;
}
</code></pre>
<hr />
<h3 id="runtime-polymorphism-virtual-function-with-object-pointer-1"><a class="header" href="#runtime-polymorphism-virtual-function-with-object-pointer-1">Runtime Polymorphism (Virtual Function with object pointer)</a></h3>
<pre><code class="language-c++">// C++ program for function overriding

#include &lt;iostream&gt;
using namespace std;

class base
{
public:
    virtual void print()
    {
        cout &lt;&lt; &quot;print base class&quot; &lt;&lt; endl;
    }

    void show()
    {
        cout &lt;&lt; &quot;show base class&quot; &lt;&lt; endl;
    }
};
</code></pre>
<hr />
<pre><code class="language-c++">class derived : public base
{
public:
    void print() // print () is already virtual function in derived class,
                 // we could also declared as virtual void print () explicitly
    {
        cout &lt;&lt; &quot;print derived class&quot; &lt;&lt; endl;
    }

    void show()
    {
        cout &lt;&lt; &quot;show derived class&quot; &lt;&lt; endl;
    }
};
</code></pre>
<hr />
<pre><code class="language-c++">// main function
int main()
{
    base *bptr;
    derived d;
    bptr = &amp;d;

    // virtual function, binded at runtime (Runtime polymorphism)
    bptr-&gt;print();

    // Non-virtual function, binded at compile time
    bptr-&gt;show();

    return 0;
}
</code></pre>
<hr />
<h3 id="pointer-to-polymorphic-objects"><a class="header" href="#pointer-to-polymorphic-objects">Pointer to Polymorphic Objects</a></h3>
<p>Ref: <a href="https://www.geeksforgeeks.org/virtual-function-cpp">Virtual Function in C++</a></p>
<p>Consider the example:</p>
<pre><code class="language-c++">// CPP program to illustrate
// working of Virtual Functions
#include &lt;iostream&gt;
using namespace std;

class base
{
public:
    void fun_1() { cout &lt;&lt; &quot;base-1\n&quot;; }
    virtual void fun_2() { cout &lt;&lt; &quot;base-2\n&quot;; }
    virtual void fun_3() { cout &lt;&lt; &quot;base-3\n&quot;; }
    virtual void fun_4() { cout &lt;&lt; &quot;base-4\n&quot;; }
};

class derived : public base
{
public:
    void fun_1() { cout &lt;&lt; &quot;derived-1\n&quot;; }
    void fun_2() { cout &lt;&lt; &quot;derived-2\n&quot;; }
    void fun_4(int x) { cout &lt;&lt; &quot;derived-4\n&quot;; }
};
</code></pre>
<p><img src="oop/img/VirtualFunctionInC.png" alt="bg right fit" /></p>
<hr />
<h4 id="what-is-a-pointer-and-how-to-use-it"><a class="header" href="#what-is-a-pointer-and-how-to-use-it">What is a pointer? and how to use it?</a></h4>
<p>Ref: <a href="https://www.geeksforgeeks.org/pointers-in-c-and-c-set-1-introduction-arithmetic-and-array">Pointer in C++</a></p>
<blockquote>
<p>Pointers store address of variables or a memory location. </p>
</blockquote>
<p><img src="oop/img/How-Pointer-Works-In-C.png" alt="" /></p>
<hr />
<h4 id="example-pointer"><a class="header" href="#example-pointer">Example: Pointer</a></h4>
<pre><code class="language-c++">// C++ program to demonstrate use of * for pointers in C++
#include &lt;iostream&gt;
using namespace std;
int main()
{
    // A normal integer variable
    int Var = 10;
    // A pointer variable that holds address of var.
    int *ptr = &amp;Var;
    // This line prints value at address stored in ptr.
    // Value stored is value of variable &quot;var&quot;
    cout &lt;&lt; &quot;Value of Var = &quot; &lt;&lt; *ptr &lt;&lt; endl;
    // The output of this line may be different in different
    // runs even on same machine.
    cout &lt;&lt; &quot;Address of Var = &quot; &lt;&lt; ptr &lt;&lt; endl;
    // We can also use ptr as lvalue (Left hand
    // side of assignment)
    *ptr = 20; // Value at address is now 20
    // This prints 20
    cout &lt;&lt; &quot;After doing *ptr = 20, *ptr is &quot; &lt;&lt; *ptr &lt;&lt; endl;
    return 0;
}
// This code is contributed by
// shubhamsingh10
</code></pre>
<hr />
<p>Output:</p>
<pre><code class="language-console">Value of Var = 10
Address of Var = 0x7fffa057dd4
After doing *ptr = 20, *ptr is 20
</code></pre>
<p><img src="oop/img/pointers-in-c.png" alt="bg right fit" /></p>
<hr />
<h4 id="how-a-pointer-to-a-polymorphic-object-works-late-binding"><a class="header" href="#how-a-pointer-to-a-polymorphic-object-works-late-binding">How a pointer to a polymorphic object works? (Late binding)</a></h4>
<p>Ref: <a href="https://www.geeksforgeeks.org/virtual-functions-and-runtime-polymorphism-in-c-set-1-introduction">Virtual Functions and Runtime Polymorphism in C++</a></p>
<p><img src="oop/img/VirtualFunctionInC.png" alt="bg right fit" /></p>
<p>The compiler maintains two things to serve this purpose:</p>
<ol>
<li><em>vtable</em>: A table of function pointers, maintained per class. </li>
<li><em>vptr</em>: A pointer to vtable, maintained per object instance.</li>
</ol>
<hr />
<p>Consider the example:</p>
<pre><code class="language-c++">// CPP program to illustrate
// working of Virtual Functions
#include &lt;iostream&gt;
using namespace std;

class base
{
public:
    void fun_1() { cout &lt;&lt; &quot;base-1\n&quot;; }
    virtual void fun_2() { cout &lt;&lt; &quot;base-2\n&quot;; }
    virtual void fun_3() { cout &lt;&lt; &quot;base-3\n&quot;; }
    virtual void fun_4() { cout &lt;&lt; &quot;base-4\n&quot;; }
};

class derived : public base
{
public:
    void fun_1() { cout &lt;&lt; &quot;derived-1\n&quot;; }
    void fun_2() { cout &lt;&lt; &quot;derived-2\n&quot;; }
    void fun_4(int x) { cout &lt;&lt; &quot;derived-4\n&quot;; }
};
</code></pre>
<p><img src="oop/img/VirtualFunctionInC.png" alt="bg right fit" /></p>
<hr />
<p>On the runtime:</p>
<pre><code class="language-c++">int main()
{
    base *p;
    derived obj1;
    p = &amp;obj1;

    // Early binding because fun1() is non-virtual
    // in base
    p-&gt;fun_1();

    // Late binding (RTP)
    p-&gt;fun_2();

    // Late binding (RTP)
    p-&gt;fun_3();

    // Late binding (RTP)
    p-&gt;fun_4();

    // Early binding but this function call is
    // illegal (produces error) because pointer
    // is of base type and function is of
    // derived class
    // p-&gt;fun_4(5);

    return 0;
}
</code></pre>
<p><img src="oop/img/VirtualFunctionInC_run.png" alt="bg right fit" /></p>
<h2 id="polymorphism-in-software-engineering"><a class="header" href="#polymorphism-in-software-engineering">Polymorphism in Software Engineering</a></h2>
<p>Ref: https://en.wikipedia.org/wiki/Polymorphism_(computer_science)</p>
<blockquote>
<p>Polymorphism is the provision of a single interface to entities of different types<a href="http://www.stroustrup.com/glossary.html#Gpolymorphism">1</a> or the use of a single symbol to represent multiple different types.<a href="https://doi.org/10.1145%2F6041.6042">2</a> 
The concept is borrowed from a principle in biology where an organism or species can have many different forms or stages.<a href="https://docs.oracle.com/javase/tutorial/java/IandI/polymorphism.html">3</a></p>
</blockquote>
<hr />
<h3 id="pros--cons-of-polymorphism"><a class="header" href="#pros--cons-of-polymorphism">Pros &amp; Cons of Polymorphism</a></h3>
<h4 id="pros"><a class="header" href="#pros">Pros</a></h4>
<ul>
<li>Reuse codes with various types of objects.</li>
<li>Use the same code/interface to work with different types of objects.</li>
<li>Use functions when the application is running.</li>
</ul>
<hr />
<h4 id="cons"><a class="header" href="#cons">Cons</a></h4>
<blockquote>
<p>One of the disadvantages of polymorphism is that developers find it difficult to implement polymorphism in codes.
Run time polymorphism can lead to the performance issue as machine needs to decide which method or variable to invoke so it basically degrades the performances as decisions are taken at run time.
Polymorphism reduces the readability of the program. One needs to identify the runtime behavior of the program to identify actual execution time.</p>
</blockquote>
<p>Ref: <a href="https://www.quora.com/What-are-the-disadvantages-of-polymorphism">Akanksha Patel</a></p>
<hr />
<h3 id="compile-time--run-time-polymorphism"><a class="header" href="#compile-time--run-time-polymorphism">Compile time &amp; Run time Polymorphism</a></h3>
<p>Difference between compile time and run time polymorphism:</p>
<blockquote>
<p>Static polymorphism produces faster code, mostly because of the possibility of aggressive inlining. Virtual functions can rarely be inlined, and mostly in a &quot;non-polymorphic&quot; scenarios. ...
On the other hand, not only compile times, but also the readability and debuggability of the code is much worse when using static polymorphism. 
For instance: abstract methods are a clean way of enforcing implementation of certain interface methods. ...</p>
</blockquote>
<p>Ref: <a href="https://stackoverflow.com/a/16876567">maciek gajewski</a></p>
<h2 id="example-1-integer--real--complex-number-calculator-a-hrefooplecture12_ex1htmlsourcea"><a class="header" href="#example-1-integer--real--complex-number-calculator-a-hrefooplecture12_ex1htmlsourcea">Example 1: Integer &amp; Real &amp; Complex Number Calculator [<a href="oop/./lecture12_ex1.html">Source</a>]</a></h2>
<h2 id="example-2-complex-number--triangles-a-hrefooplecture12_ex2htmlsourcea"><a class="header" href="#example-2-complex-number--triangles-a-hrefooplecture12_ex2htmlsourcea">Example 2: Complex Number &amp; Triangles [<a href="oop/./lecture12_ex2.html">Source</a>]</a></h2>
<h2 id="lab-12-a-hrefooplablab12-1htmlcomplex-numbers-geometry--operationsa"><a class="header" href="#lab-12-a-hrefooplablab12-1htmlcomplex-numbers-geometry--operationsa">Lab 12: <a href="oop/./lab/lab12-1.html">Complex Number's Geometry &amp; Operations</a></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-1-integer--real--complex-number-calculator-1"><a class="header" href="#example-1-integer--real--complex-number-calculator-1">Example 1: Integer &amp; Real &amp; Complex Number Calculator</a></h1>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;

using namespace std;

class Number
{
public:
    Number()
    {
    }
    virtual double get_value() const
    {
        return 0.0;
    }
    virtual string get_string() const
    {
        return &quot;&quot;;
    }
    virtual void set_value(string arg_s)
    {
    }
    virtual void add_assign(string arg_s)
    {
    }
    virtual void sub_assign(string arg_s)
    {
    }
    virtual void mul_assign(string arg_s)
    {
    }
    virtual void div_assign(string arg_s)
    {
    }
};

class Integer : public Number
{
protected:
    int m_int_value;

public:
    Integer(int arg_int_value = 0) : m_int_value(arg_int_value)
    {
    }
    Integer(const Integer &amp;arg_int) : m_int_value(arg_int.m_int_value)
    {
    }
    operator int() const
    {
        return m_int_value;
    }
    Integer &amp;operator=(const Integer &amp;arg_int)
    {
        m_int_value = arg_int.m_int_value;
        return *this;
    }
    double get_value() const
    {
        return (double)m_int_value;
    }
    string get_string() const
    {
        return to_string(m_int_value);
    }
    void set_value(string arg_int_value) // int version
    {
        stringstream ss(arg_int_value); // use operator&gt;&gt; to convert string to Integer
        ss &gt;&gt; m_int_value;
    }
    void add_assign(string arg_int_value) // int version
    {
        Integer num1(*this), num2;
        num2.set_value(arg_int_value);
        *this = num1 + num2;
    }
    void sub_assign(string arg_int_value) // int version
    {
        Integer num1(*this), num2;
        num2.set_value(arg_int_value);
        *this = num1 - num2;
    }
    void mul_assign(string arg_int_value) // int version
    {
        Integer num1(*this), num2;
        num2.set_value(arg_int_value);
        *this = num1 * num2;
    }
    void div_assign(string arg_int_value) // int version
    {
        Integer num1(*this), num2;
        num2.set_value(arg_int_value);
        *this = num1 / num2;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Integer &amp;arg_integer)
    {
        arg_os &lt;&lt; arg_integer.get_string();
        return arg_os;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Integer &amp;arg_integer)
    {
        arg_is &gt;&gt; arg_integer.m_int_value;
        return arg_is;
    }
    friend Integer operator+(const Integer &amp;arg_integer1, const Integer &amp;arg_integer2)
    {
        Integer temp_integer(arg_integer1.m_int_value + arg_integer2.m_int_value);
        return temp_integer;
    }
    friend Integer operator-(const Integer &amp;arg_integer1, const Integer &amp;arg_integer2)
    {
        Integer temp_integer(arg_integer1.m_int_value - arg_integer2.m_int_value);
        return temp_integer;
    }
    friend Integer operator*(const Integer &amp;arg_integer1, const Integer &amp;arg_integer2)
    {
        Integer temp_integer(arg_integer1.m_int_value * arg_integer2.m_int_value);
        return temp_integer;
    }
    friend Integer operator/(const Integer &amp;arg_integer1, const Integer &amp;arg_integer2)
    {
        Integer temp_integer(arg_integer1.m_int_value / arg_integer2.m_int_value);
        return temp_integer;
    }
};

// Real is a Integer
class Real : public Integer
{
protected:
    double m_after_decimal;

public:
    Real(double arg_value = 0.0) : Integer((int)arg_value),
                                   m_after_decimal(arg_value - (int)arg_value)
    {
    }
    Real(const Real &amp;arg_real) : Integer(arg_real),
                                 m_after_decimal(arg_real.m_after_decimal)
    {
    }
    operator double() const
    {
        return m_after_decimal + (double)m_int_value;
    }
    Real &amp;operator=(const Real &amp;arg_real)
    {
        m_int_value = arg_real.m_int_value;
        m_after_decimal = arg_real.m_after_decimal;
        return *this;
    }
    double get_value() const
    {
        return m_after_decimal + (double)m_int_value;
    }
    string get_string() const
    {
        return to_string(Real::get_value());
    }
    void set_value(string arg_value) // double version
    {
        double temp_double;
        temp_double = stod(arg_value);
        m_int_value = (int)temp_double;
        m_after_decimal = temp_double - (double)m_int_value;
    }
    void add_assign(string arg_int_value) // int version
    {
        Real num1(*this), num2;
        num2.set_value(arg_int_value);
        *this = num1 + num2;
    }
    void sub_assign(string arg_int_value) // int version
    {
        Real num1(*this), num2;
        num2.set_value(arg_int_value);
        *this = num1 - num2;
    }
    void mul_assign(string arg_int_value) // int version
    {
        Real num1(*this), num2;
        num2.set_value(arg_int_value);
        *this = num1 * num2;
    }
    void div_assign(string arg_int_value) // int version
    {
        Real num1(*this), num2;
        num2.set_value(arg_int_value);
        *this = num1 / num2;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Real &amp;arg_real)
    {
        arg_os &lt;&lt; (double)arg_real;
        return arg_os;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Real &amp;arg_real)
    {
        string temp_string;
        arg_is &gt;&gt; temp_string;
        arg_real.set_value(temp_string);
        return arg_is;
    }
    friend Real operator+(const Real &amp;arg_real1, const Real &amp;arg_real2)
    {
        // call the Integer operator+ to add the Integer part
        Integer temp_integer((Integer)arg_real1 + (Integer)arg_real2);
        Real temp_real(arg_real1.m_after_decimal + arg_real2.m_after_decimal);
        temp_real.set_value(to_string(temp_integer.get_value() + temp_real.get_value()));
        return temp_real;
    }
    friend Real operator-(const Real &amp;arg_real1, const Real &amp;arg_real2)
    {
        Real temp_real((double)arg_real1 - (double)arg_real2);
        return temp_real;
    }
    friend Real operator*(const Real &amp;arg_real1, const Real &amp;arg_real2)
    {
        Real temp_real((double)arg_real1 * (double)arg_real2);
        return temp_real;
    }
    friend Real operator/(const Real &amp;arg_real1, const Real &amp;arg_real2)
    {
        Real temp_real((double)arg_real1 / (double)arg_real2);
        return temp_real;
    }
};

class Imaginary
{
protected:
    double m_imaginary_value;

public:
    Imaginary(double arg_imaginary_value = 0.0) : m_imaginary_value(arg_imaginary_value)
    {
    }
    Imaginary(const Imaginary &amp;arg_imaginary) : m_imaginary_value(arg_imaginary.m_imaginary_value)
    {
    }
    Imaginary &amp;operator=(const Imaginary &amp;arg_imaginary)
    {
        m_imaginary_value = arg_imaginary.m_imaginary_value;
        return *this;
    }
    double get_value() const // use the same function as Number to
                             // maintain the same interface
    {
        return m_imaginary_value;
    }
    string get_string() const
    {
        return to_string(m_imaginary_value) + &quot;i&quot;;
    }
    void set_value(string arg_imaginary_value)
    {
        m_imaginary_value = stod(arg_imaginary_value);
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Imaginary &amp;arg_imaginary)
    {
        arg_os &lt;&lt; arg_imaginary.get_string();
        return arg_os;
    }
    friend Imaginary operator+(const Imaginary &amp;arg_imaginary1, const Imaginary &amp;arg_imaginary2)
    {
        Imaginary temp_imaginary(arg_imaginary1.m_imaginary_value + arg_imaginary2.m_imaginary_value);
        return temp_imaginary;
    }
    friend Imaginary operator-(const Imaginary &amp;arg_imaginary1, const Imaginary &amp;arg_imaginary2)
    {
        Imaginary temp_imaginary(arg_imaginary1.m_imaginary_value - arg_imaginary2.m_imaginary_value);
        return temp_imaginary;
    }
};

class Complex : public Real, public Imaginary
{
public:
    Complex(double arg_real_value = 0.0,
            double arg_imaginary_value = 0.0)
        : Real(arg_real_value),
          Imaginary(arg_imaginary_value)
    {
    }
    Complex(const Complex &amp;arg_complex)
        : Real(arg_complex),
          Imaginary(arg_complex)
    {
    }
    Complex &amp;operator=(const Complex &amp;arg_complex)
    {
        Real::operator=(arg_complex);
        Imaginary::operator=(arg_complex);
        return *this;
    }
    double get_value() const
    {
        cout &lt;&lt; &quot;not implemented&quot; &lt;&lt; endl;
        return 0.0;
    }
    string get_string() const
    {
        return Real::get_string() + &quot; + &quot; + Imaginary::get_string();
    }
    void set_value(string arg_value) // complex version
    {
        size_t plus_pos = arg_value.find(&quot;+&quot;);
        if (plus_pos != string::npos)
        {
            Real::set_value(arg_value.substr(0, plus_pos));
        }
        size_t i_pos = arg_value.find(&quot;i&quot;);
        if (i_pos != string::npos)
        {
            Imaginary::set_value(arg_value.substr(plus_pos + 1, i_pos - plus_pos - 1));
        }
    }
    Complex reciprocal() const
    {
        double temp_real_value = Real::get_value();
        double temp_imaginary_value = Imaginary::get_value();
        double temp_denominator = temp_real_value * temp_real_value + temp_imaginary_value * temp_imaginary_value;
        Complex temp_complex(temp_real_value / temp_denominator, -temp_imaginary_value / temp_denominator);
        return temp_complex;
    }
    void add_assign(string arg_int_value) // int version
    {
        Complex num1(*this), num2;
        num2.set_value(arg_int_value);
        *this = num1 + num2;
    }
    void sub_assign(string arg_int_value) // int version
    {
        Complex num1(*this), num2;
        num2.set_value(arg_int_value);
        *this = num1 - num2;
    }
    void mul_assign(string arg_int_value) // int version
    {
        Complex num1(*this), num2;
        num2.set_value(arg_int_value);
        *this = num1 * num2;
    }
    void div_assign(string arg_int_value) // int version
    {
        Complex num1(*this), num2;
        num2.set_value(arg_int_value);
        *this = num1 / num2;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex &amp;arg_complex)
    {
        arg_os &lt;&lt; arg_complex.get_string();
        return arg_os;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Complex &amp;arg_complex)
    {
        string temp_string;
        getline(arg_is, temp_string);
        arg_complex.set_value(temp_string);
        return arg_is;
    }
    friend Complex operator+(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        Complex temp_complex(arg_complex1.Real::get_value() + arg_complex2.Real::get_value(),
                             arg_complex1.Imaginary::get_value() + arg_complex2.Imaginary::get_value());
        return temp_complex;
    }
    friend Complex operator-(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        Complex temp_complex(arg_complex1.Real::get_value() - arg_complex2.Real::get_value(),
                             arg_complex1.Imaginary::get_value() - arg_complex2.Imaginary::get_value());
        return temp_complex;
    }
    friend Complex operator*(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        Complex temp_complex(arg_complex1.Real::get_value() * arg_complex2.Real::get_value() -
                                 arg_complex1.Imaginary::get_value() * arg_complex2.Imaginary::get_value(),
                             arg_complex1.Real::get_value() * arg_complex2.Imaginary::get_value() +
                                 arg_complex1.Imaginary::get_value() * arg_complex2.Real::get_value());
        return temp_complex;
    }
    friend Complex operator/(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        Complex temp_complex(arg_complex1 * arg_complex2.reciprocal());
        return temp_complex;
    }
};

// Number calculator class declaration
class Number_Calc
{
private:
    // define current value
    Number *m_curr_val_ptr;
    // define input value
    Number *m_input_val_ptr;
    // define operation
    // `+`, `-`, `*`, `/`, and `=`
    char m_op;
    // define value type
    // `(R)eal`, `(I)nterger`, `(C)omplex`
    char m_val_type;
    // define input status, turns `op` for true and turns `value` for false
    bool m_op_input;
    // calculate result
    void _calc_result()
    {
        switch (m_op)
        {
        case '+':
            m_curr_val_ptr-&gt;add_assign(m_input_val_ptr-&gt;get_string());
            break;
        case '-':
            m_curr_val_ptr-&gt;sub_assign(m_input_val_ptr-&gt;get_string());
            break;
        case '*':
            m_curr_val_ptr-&gt;mul_assign(m_input_val_ptr-&gt;get_string());
            break;
        case '/':
            m_curr_val_ptr-&gt;div_assign(m_input_val_ptr-&gt;get_string());
            break;
        case '=':
            m_curr_val_ptr-&gt;set_value(m_input_val_ptr-&gt;get_string());
            break;
        default:
            break;
        }
    }
    // operation functions
    // set activation op to add
    void _add()
    {
        m_op = '+';
        m_op_input = false;
    }
    // set activation op to subtract
    void _sub()
    {
        m_op = '-';
        m_op_input = false;
    }
    // set activation op to multiply
    void _mul()
    {
        m_op = '*';
        m_op_input = false;
    }
    // set activation op to divide
    void _div()
    {
        m_op = '/';
        m_op_input = false;
    }
    // set activation op to assign
    void _assign()
    {
        m_op = '=';
        m_op_input = false;
    }

public:
    // Constructor
    Number_Calc(const char &amp;arg_type = 'C')
        : m_curr_val_ptr(NULL), m_input_val_ptr(NULL), m_op('='), m_op_input(false), m_val_type(arg_type)
    {
        switch (m_val_type)
        {
        case 'R':
            m_curr_val_ptr = new Real();
            m_input_val_ptr = new Real();
            break;
        case 'C':
            m_curr_val_ptr = new Complex();
            m_input_val_ptr = new Complex();
            break;
        case 'I':
            m_curr_val_ptr = new Integer();
            m_input_val_ptr = new Integer();
            break;
        default:
            cout &lt;&lt; &quot;Error: Invalid value type&quot; &lt;&lt; endl;
            break;
        }
    }

    // Copy constructor
    Number_Calc(const Number_Calc &amp;arg_comp_calc)
        : m_op(arg_comp_calc.m_op), m_op_input(arg_comp_calc.m_op_input), m_val_type(arg_comp_calc.m_val_type)
    {
        switch (m_val_type)
        {
        case 'R':
            m_curr_val_ptr = new Real(*(Real *)arg_comp_calc.m_curr_val_ptr);
            m_input_val_ptr = new Real(*(Real *)arg_comp_calc.m_input_val_ptr);
            break;
        case 'C':
            m_curr_val_ptr = new Complex(*(Complex *)arg_comp_calc.m_curr_val_ptr);
            m_input_val_ptr = new Complex(*(Complex *)arg_comp_calc.m_input_val_ptr);
            break;
        case 'I':
            m_curr_val_ptr = new Integer(*(Integer *)arg_comp_calc.m_curr_val_ptr);
            m_input_val_ptr = new Integer(*(Integer *)arg_comp_calc.m_input_val_ptr);
            break;
        default:
            cout &lt;&lt; &quot;Error: Invalid value type&quot; &lt;&lt; endl;
            break;
        }
    }

    // Destructor
    ~Number_Calc()
    {
        delete m_curr_val_ptr;
        delete m_input_val_ptr;
    }

    // cin `&gt;&gt;` operator for set input value or operation
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Number_Calc &amp;arg_comp_calc)
    {
        string temp_string;
        getline(arg_is, temp_string);
        if (temp_string == &quot;+&quot;)
        {
            arg_comp_calc._add();
        }
        else if (temp_string == &quot;-&quot;)
        {
            arg_comp_calc._sub();
        }
        else if (temp_string == &quot;*&quot;)
        {
            arg_comp_calc._mul();
        }
        else if (temp_string == &quot;/&quot;)
        {
            arg_comp_calc._div();
        }
        else if (temp_string == &quot;=&quot;)
        {
            arg_comp_calc._assign();
        }
        else
        {
            arg_comp_calc.m_input_val_ptr-&gt;set_value(temp_string);
            arg_comp_calc.m_op_input = true;
            arg_comp_calc._calc_result();
        }
        return arg_is;
    }

    // cout `&lt;&lt;` operator for print calculator status
    // note: be careful about the format of output
    // cout `&lt;&lt;` operator for print calculator status
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Number_Calc &amp;arg_comp_calc)
    {
        arg_os &lt;&lt; arg_comp_calc.m_curr_val_ptr-&gt;get_string();
        return arg_os;
    }
};

int main()
{
    // create an instance of the class for Integer
    Number_Calc calc_i('I');
    for (int i = 0; i &lt; 3; i++)
    {
        cin &gt;&gt; calc_i;
        cout &lt;&lt; calc_i &lt;&lt; endl;
    }
    // create an instance of the class for Real
    Number_Calc calc_r('R');
    for (int i = 0; i &lt; 3; i++)
    {
        cin &gt;&gt; calc_r;
        cout &lt;&lt; calc_r &lt;&lt; endl;
    }
    // create an instance of the class for Complex
    Number_Calc calc_c('C');
    for (int i = 0; i &lt; 3; i++)
    {
        cin &gt;&gt; calc_c;
        cout &lt;&lt; calc_c &lt;&lt; endl;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-2-complex-number--triangles"><a class="header" href="#example-2-complex-number--triangles">Example 2: Complex Number &amp; Triangles</a></h1>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;cmath&gt;

using namespace std;

class Triangle_Complex; // forward declaration

class Integer
{
protected:
    int m_int_value;

public:
    Integer(int arg_int_value = 0) : m_int_value(arg_int_value)
    {
    }
    Integer(const Integer &amp;arg_int) : m_int_value(arg_int.m_int_value)
    {
    }
    operator int() const
    {
        return m_int_value;
    }
    Integer &amp;operator=(const Integer &amp;arg_int)
    {
        m_int_value = arg_int.m_int_value;
        return *this;
    }
    void set_int_value(int arg_int_value)
    {
        m_int_value = arg_int_value;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Integer &amp;arg_integer)
    {
        arg_os &lt;&lt; arg_integer.m_int_value;
        return arg_os;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Integer &amp;arg_integer)
    {
        arg_is &gt;&gt; arg_integer.m_int_value;
        return arg_is;
    }
    friend Integer operator+(const Integer &amp;arg_integer1, const Integer &amp;arg_integer2)
    {
        Integer temp_integer(arg_integer1.m_int_value + arg_integer2.m_int_value);
        return temp_integer;
    }
    friend Integer operator-(const Integer &amp;arg_integer1, const Integer &amp;arg_integer2)
    {
        Integer temp_integer(arg_integer1.m_int_value - arg_integer2.m_int_value);
        return temp_integer;
    }
    friend Integer operator*(const Integer &amp;arg_integer1, const Integer &amp;arg_integer2)
    {
        Integer temp_integer(arg_integer1.m_int_value * arg_integer2.m_int_value);
        return temp_integer;
    }
    friend Integer operator/(const Integer &amp;arg_integer1, const Integer &amp;arg_integer2)
    {
        Integer temp_integer(arg_integer1.m_int_value / arg_integer2.m_int_value);
        return temp_integer;
    }
};

// Real is a Integer
class Real : public Integer
{
protected:
    double m_after_decimal;

public:
    Real(double arg_value = 0.0) : Integer((int)arg_value),
                                   m_after_decimal(arg_value - (int)arg_value)
    {
    }
    Real(const Real &amp;arg_real) : Integer(arg_real),
                                 m_after_decimal(arg_real.m_after_decimal)
    {
    }
    operator double() const
    {
        return m_after_decimal + (double)m_int_value;
    }
    Real &amp;operator=(const Real &amp;arg_real)
    {
        m_int_value = arg_real.m_int_value;
        m_after_decimal = arg_real.m_after_decimal;
        return *this;
    }
    void set_real_value(double arg_value)
    {
        m_int_value = (int)arg_value;
        m_after_decimal = arg_value - m_int_value;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Real &amp;arg_real)
    {
        arg_os &lt;&lt; (double)arg_real;
        return arg_os;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Real &amp;arg_real)
    {
        double temp_double;
        arg_is &gt;&gt; temp_double;
        arg_real.set_real_value(temp_double);
        return arg_is;
    }
    friend Real operator+(const Real &amp;arg_real1, const Real &amp;arg_real2)
    {
        // call the Integer operator+ to add the Integer part
        Integer temp_integer((Integer)arg_real1 + (Integer)arg_real2);
        Real temp_real(arg_real1.m_after_decimal + arg_real2.m_after_decimal);
        temp_real.set_int_value((int)temp_integer + (int)temp_real);
        return temp_real;
    }
    friend Real operator-(const Real &amp;arg_real1, const Real &amp;arg_real2)
    {
        Real temp_real((double)arg_real1 - (double)arg_real2);
        return temp_real;
    }
    friend Real operator*(const Real &amp;arg_real1, const Real &amp;arg_real2)
    {
        Real temp_real((double)arg_real1 * (double)arg_real2);
        return temp_real;
    }
    friend Real operator/(const Real &amp;arg_real1, const Real &amp;arg_real2)
    {
        Real temp_real((double)arg_real1 / (double)arg_real2);
        return temp_real;
    }
};

class Imaginary
{
protected:
    double m_imaginary_value;

public:
    Imaginary(double arg_imaginary_value = 0.0) : m_imaginary_value(arg_imaginary_value)
    {
    }
    Imaginary(const Imaginary &amp;arg_imaginary) : m_imaginary_value(arg_imaginary.m_imaginary_value)
    {
    }
    Imaginary &amp;operator=(const Imaginary &amp;arg_imaginary)
    {
        m_imaginary_value = arg_imaginary.m_imaginary_value;
        return *this;
    }
    double get_imaginary_value() const
    {
        return m_imaginary_value;
    }
    void set_imaginary_value(double arg_imaginary_value)
    {
        m_imaginary_value = arg_imaginary_value;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Imaginary &amp;arg_imaginary)
    {
        arg_os &lt;&lt; arg_imaginary.m_imaginary_value &lt;&lt; &quot;i&quot;;
        return arg_os;
    }
    friend Imaginary operator+(const Imaginary &amp;arg_imaginary1, const Imaginary &amp;arg_imaginary2)
    {
        Imaginary temp_imaginary(arg_imaginary1.m_imaginary_value + arg_imaginary2.m_imaginary_value);
        return temp_imaginary;
    }
    friend Imaginary operator-(const Imaginary &amp;arg_imaginary1, const Imaginary &amp;arg_imaginary2)
    {
        Imaginary temp_imaginary(arg_imaginary1.m_imaginary_value - arg_imaginary2.m_imaginary_value);
        return temp_imaginary;
    }
};

class Complex : public Real, public Imaginary
{
public:
    Complex(double arg_real_value = 0.0,
            double arg_imaginary_value = 0.0)
        : Real(arg_real_value),
          Imaginary(arg_imaginary_value)
    {
    }
    Complex(const Complex &amp;arg_complex)
        : Real(arg_complex),
          Imaginary(arg_complex)
    {
    }
    Complex &amp;operator=(const Complex &amp;arg_complex)
    {
        Real::operator=(arg_complex);
        Imaginary::operator=(arg_complex);
        return *this;
    }
    Complex reciprocal() const
    {
        Complex temp_complex(*this);
        double temp_real_value = temp_complex;
        double temp_imaginary_value = temp_complex.get_imaginary_value();
        double temp_denominator = temp_real_value * temp_real_value + temp_imaginary_value * temp_imaginary_value;
        temp_complex.set_real_value(temp_real_value / temp_denominator);
        temp_complex.set_imaginary_value(-temp_imaginary_value / temp_denominator);
        return temp_complex;
    }
    double get_magnitude() const
    {
        Real temp_real(*this);
        return sqrt((double)(temp_real * temp_real) + get_imaginary_value() * get_imaginary_value());
    }
    Complex get_argument() const
    {
        double magnitude = get_magnitude();
        Complex temp_complex((double)(*this) / magnitude, get_imaginary_value() / magnitude);
        return temp_complex;
    }
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex &amp;arg_complex)
    {
        arg_os &lt;&lt; (Real)arg_complex &lt;&lt; &quot; + &quot; &lt;&lt; (Imaginary)arg_complex;
        return arg_os;
    }
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Complex &amp;arg_complex)
    {
        string temp_string;
        getline(arg_is, temp_string, '+');
        arg_complex.set_real_value(stod(temp_string));
        getline(arg_is, temp_string, 'i');
        arg_complex.set_imaginary_value(stod(temp_string));
        return arg_is;
    }
    friend Complex operator+(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        Complex temp_complex((double)arg_complex1 + (double)arg_complex2,
                             arg_complex1.get_imaginary_value() + arg_complex2.get_imaginary_value());
        return temp_complex;
    }
    friend Complex operator-(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        Complex temp_complex((double)arg_complex1 - (double)arg_complex2,
                             arg_complex1.get_imaginary_value() - arg_complex2.get_imaginary_value());
        return temp_complex;
    }
    friend Complex operator*(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        Complex temp_complex((double)arg_complex1 * (double)arg_complex2 -
                                 arg_complex1.get_imaginary_value() * arg_complex2.get_imaginary_value(),
                             (double)arg_complex1 * arg_complex2.get_imaginary_value() +
                                 arg_complex1.get_imaginary_value() * (double)arg_complex2);
        return temp_complex;
    }
    friend Complex operator/(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        Complex temp_complex(arg_complex1 * arg_complex2.reciprocal());
        return temp_complex;
    }
    friend bool operator==(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        return ((double)arg_complex1 == (double)arg_complex2) &amp;&amp;
               (arg_complex1.get_imaginary_value() == arg_complex2.get_imaginary_value());
    }
    friend bool operator!=(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        return !(arg_complex1 == arg_complex2);
    }
    friend bool operator&lt;(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        return ((double)arg_complex1 &lt; (double)arg_complex2) ||
               ((double)arg_complex1 == (double)arg_complex2 &amp;&amp;
                arg_complex1.get_imaginary_value() &lt; arg_complex2.get_imaginary_value());
    }
    friend bool operator&gt;(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        return arg_complex2 &lt; arg_complex1;
    }
    friend bool operator&lt;=(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        return !(arg_complex1 &gt; arg_complex2);
    }
    friend bool operator&gt;=(const Complex &amp;arg_complex1, const Complex &amp;arg_complex2)
    {
        return !(arg_complex1 &lt; arg_complex2);
    }
    friend class Triangle_Complex;
};

// Triangle_Complex class declaration
class Triangle_Complex
{
protected:
    // define three points of the Triangle_Complex
    // Triangle 'has-a' Complex, so it use composition
    Complex m_point[3];

    // check &amp; correct the Triangle_Complex points to counterclockwise order
    void _check_points()
    {
        // if the area is negative, swap the points
        if (area() &lt; 0.0)
        {
            Complex temp = m_point[0];
            m_point[0] = m_point[1];
            m_point[1] = temp;
        }
    }

public:
    // Constructor
    Triangle_Complex(const Complex &amp;arg_point1,
                     const Complex &amp;arg_point2,
                     const Complex &amp;arg_point3)
        : m_point{arg_point1, arg_point2, arg_point3}
    {
        _check_points();
    }

    // Copy constructor
    Triangle_Complex(const Triangle_Complex &amp;arg_triangle)
        : m_point{arg_triangle.m_point[0], arg_triangle.m_point[1], arg_triangle.m_point[2]}
    {
    }

    // Destructor
    ~Triangle_Complex() {} // do nothing

    // modify the three points of the Triangle_Complex
    virtual void set_points(const Complex &amp;arg_point1,
                            const Complex &amp;arg_point2,
                            const Complex &amp;arg_point3)
    {
        m_point[0] = arg_point1;
        m_point[1] = arg_point2;
        m_point[2] = arg_point3;
        _check_points();
    }
    virtual void set_point1(const Complex &amp;arg_point1)
    {
        m_point[0] = arg_point1;
        _check_points();
    }
    virtual void set_point2(const Complex &amp;arg_point2)
    {
        m_point[1] = arg_point2;
        _check_points();
    }
    virtual void set_point3(const Complex &amp;arg_point3)
    {
        m_point[2] = arg_point3;
        _check_points();
    }
    // get the three points of the Triangle_Complex
    Complex get_point1() const
    {
        return m_point[0];
    }
    Complex get_point2() const
    {
        return m_point[1];
    }
    Complex get_point3() const
    {
        return m_point[2];
    }

    // calculate the area of the Triangle_Complex
    double area()
    {
        double area = 0.0;
        for (int i = 0; i &lt; 3; i++)
        {
            area += (double)m_point[i] * m_point[(i + 1) % 3].get_imaginary_value();
            area -= m_point[i].get_imaginary_value() * (double)m_point[(i + 1) % 3];
        }
        return area / 2.0;
    }

    // print the Triangle_Complex
    // format: (c1, c2, c3)
    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;arg_os, const Triangle_Complex &amp;arg_tri)
    {
        arg_os &lt;&lt; &quot;(&quot;;
        for (int i = 0; i &lt; 3; i++)
        {
            arg_os &lt;&lt; arg_tri.m_point[i];
            if (i &lt; 2)
                arg_os &lt;&lt; &quot;, &quot;;
        }
        arg_os &lt;&lt; &quot;)&quot;;
        return arg_os;
    }
    // read the coordinate of a point from the input,
    // format: (c1, c2, c3) and ignore space
    friend std::istream &amp;operator&gt;&gt;(std::istream &amp;arg_is, Triangle_Complex &amp;arg_tri)
    {
        string temp;
        if (getline(arg_is, temp, '(')) // ignore the first '('
        {
            for (int i = 0; i &lt; 3; i++)
            {
                arg_is &gt;&gt; arg_tri.m_point[i];
                if (i &lt; 2)
                {
                    getline(arg_is, temp, ','); // ignore the ','
                }
            }
            getline(arg_is, temp, ')'); // ignore the last ')'
        }

        // check &amp; correct the Triangle_Complex points to counterclockwise order
        arg_tri._check_points();

        return arg_is;
    }
};

class Equilateral_Triangle_Complex : public Triangle_Complex
// Equilateral Triangle `is-a' Triangle_Complex, so it use inheritance
// use function overloading to implement the different function
// of Equilateral_Triangle_Complex
// details will be discussed in polymorphism (next chapter)
{
public:
    Equilateral_Triangle_Complex(const Complex &amp;arg_point1,
                                 const Complex &amp;arg_point2)
        : Triangle_Complex(arg_point1, arg_point2, arg_point1)
    {
        Complex temp = arg_point2 - arg_point1;
        temp = temp * Complex(0.5, sqrt(3.0) / 2.0); // rotate 60 degree
        m_point[2] = arg_point1 + temp;              // calculate the third point
        _check_points();
    }

    void set_points(const Complex &amp;arg_point1,
                    const Complex &amp;arg_point2,
                    const Complex &amp;arg_point3)
    {
        m_point[0] = arg_point1;
        m_point[1] = arg_point2;
        Complex temp = arg_point2 - arg_point1;
        temp = temp * Complex(0.5, sqrt(3.0) / 2.0); // rotate 60 degree
        m_point[2] = arg_point1 + temp;              // calculate the third point
        _check_points();
    }

    void set_point1(const Complex &amp;arg_point1)
    {
        // invalid operation
    }
    void set_point2(const Complex &amp;arg_point2)
    {
        // invalid operation
    }
    void set_point3(const Complex &amp;arg_point3)
    {
        // invalid operation
    }
    // read the coordinate of a point from the input,
    // format: (c1, c2, c3) and ignore c3 and spaces
    friend std::istream &amp;operator&gt;&gt;(std::istream &amp;arg_is,
                                    Equilateral_Triangle_Complex &amp;arg_tri)
    {
        string temp;
        if (getline(arg_is, temp, '(')) // ignore the first '('
        {
            for (int i = 0; i &lt; 3; i++)
            {
                if (i &lt; 2)
                {
                    arg_is &gt;&gt; arg_tri.m_point[i];
                    getline(arg_is, temp, ','); // ignore the ','
                }
            }
            getline(arg_is, temp, ')'); // ignore the c3 and last ')'
        }

        // check &amp; correct the Triangle_Complex points to counterclockwise order
        arg_tri._check_points();

        return arg_is;
    }
};

// main function

int main()
{
    // create a Equilateral_Triangle_Complex
    Triangle_Complex *t = new Equilateral_Triangle_Complex(Complex(1, 1), Complex(2, 2));
    cout &lt;&lt; *t &lt;&lt; endl;
    cout &lt;&lt; &quot;Area: &quot; &lt;&lt; t-&gt;area() &lt;&lt; endl;
    // change the points of the Equilateral_Triangle_Complex
    t-&gt;set_points(Complex(3, 3), Complex(2, 2), Complex(3, 0));
    cout &lt;&lt; *t &lt;&lt; endl;
    cout &lt;&lt; &quot;Area: &quot; &lt;&lt; t-&gt;area() &lt;&lt; endl;
    delete t;

    // change the object to Triangle_Complex
    t = new Triangle_Complex(Complex(1, 1), Complex(2, 2), Complex(3, 0));
    cout &lt;&lt; *t &lt;&lt; endl;
    cout &lt;&lt; &quot;Area: &quot; &lt;&lt; t-&gt;area() &lt;&lt; endl;
    // change the points of the Triangle_Complex
    t-&gt;set_points(Complex(3, 3), Complex(2, 2), Complex(3, 0));
    cout &lt;&lt; *t &lt;&lt; endl;
    cout &lt;&lt; &quot;Area: &quot; &lt;&lt; t-&gt;area() &lt;&lt; endl;
    delete t;

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-12-complex-numbers-geometry--operations"><a class="header" href="#lab-12-complex-numbers-geometry--operations">Lab 12: Complex Number's Geometry &amp; Operations</a></h1>
<h2 id="lab-12-1-complex-numbers-geometry-40"><a class="header" href="#lab-12-1-complex-numbers-geometry-40">Lab 12-1: Complex Number's Geometry (40%)</a></h2>
<ul>
<li>輸入：
<ol>
<li>以 <code>char</code> 格式輸入幾何圖形形狀，包含三角形 (<code>t</code>)、四邊形 (<code>q</code>)、多邊形 (<code>p</code>)、圓形 <code>c</code>，一行輸入一個幾何圖形</li>
<li>以 <code>unsinged int</code> 格式輸入幾何圖形的頂點數，一行輸入一個正整數
<ol>
<li>三角形：3</li>
<li>四邊形：4</li>
<li>多邊形：大於 3 的正整數</li>
<li>圓形：2</li>
</ol>
</li>
<li>以 <code>double</code> 格式輸入組合幾何圖形的複數的實數及虛數部分，以空格分開，一行輸入一個複數</li>
<li>輸入幾何圖形形狀及頂點數後依據 <strong>2.</strong> 的頂點數接著輸入相對應的複數
<ol>
<li>三角形：連續輸入三個複數</li>
<li>四邊形：連續輸入四個複數</li>
<li>多邊形：連續輸入多個複數</li>
<li>圓形：連續輸入兩個複數</li>
</ol>
</li>
<li>輸入 <kbd>Ctrl</kbd>+<kbd>D</kbd> 結束程式
<ul>
<li>Windows 請輸入 <kbd>Ctrl</kbd>+<kbd>Z</kbd> (會在螢幕上顯示 <code>^Z</code>) 再輸入 <kbd>Enter</kbd> (Format 中的 <code>⏎</code>) 完成輸入</li>
</ul>
</li>
</ol>
</li>
<li>輸出：
<ol>
<li>顯示紀錄幾何圖形的形狀、頂點個數及其複數
<ol>
<li>格式請參考 <a href="oop/lab/lab12-1.html#format">Format</a> 中的說明</li>
<li>頂點順序與輸入順序相同</li>
</ol>
</li>
<li>複數的格式為 <code>(-)&lt;real result&gt; (+|-) (&lt;imag result&gt;i)</code>
<ol>
<li>若虛數部分為 0 則僅顯示實數部分</li>
<li>若虛數部分小於 0 則中間的 <code>+</code> 要改成 <code>-</code>，並且虛數部分要顯示絕對值</li>
</ol>
</li>
<li>虛數及實數部分皆以預設 <code>double</code> 格式顯示</li>
</ol>
</li>
<li>檔名：<code>lab12-1_&lt;學號&gt;.cpp</code> (e.g. <code>lab12-1_106062802.cpp</code>)</li>
</ul>
<p>注意事項：</p>
<ul>
<li>程式不會輸出任何使用者提示，只會輸出程式結果</li>
<li>使用者不需要處理錯誤輸入</li>
<li>請使用 pseudo code 提供的 <code>main</code> function 來處理輸入與輸出</li>
<li>程式需要於 10 秒內完成，所有的測資皆會保證於 10 秒內完成</li>
</ul>
<h3 id="format-10"><a class="header" href="#format-10">Format</a></h3>
<pre><code class="language-text">&lt;geometry type&gt;⏎
n⏎
&lt;real 1&gt; &lt;imag 1&gt;⏎
&lt;real 2&gt; &lt;imag 2&gt;⏎
...
&lt;real n&gt; &lt;imag n&gt;⏎
&lt;geometry type&gt;
n
(-)&lt;real 1&gt; (+|-) (&lt;imag 1&gt;i)
(-)&lt;real 2&gt; (+|-) (&lt;imag 2&gt;i)
...
(-)&lt;real n&gt; (+|-) (&lt;imag n&gt;i)
^Z⏎
</code></pre>
<h3 id="example-11"><a class="header" href="#example-11">Example</a></h3>
<h4 id="triangle"><a class="header" href="#triangle">Triangle</a></h4>
<pre><code class="language-console">$ ./a.out
t⏎
3⏎
1.0 2.0⏎
3.0 4.0⏎
5.0 0.0⏎
t
3
1 + 2i
3 + 4i
5
^Z⏎
</code></pre>
<h4 id="quadrilateral"><a class="header" href="#quadrilateral">Quadrilateral</a></h4>
<pre><code class="language-console">$ ./a.out
q⏎
4⏎
1.0 2.0⏎
3.0 2.0⏎
3.0 4.0⏎
1.0 4.0⏎
q
4
1 + 2i
3 + 2i
3 + 4i
1 + 4i
^Z⏎
</code></pre>
<h4 id="circle"><a class="header" href="#circle">Circle</a></h4>
<pre><code class="language-console">$ ./a.out
c⏎
2⏎
1.0 2.0⏎
3.0 4.0⏎
c
2
1 + 2i
3 + 4i
^Z⏎
</code></pre>
<h4 id="polygon"><a class="header" href="#polygon">Polygon</a></h4>
<pre><code class="language-console">$ ./a.out
p⏎
5⏎
1.0 0.0⏎
2.0 1.1⏎
-3.0 -2.2⏎
4.3 2.1⏎
-1.2 3.4⏎
p
5
1
2 + 1.1i
-3 - 2.2i
4.3 + 2.1i
-1.2 + 3.4i
^Z⏎
</code></pre>
<h4 id="multiple-objects"><a class="header" href="#multiple-objects">Multiple Objects</a></h4>
<pre><code class="language-console">$ ./a.out
t⏎
3⏎
1.0 2.0⏎
3.0 4.0⏎
5.0 0.0⏎
t
3
1 + 2i
3 + 4i
5
q⏎
4⏎
1.0 2.0⏎
3.0 2.0⏎
3.0 4.0⏎
1.0 4.0⏎
q
4
1 + 2i
3 + 2i
3 + 4i
1 + 4i
c⏎
2⏎
1.0 2.0⏎
3.0 4.0⏎
c
2
1 + 2i
3 + 4i
p⏎
5⏎
1.0 0.0⏎
2.0 1.1⏎
-3.0 -2.2⏎
4.3 2.1⏎
-1.2 3.4⏎
p
5
1
2 + 1.1i
-3 - 2.2i
4.3 + 2.1i
-1.2 + 3.4i
^Z⏎
</code></pre>
<h3 id="pseudo-code-10"><a class="header" href="#pseudo-code-10">Pseudo Code</a></h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;

using namespace std;

class Geometry_Comp;

class Complex
{
private:
    // data members
    // save the real and imaginary parts of the complex number
    // with `double` precision
    double m_real;
    double m_imag;

public:
    // Constructor, initializes real and imaginary parts
    Complex(const double &amp;arg_real = 0.0, const double &amp;arg_imag = 0.0);
    // Copy constructor
    Complex(const Complex &amp;arg_c);
    // assignment operator
    Complex &amp;operator=(const Complex &amp;arg_c);
    // cout `&lt;&lt;` operator for print complex number
    // note: be careful about the format of output
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex &amp;arg_c);
    // cin `&gt;&gt;` operator for input complex number
    // note: use `&gt;&gt;` to parse the string to double,
    // use `istream::fail()` to check the conversion is successful
    // and use `istream::eof()` to check the is parse to the end of line
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Complex &amp;arg_c);
    // friend class
    friend class Geometry_Comp;
};

class Geometry_Comp
{
protected:
    // data members
    vector&lt;Complex&gt; m_comp_array;

public:
    // Constructor, initializes the array
    Geometry_Comp(const unsigned int &amp;arg_num_of_vertex = 0);
    // Copy constructor
    Geometry_Comp(const Geometry_Comp &amp;arg_gc);
    // assignment operator
    Geometry_Comp &amp;operator=(const Geometry_Comp &amp;arg_gc);
    // print the geometry
    virtual void print_geometry();
    // parse the cin to the geometry
    virtual void parse_geometry(istream &amp;arg_is);
    // set the geometry
    void set_geometry(const vector&lt;Complex&gt; &amp;arg_comp_array);
    // get the geometry array
    vector&lt;Complex&gt; get_geometry_array();
};

class Triangle_Comp : public Geometry_Comp
{
public:
    // Constructor, initializes the array
    Triangle_Comp();
    // Copy constructor
    Triangle_Comp(const Triangle_Comp &amp;arg_tc);
    // assignment operator
    Triangle_Comp &amp;operator=(const Triangle_Comp &amp;arg_tc);
    // print the geometry
    void print_geometry();
    // parse the cin to the geometry
    void parse_geometry(istream &amp;arg_is);
};
const unsigned triangle_num_of_vertex = 3;

class Quadrilateral_Comp : public Geometry_Comp
{
public:
    // Constructor, initializes the array
    Quadrilateral_Comp();
    // Copy constructor
    Quadrilateral_Comp(const Quadrilateral_Comp &amp;arg_qc);
    // assignment operator
    Quadrilateral_Comp &amp;operator=(const Quadrilateral_Comp &amp;arg_qc);
    // print the geometry
    void print_geometry();
    // parse the cin to the geometry
    void parse_geometry(istream &amp;arg_is);
};
const unsigned quadrilateral_num_of_vertex = 4;

class Polygon_Comp : public Geometry_Comp
{
public:
    // Constructor, initializes the array
    Polygon_Comp();
    // Copy constructor
    Polygon_Comp(const Polygon_Comp &amp;arg_pc);
    // assignment operator
    Polygon_Comp &amp;operator=(const Polygon_Comp &amp;arg_pc);
    // print the geometry
    void print_geometry();
    // parse the cin to the geometry
    void parse_geometry(istream &amp;arg_is);
};

class Circle_Comp : public Geometry_Comp
{
public:
    // Constructor, initializes the array
    Circle_Comp();
    // Copy constructor
    Circle_Comp(const Circle_Comp &amp;arg_cc);
    // assignment operator
    Circle_Comp &amp;operator=(const Circle_Comp &amp;arg_cc);
    // print the geometry
    void print_geometry();
    // parse the cin to the geometry
    void parse_geometry(istream &amp;arg_is);
};
const unsigned circle_num_of_vertex = 2;

// error and exit
void error_and_exit()
{
    cout &lt;&lt; &quot;Error: Invalid input&quot; &lt;&lt; endl;
    exit(1);
}

// used for process the test cases, do not modify
int main()
{
    string input;
    Geometry_Comp *geo_ptr = 0;

    while (getline(cin, input))
    {
        // check the geometry type
        switch (input[0])
        {
        case 't':
            geo_ptr = new Triangle_Comp();
            break;
        case 'q':
            geo_ptr = new Quadrilateral_Comp();
            break;
        case 'p':
            geo_ptr = new Polygon_Comp();
            break;
        case 'c':
            geo_ptr = new Circle_Comp();
            break;
        }
        // parse the cin to the geometry
        geo_ptr-&gt;parse_geometry(cin);
        // print the geometry
        geo_ptr-&gt;print_geometry();
        // delete the pointer
        delete geo_ptr;
    }
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="lab-12-2-simple-complex-number-geometry-transformation-40"><a class="header" href="#lab-12-2-simple-complex-number-geometry-transformation-40">Lab 12-2: Simple Complex Number Geometry Transformation (40%)</a></h2>
<ul>
<li>輸入：
<ol>
<li>幾何圖形</li>
<li>以 <code>char</code> 格式輸入幾何圖形形狀，包含三角形 (<code>t</code>)、四邊形 (<code>q</code>)、多邊形 (<code>p</code>)、圓形 (<code>c</code>)，一行輸入一個幾何圖形</li>
<li>以 <code>unsinged int</code> 格式輸入幾何圖形的頂點數，一行輸入一個正整數
<ol>
<li>三角形：3</li>
<li>四邊形：4</li>
<li>多邊形：大於 3 的正整數</li>
<li>圓形：2</li>
</ol>
</li>
<li>以 <code>double</code> 格式輸入組合幾何圖形的複數的實數及虛數部分，以空格分開，一行輸入一個複數</li>
<li>輸入幾何圖形形狀及頂點數後依據 <strong>2.</strong> 的頂點數接著輸入相對應的複數
<ol>
<li>三角形：連續輸入三個複數</li>
<li>四邊形：連續輸入四個複數</li>
<li>多邊形：連續輸入多個複數</li>
<li>圓形：連續輸入兩個複數</li>
</ol>
</li>
<li>幾何變換</li>
<li>以 <code>char</code> 格式輸入幾何變換字元，包含以 <code>0</code> 點旋轉 (<code>r</code>)、以 <code>0</code> 點縮放 (<code>z</code>)、平移 (<code>m</code>)，一行輸入一個幾何變換</li>
<li>以 <code>double</code> 格式輸入幾何變換的複數的實數及虛數部分，以空格分開，一行輸入一個複數
<ol>
<li>以 <code>0</code> 點旋轉：\(z * (cos(\theta) + sin(\theta)i), norm = 1\)</li>
<li>以 <code>0</code> 點縮放：\(z * (r + 0i)\)</li>
<li>平移：\(z + (x + yi)\)</li>
</ol>
</li>
<li>輸入幾何變換後須將所有的幾何圖形複數變換</li>
<li>輸入 <kbd>Ctrl</kbd>+<kbd>D</kbd> 結束程式
<ul>
<li>Windows 請輸入 <kbd>Ctrl</kbd>+<kbd>Z</kbd> (會在螢幕上顯示 <code>^Z</code>) 再輸入 <kbd>Enter</kbd> (Format 中的 <code>⏎</code>) 完成輸入</li>
</ul>
</li>
</ol>
</li>
<li>輸出：
<ol>
<li>幾何圖形
<ol>
<li>顯示紀錄幾何圖形的形狀、頂點個數及其複數
<ol>
<li>格式請參考 <a href="oop/lab/lab12-2.html#format">Format</a> 中的說明</li>
<li>頂點順序與輸入順序相同</li>
</ol>
</li>
<li>複數的格式為 <code>(-)&lt;real result&gt; (+|-) (&lt;imag result&gt;i)</code>
<ol>
<li>若虛數部分為 0 則僅顯示實數部分</li>
<li>若虛數部分小於 0 則中間的 <code>+</code> 要改成 <code>-</code>，並且虛數部分要顯示絕對值</li>
</ol>
</li>
<li>虛數及實數部分皆以預設 <code>double</code> 格式顯示</li>
</ol>
</li>
<li>幾何變換
<ol>
<li>輸出變換後的所有幾何圖形複數</li>
</ol>
</li>
</ol>
</li>
<li>檔名：<code>lab12-2_&lt;學號&gt;.cpp</code> (e.g. <code>lab12-2_106062802.cpp</code>)</li>
</ul>
<p>注意事項：</p>
<ul>
<li>程式不會輸出任何使用者提示，只會輸出程式結果</li>
<li>使用者不需要處理錯誤輸入</li>
<li>請使用 pseudo code 提供的 <code>main</code> 來處理輸入與輸出</li>
<li>程式需要於 10 秒內完成，所有的測資皆會保證於 10 秒內完成</li>
</ul>
<h3 id="format-11"><a class="header" href="#format-11">Format</a></h3>
<h4 id="input"><a class="header" href="#input">Input</a></h4>
<pre><code class="language-text">&lt;geometry type&gt;⏎
n⏎
&lt;real 1&gt; &lt;imag 1&gt;⏎
&lt;real 2&gt; &lt;imag 2&gt;⏎
...
&lt;real n&gt; &lt;imag n&gt;⏎
&lt;geometry type&gt;
n
(-)&lt;real 1&gt; (+|-) (&lt;imag 1&gt;i)
(-)&lt;real 2&gt; (+|-) (&lt;imag 2&gt;i)
...
(-)&lt;real n&gt; (+|-) (&lt;imag n&gt;i)
</code></pre>
<h4 id="transformation"><a class="header" href="#transformation">Transformation</a></h4>
<pre><code class="language-text">&lt;geometry type 1&gt;⏎
n⏎
&lt;real 1&gt; &lt;imag 1&gt;⏎
&lt;real 2&gt; &lt;imag 2&gt;⏎
...
&lt;real n&gt; &lt;imag n&gt;⏎
&lt;geometry type 1&gt;
n
(-)&lt;real 1&gt; (+|-) (&lt;imag 1&gt;i)
(-)&lt;real 2&gt; (+|-) (&lt;imag 2&gt;i)
...
(-)&lt;real n&gt; (+|-) (&lt;imag n&gt;i)
&lt;geometry type 2&gt;⏎
n⏎
&lt;real 1&gt; &lt;imag 1&gt;⏎
&lt;real 2&gt; &lt;imag 2&gt;⏎
...
&lt;real n&gt; &lt;imag n&gt;⏎
&lt;geometry type 2&gt;
n
(-)&lt;real 1&gt; (+|-) (&lt;imag 1&gt;i)
(-)&lt;real 2&gt; (+|-) (&lt;imag 2&gt;i)
...
(-)&lt;real n&gt; (+|-) (&lt;imag n&gt;i)
&lt;geometry transformation type&gt;⏎
(-)&lt;real trans&gt; (+|-) (&lt;imag trans&gt;i)⏎
&lt;geometry type 1&gt;
n
(-)&lt;real 1&gt; (+|-) (&lt;imag 1&gt;i)
(-)&lt;real 2&gt; (+|-) (&lt;imag 2&gt;i)
...
(-)&lt;real n&gt; (+|-) (&lt;imag n&gt;i)
&lt;geometry type 2&gt;
n
(-)&lt;real 1&gt; (+|-) (&lt;imag 1&gt;i)
(-)&lt;real 2&gt; (+|-) (&lt;imag 2&gt;i)
...
(-)&lt;real n&gt; (+|-) (&lt;imag n&gt;i)
...
^Z⏎
</code></pre>
<h3 id="example-12"><a class="header" href="#example-12">Example</a></h3>
<h4 id="input-1"><a class="header" href="#input-1">Input</a></h4>
<h5 id="triangle-1"><a class="header" href="#triangle-1">Triangle</a></h5>
<pre><code class="language-console">$ ./a.out
t⏎
3⏎
1.0 2.0⏎
3.0 4.0⏎
5.0 0.0⏎
t
3
1 + 2i
3 + 4i
5
^Z⏎
</code></pre>
<h5 id="quadrilateral-1"><a class="header" href="#quadrilateral-1">Quadrilateral</a></h5>
<pre><code class="language-console">$ ./a.out
q⏎
4⏎
1.0 2.0⏎
3.0 2.0⏎
3.0 4.0⏎
1.0 4.0⏎
q
4
1 + 2i
3 + 2i
3 + 4i
1 + 4i
^Z⏎
</code></pre>
<h5 id="circle-1"><a class="header" href="#circle-1">Circle</a></h5>
<pre><code class="language-console">$ ./a.out
c⏎
2⏎
1.0 2.0⏎
3.0 4.0⏎
c
2
1 + 2i
3 + 4i
^Z⏎
</code></pre>
<h5 id="polygon-1"><a class="header" href="#polygon-1">Polygon</a></h5>
<pre><code class="language-console">$ ./a.out
p⏎
5⏎
1.0 0.0⏎
2.0 1.1⏎
-3.0 -2.2⏎
4.3 2.1⏎
-1.2 3.4⏎
p
5
1
2 + 1.1i
-3 - 2.2i
4.3 + 2.1i
-1.2 + 3.4i
^Z⏎
</code></pre>
<h5 id="multiple-objects-1"><a class="header" href="#multiple-objects-1">Multiple Objects</a></h5>
<pre><code class="language-console">$ ./a.out
t⏎
3⏎
1.0 2.0⏎
3.0 4.0⏎
5.0 0.0⏎
t
3
1 + 2i
3 + 4i
5
q⏎
4⏎
1.0 2.0⏎
3.0 2.0⏎
3.0 4.0⏎
1.0 4.0⏎
q
4
1 + 2i
3 + 2i
3 + 4i
1 + 4i
c⏎
2⏎
1.0 2.0⏎
3.0 4.0⏎
c
2
1 + 2i
3 + 4i
p⏎
5⏎
1.0 0.0⏎
2.0 1.1⏎
-3.0 -2.2⏎
4.3 2.1⏎
-1.2 3.4⏎
p
5
1
2 + 1.1i
-3 - 2.2i
4.3 + 2.1i
-1.2 + 3.4i
^Z⏎
</code></pre>
<h4 id="transformation-1"><a class="header" href="#transformation-1">Transformation</a></h4>
<h5 id="scaling"><a class="header" href="#scaling">Scaling</a></h5>
<pre><code class="language-console">$ ./a.out
t⏎
3⏎
1.0 2.0⏎
3.0 4.0⏎
5.0 0.0⏎
t
3
1 + 2i
3 + 4i
5
z⏎
2.0 0.0⏎
t
3
2 + 4i
6 + 8i
10
^Z⏎
</code></pre>
<h5 id="translation"><a class="header" href="#translation">Translation</a></h5>
<pre><code class="language-console">$ ./a.out
q⏎
4⏎
1.0 2.0⏎
3.0 2.0⏎
3.0 4.0⏎
1.0 4.0⏎
q
4
1 + 2i
3 + 2i
3 + 4i
1 + 4i
m⏎
3.0 -1.0⏎
q
4
4 + 1i
6 + 1i
6 + 3i
4 + 3i
^Z⏎
</code></pre>
<h5 id="rotation"><a class="header" href="#rotation">Rotation</a></h5>
<pre><code class="language-console">$ ./a.out
c⏎
2⏎
1.0 2.0⏎
3.0 4.0⏎
c
2
1 + 2i
3 + 4i
r⏎
0.99990604980155 0.013707354604752⏎
c
2
0.972491 + 2.01352i
2.94489 + 4.04075i
^Z⏎
</code></pre>
<h5 id="multiple-transformations"><a class="header" href="#multiple-transformations">Multiple Transformations</a></h5>
<pre><code class="language-console">$ ./a.out
p⏎
5⏎
1.0 0.0⏎
2.0 1.1⏎
-3.0 -2.2⏎
4.3 2.1⏎
-1.2 3.4⏎
p
5
1
2 + 1.1i
-3 - 2.2i
4.3 + 2.1i
-1.2 + 3.4i
z⏎
2.0 0.0⏎
p
5
2
4 + 2.2i
-6 - 4.4i
8.6 + 4.2i
-2.4 + 6.8i
m⏎
3.0 -1.0⏎
p
5
5 - 1i
7 + 1.2i
-3 - 5.4i
11.6 + 3.2i
0.6 + 5.8i
r⏎
0.99990604980155 0.013707354604752⏎
p
5
5.01324 - 0.931369i
6.98289 + 1.29584i
-2.9257 - 5.44061i
11.555 + 3.3587i
0.520441 + 5.80768i
^Z⏎
</code></pre>
<h5 id="multiple-transformations-on-multiple-objects"><a class="header" href="#multiple-transformations-on-multiple-objects">Multiple Transformations on Multiple Objects</a></h5>
<pre><code class="language-console">$ ./a.out
t⏎
3⏎
1.0 2.0⏎
3.0 4.0⏎
5.0 0.0⏎
t
3
1 + 2i
3 + 4i
5
q⏎
4⏎
1.0 2.0⏎
3.0 2.0⏎
3.0 4.0⏎
1.0 4.0⏎
q
4
1 + 2i
3 + 2i
3 + 4i
1 + 4i
c⏎
2⏎
1.0 2.0⏎
3.0 4.0⏎
c
2
1 + 2i
3 + 4i
p⏎
5⏎
1.0 0.0⏎
2.0 1.1⏎
-3.0 -2.2⏎
4.3 2.1⏎
-1.2 3.4⏎
p
5
1
2 + 1.1i
-3 - 2.2i
4.3 + 2.1i
-1.2 + 3.4i
z⏎
2.0 0.0⏎
t
3
2 + 4i
6 + 8i
10
q
4
2 + 4i
6 + 4i
6 + 8i
2 + 8i
c
2
2 + 4i
6 + 8i
p
5
2
4 + 2.2i
-6 - 4.4i
8.6 + 4.2i
-2.4 + 6.8i
m⏎
3.0 -1.0⏎
t
3
5 + 3i
9 + 7i
13 - 1i
q
4
5 + 3i
9 + 3i
9 + 7i
5 + 7i
c
2
5 + 3i
9 + 7i
p
5
5 - 1i
7 + 1.2i
-3 - 5.4i
11.6 + 3.2i
0.6 + 5.8i
r⏎
0.99990604980155 0.013707354604752⏎
t
3
4.95841 + 3.06825i
8.9032 + 7.12271i
13.0125 - 0.82171i
q
4
4.95841 + 3.06825i
8.95803 + 3.12308i
8.9032 + 7.12271i
4.90358 + 7.06788i
c
2
4.95841 + 3.06825i
8.9032 + 7.12271i
p
5
5.01324 - 0.931369i
6.98289 + 1.29584i
-2.9257 - 5.44061i
11.555 + 3.3587i
0.520441 + 5.80768i
^Z⏎
</code></pre>
<h3 id="pseudo-code-11"><a class="header" href="#pseudo-code-11">Pseudo Code</a></h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;

using namespace std;

class Geometry_Comp;

class Complex
{
private:
    // data members
    // save the real and imaginary parts of the complex number
    // with `double` precision
    double m_real;
    double m_imag;

public:
    // Constructor, initializes real and imaginary parts
    Complex(const double &amp;arg_real = 0.0, const double &amp;arg_imag = 0.0);
    // Copy constructor
    Complex(const Complex &amp;arg_c);
    // assignment operator
    Complex &amp;operator=(const Complex &amp;arg_c);
    // add assignment operator
    Complex &amp;operator+=(const Complex &amp;arg_c);
    // multiply assignment operator
    Complex &amp;operator*=(const Complex &amp;arg_c);
    // length of the complex number
    double length() const;
    // angle of the complex number in radians
    // use `atan2` to compute the angle by the formula `atan(imag/real)`
    // and use `NAN` for 0/0 case
    // `atan2` ref: https://en.cppreference.com/w/cpp/numeric/math/atan2
    // `NAN` ref: https://en.cppreference.com/w/cpp/numeric/math/NAN
    double angle() const;
    // cout `&lt;&lt;` operator for print complex number
    // note: be careful about the format of output
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex &amp;arg_c);
    // cin `&gt;&gt;` operator for input complex number
    // note: use `&gt;&gt;` to parse the string to double,
    // use `istream::fail()` to check the conversion is successful
    // and use `istream::eof()` to check the is parse to the end of line
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Complex &amp;arg_c);
    // friend class
    friend class Geometry_Comp;
};

class Geometry_Comp
{
protected:
    // data members
    vector&lt;Complex&gt; m_comp_array;
    // utility function to check if the transformation is valid
    // hint: use `isnan` to check the angle is valid or not
    // ref: https://en.cppreference.com/w/cpp/numeric/math/isnan
    bool _check_transform(const Complex &amp;arg_trans_c, const char &amp;arg_op);

public:
    // Constructor, initializes the array
    Geometry_Comp(const unsigned int &amp;arg_num_of_vertex = 0);
    // Copy constructor
    Geometry_Comp(const Geometry_Comp &amp;arg_gc);
    // assignment operator
    Geometry_Comp &amp;operator=(const Geometry_Comp &amp;arg_gc);
    // print the geometry
    virtual void print_geometry();
    // parse the cin to the geometry
    virtual void parse_geometry(istream &amp;arg_is);
    // apply transformation to the geometry
    void transform_geometry(const Complex &amp;arg_trans_c, const char &amp;arg_op);
    // set the geometry
    void set_geometry(const vector&lt;Complex&gt; &amp;arg_comp_array);
    // get the geometry array
    vector&lt;Complex&gt; get_geometry_array();
};

class Triangle_Comp : public Geometry_Comp
{
public:
    // Constructor, initializes the array
    Triangle_Comp();
    // Copy constructor
    Triangle_Comp(const Triangle_Comp &amp;arg_tc);
    // assignment operator
    Triangle_Comp &amp;operator=(const Triangle_Comp &amp;arg_tc);
    // print the geometry
    void print_geometry();
    // parse the cin to the geometry
    void parse_geometry(istream &amp;arg_is);
};
const unsigned triangle_num_of_vertex = 3;

class Quadrilateral_Comp : public Geometry_Comp
{
public:
    // Constructor, initializes the array
    Quadrilateral_Comp();
    // Copy constructor
    Quadrilateral_Comp(const Quadrilateral_Comp &amp;arg_qc);
    // assignment operator
    Quadrilateral_Comp &amp;operator=(const Quadrilateral_Comp &amp;arg_qc);
    // print the geometry
    void print_geometry();
    // parse the cin to the geometry
    void parse_geometry(istream &amp;arg_is);
};
const unsigned quadrilateral_num_of_vertex = 4;

class Polygon_Comp : public Geometry_Comp
{
public:
    // Constructor, initializes the array
    Polygon_Comp();
    // Copy constructor
    Polygon_Comp(const Polygon_Comp &amp;arg_pc);
    // assignment operator
    Polygon_Comp &amp;operator=(const Polygon_Comp &amp;arg_pc);
    // print the geometry
    void print_geometry();
    // parse the cin to the geometry
    void parse_geometry(istream &amp;arg_is);
};

class Circle_Comp : public Geometry_Comp
{
public:
    // Constructor, initializes the array
    Circle_Comp();
    // Copy constructor
    Circle_Comp(const Circle_Comp &amp;arg_cc);
    // assignment operator
    Circle_Comp &amp;operator=(const Circle_Comp &amp;arg_cc);
    // print the geometry
    void print_geometry();
    // parse the cin to the geometry
    void parse_geometry(istream &amp;arg_is);
};
const unsigned circle_num_of_vertex = 2;

// error and exit
void error_and_exit()
{
    cout &lt;&lt; &quot;Error: Invalid input&quot; &lt;&lt; endl;
    exit(1);
}

// used for process the test cases, do not modify
int main()
{
    string input, temp;
    vector&lt;Geometry_Comp *&gt; geo_ptr_array;
    Geometry_Comp *geo_ptr;
    Complex trans_c;
    char trans_op;

    while (getline(cin, input))
    {
        // check the geometry type
        switch (input[0])
        {
        case 't':
            geo_ptr = new Triangle_Comp();
            break;
        case 'q':
            geo_ptr = new Quadrilateral_Comp();
            break;
        case 'p':
            geo_ptr = new Polygon_Comp();
            break;
        case 'c':
            geo_ptr = new Circle_Comp();
            break;
        case 'r':
        case 'z':
        case 'm':
            getline(cin, temp);
            break;
        }
        if (input[0] == 't' || input[0] == 'q' || input[0] == 'p' || input[0] == 'c')
        {
            // parse the cin to the geometry
            geo_ptr-&gt;parse_geometry(cin);
            // print the geometry
            geo_ptr-&gt;print_geometry();
            // push the pointer to the array
            geo_ptr_array.push_back(geo_ptr);
        }
        else if (input[0] == 'r' || input[0] == 'z' || input[0] == 'm')
        {
            stringstream ss(temp);
            ss &gt;&gt; trans_c;
            // transform the geometry using operator and complex
            for (int i = 0; i &lt; geo_ptr_array.size(); i++)
            {
                geo_ptr_array[i]-&gt;transform_geometry(trans_c, input[0]);
                // print transformed geometry
                geo_ptr_array[i]-&gt;print_geometry();
            }
        }
    }
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="lab-12-3-enhanced-complex-number-geometry-transformation-20"><a class="header" href="#lab-12-3-enhanced-complex-number-geometry-transformation-20">Lab 12-3: Enhanced Complex Number Geometry Transformation (20%)</a></h2>
<ul>
<li>輸入：
<ol>
<li>幾何圖形</li>
<li>以 <code>char</code> 格式輸入幾何圖形形狀，包含三角形 (<code>t</code>)、四邊形 (<code>q</code>)、多邊形 (<code>p</code>)、圓形 (<code>c</code>)，一行輸入一個幾何圖形</li>
<li>以 <code>unsinged int</code> 格式輸入幾何圖形的頂點數，一行輸入一個正整數
<ol>
<li>三角形：3</li>
<li>四邊形：4</li>
<li>多邊形：大於 3 的正整數</li>
<li>圓形：2</li>
</ol>
</li>
<li>以 <code>double</code> 格式輸入組合幾何圖形的複數的實數及虛數部分，以空格分開，一行輸入一個複數</li>
<li>輸入幾何圖形形狀及頂點數後依據 <strong>2.</strong> 的頂點數接著輸入相對應的複數
<ol>
<li>三角形：連續輸入三個複數</li>
<li>四邊形：連續輸入四個複數</li>
<li>多邊形：連續輸入多個複數</li>
<li>圓形：連續輸入兩個複數</li>
</ol>
</li>
<li>幾何變換</li>
<li>以 <code>char</code> 格式輸入幾何變換字元，包含以 <code>0</code> 點旋轉 (<code>r</code>)、以 <code>0</code> 點縮放 (<code>z</code>)、平移 (<code>m</code>)，一行輸入一個幾何變換</li>
<li>以 <code>double</code> 格式輸入幾何變換的複數的實數及虛數部分，以空格分開，一行輸入一個複數
<ol>
<li>以 <code>0</code> 點旋轉：\(z * (cos(\theta) + sin(\theta)i), norm = 1\)</li>
<li>以 <code>0</code> 點縮放：\(z * (r + 0i)\)</li>
<li>平移：\(z + (x + yi)\)</li>
</ol>
</li>
<li>輸入幾何變換後須將所有的幾何圖形複數變換</li>
<li>輸入 <kbd>Ctrl</kbd>+<kbd>D</kbd> 結束程式
<ul>
<li>Windows 請輸入 <kbd>Ctrl</kbd>+<kbd>Z</kbd> (會在螢幕上顯示 <code>^Z</code>) 再輸入 <kbd>Enter</kbd> (Format 中的 <code>⏎</code>) 完成輸入</li>
</ul>
</li>
<li>程式輸入以行為單位，每行輸入為任何有效的 <code>string</code> 格式</li>
</ol>
</li>
<li>輸出：
<ol>
<li>幾何圖形
<ol>
<li>顯示紀錄幾何圖形的形狀、頂點個數及其複數
<ol>
<li>格式請參考 <a href="oop/lab/lab12-3.html#format">Format</a> 中的說明</li>
<li>頂點順序與輸入順序相同</li>
</ol>
</li>
<li>複數的格式為 <code>(-)&lt;real result&gt; (+|-) (&lt;imag result&gt;i)</code>
<ol>
<li>若虛數部分為 0 則僅顯示實數部分</li>
<li>若虛數部分小於 0 則中間的 <code>+</code> 要改成 <code>-</code>，並且虛數部分要顯示絕對值</li>
</ol>
</li>
<li>虛數及實數部分皆以預設 <code>double</code> 格式顯示</li>
</ol>
</li>
<li>幾何變換
<ol>
<li>輸出變換後的所有幾何圖形複數</li>
</ol>
</li>
<li>若使用者輸入的複數、幾何圖形或幾何變換不正確，則顯示錯誤訊息 <code>Error: Invalid input</code> 並結束程式</li>
</ol>
</li>
<li>檔名：<code>lab12-3_&lt;學號&gt;.cpp</code> (e.g. <code>lab12-3_106062802.cpp</code>)</li>
</ul>
<p>注意事項：</p>
<ul>
<li>程式不會輸出任何使用者提示，只會輸出程式結果或錯誤訊息</li>
<li>程式僅需處裡輸入格式錯誤的例外狀況，如輸入的複數、幾何圖形或幾何變換不正確，其餘錯誤不須處裡</li>
<li>請基於 pseudo code 提供的 <code>main</code> 進行修改來處理輸入與輸出</li>
<li>程式需要於 10 秒內完成，所有的測資皆會保證於 10 秒內完成</li>
</ul>
<h3 id="format-12"><a class="header" href="#format-12">Format</a></h3>
<h4 id="input-2"><a class="header" href="#input-2">Input</a></h4>
<pre><code class="language-text">&lt;geometry type&gt;⏎
n⏎
&lt;real 1&gt; &lt;imag 1&gt;⏎
&lt;real 2&gt; &lt;imag 2&gt;⏎
...
&lt;real n&gt; &lt;imag n&gt;⏎
&lt;geometry type&gt;
n
(-)&lt;real 1&gt; (+|-) (&lt;imag 1&gt;i)
(-)&lt;real 2&gt; (+|-) (&lt;imag 2&gt;i)
...
(-)&lt;real n&gt; (+|-) (&lt;imag n&gt;i)
</code></pre>
<h4 id="transformation-2"><a class="header" href="#transformation-2">Transformation</a></h4>
<pre><code class="language-text">&lt;geometry type 1&gt;⏎
n⏎
&lt;real 1&gt; &lt;imag 1&gt;⏎
&lt;real 2&gt; &lt;imag 2&gt;⏎
...
&lt;real n&gt; &lt;imag n&gt;⏎
&lt;geometry type 1&gt;
n
(-)&lt;real 1&gt; (+|-) (&lt;imag 1&gt;i)
(-)&lt;real 2&gt; (+|-) (&lt;imag 2&gt;i)
...
(-)&lt;real n&gt; (+|-) (&lt;imag n&gt;i)
&lt;geometry type 2&gt;⏎
n⏎
&lt;real 1&gt; &lt;imag 1&gt;⏎
&lt;real 2&gt; &lt;imag 2&gt;⏎
...
&lt;real n&gt; &lt;imag n&gt;⏎
&lt;geometry type 2&gt;
n
(-)&lt;real 1&gt; (+|-) (&lt;imag 1&gt;i)
(-)&lt;real 2&gt; (+|-) (&lt;imag 2&gt;i)
...
(-)&lt;real n&gt; (+|-) (&lt;imag n&gt;i)
&lt;geometry transformation type&gt;⏎
(-)&lt;real trans&gt; (+|-) (&lt;imag trans&gt;i)⏎
&lt;geometry type 1&gt;
n
(-)&lt;real 1&gt; (+|-) (&lt;imag 1&gt;i)
(-)&lt;real 2&gt; (+|-) (&lt;imag 2&gt;i)
...
(-)&lt;real n&gt; (+|-) (&lt;imag n&gt;i)
&lt;geometry type 2&gt;
n
(-)&lt;real 1&gt; (+|-) (&lt;imag 1&gt;i)
(-)&lt;real 2&gt; (+|-) (&lt;imag 2&gt;i)
...
(-)&lt;real n&gt; (+|-) (&lt;imag n&gt;i)
...
^Z⏎
</code></pre>
<h3 id="example-13"><a class="header" href="#example-13">Example</a></h3>
<h4 id="input-3"><a class="header" href="#input-3">Input</a></h4>
<h5 id="triangle-2"><a class="header" href="#triangle-2">Triangle</a></h5>
<pre><code class="language-console">$ ./a.out
t⏎
3⏎
1.0 2.0⏎
3.0 4.0⏎
5.0 0.0⏎
t
3
1 + 2i
3 + 4i
5
^Z⏎
</code></pre>
<h5 id="quadrilateral-2"><a class="header" href="#quadrilateral-2">Quadrilateral</a></h5>
<pre><code class="language-console">$ ./a.out
q⏎
4⏎
1.0 2.0⏎
3.0 2.0⏎
3.0 4.0⏎
1.0 4.0⏎
q
4
1 + 2i
3 + 2i
3 + 4i
1 + 4i
^Z⏎
</code></pre>
<h5 id="circle-2"><a class="header" href="#circle-2">Circle</a></h5>
<pre><code class="language-console">$ ./a.out
c⏎
2⏎
1.0 2.0⏎
3.0 4.0⏎
c
2
1 + 2i
3 + 4i
^Z⏎
</code></pre>
<h5 id="polygon-2"><a class="header" href="#polygon-2">Polygon</a></h5>
<pre><code class="language-console">$ ./a.out
p⏎
5⏎
1.0 0.0⏎
2.0 1.1⏎
-3.0 -2.2⏎
4.3 2.1⏎
-1.2 3.4⏎
p
5
1
2 + 1.1i
-3 - 2.2i
4.3 + 2.1i
-1.2 + 3.4i
^Z⏎
</code></pre>
<h5 id="multiple-objects-2"><a class="header" href="#multiple-objects-2">Multiple Objects</a></h5>
<pre><code class="language-console">$ ./a.out
t⏎
3⏎
1.0 2.0⏎
3.0 4.0⏎
5.0 0.0⏎
t
3
1 + 2i
3 + 4i
5
q⏎
4⏎
1.0 2.0⏎
3.0 2.0⏎
3.0 4.0⏎
1.0 4.0⏎
q
4
1 + 2i
3 + 2i
3 + 4i
1 + 4i
c⏎
2⏎
1.0 2.0⏎
3.0 4.0⏎
c
2
1 + 2i
3 + 4i
p⏎
5⏎
1.0 0.0⏎
2.0 1.1⏎
-3.0 -2.2⏎
4.3 2.1⏎
-1.2 3.4⏎
p
5
1
2 + 1.1i
-3 - 2.2i
4.3 + 2.1i
-1.2 + 3.4i
^Z⏎
</code></pre>
<h4 id="transformation-3"><a class="header" href="#transformation-3">Transformation</a></h4>
<h5 id="scaling-1"><a class="header" href="#scaling-1">Scaling</a></h5>
<pre><code class="language-console">$ ./a.out
t⏎
3⏎
1.0 2.0⏎
3.0 4.0⏎
5.0 0.0⏎
t
3
1 + 2i
3 + 4i
5
z⏎
2.0 0.0⏎
t
3
2 + 4i
6 + 8i
10
^Z⏎
</code></pre>
<h5 id="translation-1"><a class="header" href="#translation-1">Translation</a></h5>
<pre><code class="language-console">$ ./a.out
q⏎
4⏎
1.0 2.0⏎
3.0 2.0⏎
3.0 4.0⏎
1.0 4.0⏎
q
4
1 + 2i
3 + 2i
3 + 4i
1 + 4i
m⏎
3.0 -1.0⏎
q
4
4 + 1i
6 + 1i
6 + 3i
4 + 3i
^Z⏎
</code></pre>
<h5 id="rotation-1"><a class="header" href="#rotation-1">Rotation</a></h5>
<pre><code class="language-console">$ ./a.out
c⏎
2⏎
1.0 2.0⏎
3.0 4.0⏎
c
2
1 + 2i
3 + 4i
r⏎
0.99990604980155 0.013707354604752⏎
c
2
0.972491 + 2.01352i
2.94489 + 4.04075i
^Z⏎
</code></pre>
<h5 id="multiple-transformations-1"><a class="header" href="#multiple-transformations-1">Multiple Transformations</a></h5>
<pre><code class="language-console">$ ./a.out
p⏎
5⏎
1.0 0.0⏎
2.0 1.1⏎
-3.0 -2.2⏎
4.3 2.1⏎
-1.2 3.4⏎
p
5
1
2 + 1.1i
-3 - 2.2i
4.3 + 2.1i
-1.2 + 3.4i
z⏎
2.0 0.0⏎
p
5
2
4 + 2.2i
-6 - 4.4i
8.6 + 4.2i
-2.4 + 6.8i
m⏎
3.0 -1.0⏎
p
5
5 - 1i
7 + 1.2i
-3 - 5.4i
11.6 + 3.2i
0.6 + 5.8i
r⏎
0.99990604980155 0.013707354604752⏎
p
5
5.01324 - 0.931369i
6.98289 + 1.29584i
-2.9257 - 5.44061i
11.555 + 3.3587i
0.520441 + 5.80768i
^Z⏎
</code></pre>
<h5 id="multiple-transformations-on-multiple-objects-1"><a class="header" href="#multiple-transformations-on-multiple-objects-1">Multiple Transformations on Multiple Objects</a></h5>
<pre><code class="language-console">$ ./a.out
t⏎
3⏎
1.0 2.0⏎
3.0 4.0⏎
5.0 0.0⏎
t
3
1 + 2i
3 + 4i
5
q⏎
4⏎
1.0 2.0⏎
3.0 2.0⏎
3.0 4.0⏎
1.0 4.0⏎
q
4
1 + 2i
3 + 2i
3 + 4i
1 + 4i
c⏎
2⏎
1.0 2.0⏎
3.0 4.0⏎
c
2
1 + 2i
3 + 4i
p⏎
5⏎
1.0 0.0⏎
2.0 1.1⏎
-3.0 -2.2⏎
4.3 2.1⏎
-1.2 3.4⏎
p
5
1
2 + 1.1i
-3 - 2.2i
4.3 + 2.1i
-1.2 + 3.4i
z⏎
2.0 0.0⏎
t
3
2 + 4i
6 + 8i
10
q
4
2 + 4i
6 + 4i
6 + 8i
2 + 8i
c
2
2 + 4i
6 + 8i
p
5
2
4 + 2.2i
-6 - 4.4i
8.6 + 4.2i
-2.4 + 6.8i
m⏎
3.0 -1.0⏎
t
3
5 + 3i
9 + 7i
13 - 1i
q
4
5 + 3i
9 + 3i
9 + 7i
5 + 7i
c
2
5 + 3i
9 + 7i
p
5
5 - 1i
7 + 1.2i
-3 - 5.4i
11.6 + 3.2i
0.6 + 5.8i
r⏎
0.99990604980155 0.013707354604752⏎
t
3
4.95841 + 3.06825i
8.9032 + 7.12271i
13.0125 - 0.82171i
q
4
4.95841 + 3.06825i
8.95803 + 3.12308i
8.9032 + 7.12271i
4.90358 + 7.06788i
c
2
4.95841 + 3.06825i
8.9032 + 7.12271i
p
5
5.01324 - 0.931369i
6.98289 + 1.29584i
-2.9257 - 5.44061i
11.555 + 3.3587i
0.520441 + 5.80768i
^Z⏎
</code></pre>
<h4 id="exception-handling-3"><a class="header" href="#exception-handling-3">Exception Handling</a></h4>
<h5 id="wrong-object-type-or-transformation-type"><a class="header" href="#wrong-object-type-or-transformation-type">Wrong object type or transformation type</a></h5>
<pre><code class="language-console">$ ./a.out
a⏎
Error: Invalid input
$ ./a.out
t⏎
3⏎
1.0 2.0⏎
3.0 4.0⏎
5.0 0.0⏎
t
3
1 + 2i
3 + 4i
5
l⏎
Error: Invalid input
</code></pre>
<h5 id="wrong-object-or-veterx-format"><a class="header" href="#wrong-object-or-veterx-format">Wrong object or veterx format</a></h5>
<pre><code class="language-console">$ ./a.out
t⏎
1234adsfdf⏎
Error: Invalid input
$ ./a.out
t⏎
5⏎
Error: Invalid input
$ ./a.out
$ ./a.out
t⏎
3⏎
1.0 2.0⏎
3.0 4.0⏎
5.0 0.0⏎
t
3
1 + 2i
3 + 4i
5
3.0 2.0⏎
Error: Invalid input
</code></pre>
<h5 id="wrong-complex-number-format"><a class="header" href="#wrong-complex-number-format">Wrong complex number format</a></h5>
<pre><code class="language-console">$ ./a.out
t⏎
3⏎
asdfjsoidfjpsdiofj⏎
Error: Invalid input
$ ./a.out
t⏎
3⏎
1.0 asdfjsoidfjpsdiofj⏎
Error: Invalid input
$ ./a.out
t⏎
3⏎
1.0⏎
Error: Invalid input
</code></pre>
<h3 id="pseudo-code-12"><a class="header" href="#pseudo-code-12">Pseudo Code</a></h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;

using namespace std;

class Geometry_Comp;

class Complex
{
private:
    // data members
    // save the real and imaginary parts of the complex number
    // with `double` precision
    double m_real;
    double m_imag;

public:
    // Constructor, initializes real and imaginary parts
    Complex(const double &amp;arg_real = 0.0, const double &amp;arg_imag = 0.0);
    // Copy constructor
    Complex(const Complex &amp;arg_c);
    // assignment operator
    Complex &amp;operator=(const Complex &amp;arg_c);
    // add assignment operator
    Complex &amp;operator+=(const Complex &amp;arg_c);
    // multiply assignment operator
    Complex &amp;operator*=(const Complex &amp;arg_c);
    // length of the complex number
    double length() const;
    // angle of the complex number in radians
    // use `atan2` to compute the angle by the formula `atan(imag/real)`
    // and use `NAN` for 0/0 case
    // `atan2` ref: https://en.cppreference.com/w/cpp/numeric/math/atan2
    // `NAN` ref: https://en.cppreference.com/w/cpp/numeric/math/NAN
    double angle() const;
    // cout `&lt;&lt;` operator for print complex number
    // note: be careful about the format of output
    friend ostream &amp;operator&lt;&lt;(ostream &amp;arg_os, const Complex &amp;arg_c);
    // cin `&gt;&gt;` operator for input complex number
    // note: use `&gt;&gt;` to parse the string to double,
    // use `istream::fail()` to check the conversion is successful
    // and use `istream::eof()` to check the is parse to the end of line
    friend istream &amp;operator&gt;&gt;(istream &amp;arg_is, Complex &amp;arg_c);
    // friend class
    friend class Geometry_Comp;
};

class Geometry_Comp
{
protected:
    // data members
    vector&lt;Complex&gt; m_comp_array;
    // utility function to check if the transformation is valid
    // hint: use `isnan` to check the angle is valid or not
    // ref: https://en.cppreference.com/w/cpp/numeric/math/isnan
    bool _check_transform(const Complex &amp;arg_trans_c, const char &amp;arg_op);

public:
    // Constructor, initializes the array
    Geometry_Comp(const unsigned int &amp;arg_num_of_vertex = 0);
    // Copy constructor
    Geometry_Comp(const Geometry_Comp &amp;arg_gc);
    // assignment operator
    Geometry_Comp &amp;operator=(const Geometry_Comp &amp;arg_gc);
    // print the geometry
    virtual void print_geometry();
    // parse the cin to the geometry
    virtual void parse_geometry(istream &amp;arg_is);
    // apply transformation to the geometry
    void transform_geometry(const Complex &amp;arg_trans_c, const char &amp;arg_op);
    // set the geometry
    void set_geometry(const vector&lt;Complex&gt; &amp;arg_comp_array);
    // get the geometry array
    vector&lt;Complex&gt; get_geometry_array();
};

class Triangle_Comp : public Geometry_Comp
{
public:
    // Constructor, initializes the array
    Triangle_Comp();
    // Copy constructor
    Triangle_Comp(const Triangle_Comp &amp;arg_tc);
    // assignment operator
    Triangle_Comp &amp;operator=(const Triangle_Comp &amp;arg_tc);
    // print the geometry
    void print_geometry();
    // parse the cin to the geometry
    void parse_geometry(istream &amp;arg_is);
};
const unsigned triangle_num_of_vertex = 3;

class Quadrilateral_Comp : public Geometry_Comp
{
public:
    // Constructor, initializes the array
    Quadrilateral_Comp();
    // Copy constructor
    Quadrilateral_Comp(const Quadrilateral_Comp &amp;arg_qc);
    // assignment operator
    Quadrilateral_Comp &amp;operator=(const Quadrilateral_Comp &amp;arg_qc);
    // print the geometry
    void print_geometry();
    // parse the cin to the geometry
    void parse_geometry(istream &amp;arg_is);
};
const unsigned quadrilateral_num_of_vertex = 4;

class Polygon_Comp : public Geometry_Comp
{
public:
    // Constructor, initializes the array
    Polygon_Comp();
    // Copy constructor
    Polygon_Comp(const Polygon_Comp &amp;arg_pc);
    // assignment operator
    Polygon_Comp &amp;operator=(const Polygon_Comp &amp;arg_pc);
    // print the geometry
    void print_geometry();
    // parse the cin to the geometry
    void parse_geometry(istream &amp;arg_is);
};

class Circle_Comp : public Geometry_Comp
{
public:
    // Constructor, initializes the array
    Circle_Comp();
    // Copy constructor
    Circle_Comp(const Circle_Comp &amp;arg_cc);
    // assignment operator
    Circle_Comp &amp;operator=(const Circle_Comp &amp;arg_cc);
    // print the geometry
    void print_geometry();
    // parse the cin to the geometry
    void parse_geometry(istream &amp;arg_is);
};
const unsigned circle_num_of_vertex = 2;

// error and exit
void error_and_exit()
{
    cout &lt;&lt; &quot;Error: Invalid input&quot; &lt;&lt; endl;
    exit(1);
}

int main()
{
    string input, temp;
    vector&lt;Geometry_Comp *&gt; geo_ptr_array;
    Geometry_Comp *geo_ptr;
    Complex trans_c;
    char trans_op;

    while (getline(cin, input))
    {
        // check the geometry type
        switch (input[0])
        {
        case 't':
            geo_ptr = new Triangle_Comp();
            break;
        case 'q':
            geo_ptr = new Quadrilateral_Comp();
            break;
        case 'p':
            geo_ptr = new Polygon_Comp();
            break;
        case 'c':
            geo_ptr = new Circle_Comp();
            break;
        case 'r':
        case 'z':
        case 'm':
            getline(cin, temp);
            break;
        }
        if (input[0] == 't' || input[0] == 'q' || input[0] == 'p' || input[0] == 'c')
        {
            // parse the cin to the geometry
            geo_ptr-&gt;parse_geometry(cin);
            // print the geometry
            geo_ptr-&gt;print_geometry();
            // push the pointer to the array
            geo_ptr_array.push_back(geo_ptr);
        }
        else if (input[0] == 'r' || input[0] == 'z' || input[0] == 'm')
        {
            stringstream ss(temp);
            ss &gt;&gt; trans_c;
            // transform the geometry using operator and complex
            for (int i = 0; i &lt; geo_ptr_array.size(); i++)
            {
                geo_ptr_array[i]-&gt;transform_geometry(trans_c, input[0]);
                // print transformed geometry
                geo_ptr_array[i]-&gt;print_geometry();
            }
        }
    }
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!---
marp: true
author: Yi-Wen Hung
theme: default
headingDivider: 2
paginate: true
--->
<h1 id="file-processing-1"><a class="header" href="#file-processing-1">File Processing (1)</a></h1>
<blockquote>
<p>Slides version: <a href="file/./lecture13_slides.html">lecture13_slides.html</a>
Website version: <a href="file/./lecture13.html">lecture13.html</a></p>
</blockquote>
<ul>
<li>What is File?
<ul>
<li>Temporary variable &amp; Permanent file</li>
<li>Example: Gradebook (Text) &amp; Image (Binary)</li>
</ul>
</li>
</ul>
<ul>
<li>File 101 in C++
<ul>
<li>Open &amp; Close File</li>
<li>Read or Write or Read &amp; Write</li>
<li>Text or Binary</li>
<li>Append or Overwrite</li>
<li>Sequantial or Random Access</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>Example 1: Big Real Number in Text File</li>
<li>Example 2: Point &amp; Triangle in Text File (function ver.)</li>
<li>Example 3: Vector &amp; Matrix in Binary File (function ver.)</li>
<li>Pratices</li>
</ul>
<h2 id="what-is-file"><a class="header" href="#what-is-file">What is File?</a></h2>
<blockquote>
<p>A computer file is a computer resource for recording data in a computer storage device, primarily identified by its file name. Just as words can be written to paper, so can data be written to a computer file.</p>
</blockquote>
<p>Ref: https://en.wikipedia.org/wiki/Computer_file</p>
<p><img src="file/img/nthu.jpg" alt="bg right fit" /></p>
<hr />
<h3 id="example-gradebook-text"><a class="header" href="#example-gradebook-text">Example: Gradebook (Text)</a></h3>
<p>In text format (csv):</p>
<pre><code class="language-csv">Name,Grade
John,A
Mary,B
</code></pre>
<p>In table format:</p>
<table><thead><tr><th align="center">Name</th><th align="center">Grade</th></tr></thead><tbody>
<tr><td align="center">John</td><td align="center">A</td></tr>
<tr><td align="center">Mary</td><td align="center">B</td></tr>
</tbody></table>
<hr />
<h3 id="example-image-binary"><a class="header" href="#example-image-binary">Example: Image (Binary)</a></h3>
<p>In viewable format: as the image on the right</p>
<p><img src="file/img/nthu.jpg" alt="bg right fit" /></p>
<p>In binary format:</p>
<pre><code class="language-binary">00000000: ffd8 ffe1 4812 4578 6966 0000 4d4d 002a  ....H.Exif..MM.*
00000010: 0000 0008 0007 0112 0003 0000 0001 0001  ................
00000020: 0000 011a 0005 0000 0001 0000 0062 011b  .............b..
00000030: 0005 0000 0001 0000 006a 0128 0003 0000  .........j.(....
00000040: 0001 0002 0000 0131 0002 0000 001c 0000  .......1........
00000050: 0072 0132 0002 0000 0014 0000 008e 8769  .r.2...........i
00000060: 0004 0000 0001 0000 00a4 0000 00d0 002d  ...............-
00000070: c6c0 0000 2710 002d c6c0 0000 2710 4164  ....'..-....'.Ad
00000080: 6f62 6520 5068 6f74 6f73 686f 7020 4353  obe Photoshop CS
00000090: 3520 5769 6e64 6f77 7300 3230 3133 3a30  5 Windows.2013:0
000000a0: 343a 3031 2031 353a 3033 3a30 3400 0000  4:01 15:03:04...
000000b0: 0003 a001 0003 0000 0001 0001 0000 a002  ................
</code></pre>
<h2 id="file-101-in-c"><a class="header" href="#file-101-in-c">File 101 in C++</a></h2>
<p>Steps to process a file:</p>
<ol>
<li>Open a file</li>
<li>Seek to a position</li>
<li>Read or write data</li>
<li>Close the file</li>
</ol>
<hr />
<h3 id="open-a-file-write"><a class="header" href="#open-a-file-write">Open a file (Write)</a></h3>
<pre><code class="language-c++">// include iostream &amp; fstream for handle the file object
#include &lt;iostream&gt;
#include &lt;fstream&gt;
// short-cut of std::
using namespace std;

int main()
{
    // write to a file
    // create a output file stream object
    ofstream outfile;
    // open a file
    outfile.open(&quot;test.txt&quot;);
    // check if the file is open
    if (!outfile)
    {
        cout &lt;&lt; &quot;Error opening file&quot; &lt;&lt; endl;
        return 1;
    }
    // ...
}
</code></pre>
<hr />
<h3 id="seek-to-a-position-write"><a class="header" href="#seek-to-a-position-write">Seek to a position (Write)</a></h3>
<pre><code class="language-c++">int main()
{
    // ...
    // open a file
    outfile.open(&quot;test.txt&quot;);
    // ...
    // seek to the end of the file
    outfile.seekp(0, ios::end);
    // ...
}
</code></pre>
<p><code>test.txt</code>:</p>
<pre><code class="language-text">|
</code></pre>
<hr />
<h3 id="read-or-write-data-write"><a class="header" href="#read-or-write-data-write">Read or write data (Write)</a></h3>
<pre><code class="language-c++">int main()
{
    // ...
    // seek to the end of the file
    outfile.seekp(0, ios::end);
    // write to the file
    outfile &lt;&lt; &quot;Hello World!&quot; &lt;&lt; endl;
    // ...
}
</code></pre>
<p><code>test.txt</code>:</p>
<pre><code class="language-text">Hello World!⏎
|
</code></pre>
<hr />
<h3 id="close-the-file-write"><a class="header" href="#close-the-file-write">Close the file (Write)</a></h3>
<pre><code class="language-c++">int main()
{
    // ...
    // write to the file
    outfile &lt;&lt; &quot;Hello World!&quot; &lt;&lt; endl;
    // close the file
    outfile.close();
}
</code></pre>
<p><code>test.txt</code>:</p>
<pre><code class="language-text">Hello World!⏎
|&lt;EOF&gt;
</code></pre>
<hr />
<h3 id="hello-world-write"><a class="header" href="#hello-world-write">Hello World! (Write)</a></h3>
<pre><code class="language-c++">// include iostream &amp; fstream for handle the file object
#include &lt;iostream&gt;
#include &lt;fstream&gt;
// short-cut of std::
using namespace std;

int main()
{
    // write to a file
    // create a output file stream object
    ofstream outfile;
    // open a file
    outfile.open(&quot;test.txt&quot;);
    // check if the file is open
    if (!outfile)
    {
        cout &lt;&lt; &quot;Error opening file&quot; &lt;&lt; endl;
        return 1;
    }
    // seek to the end of the file
    outfile.seekp(0, ios::end);
    // write to the file
    outfile &lt;&lt; &quot;Hello World!&quot; &lt;&lt; endl;
    // close the file
    outfile.close();
}
</code></pre>
<hr />
<h3 id="open-a-file-read"><a class="header" href="#open-a-file-read">Open a file (Read)</a></h3>
<pre><code class="language-c++">// include iostream &amp; fstream for handle the file object
#include &lt;iostream&gt;
#include &lt;fstream&gt;
// short-cut of std::
using namespace std;

int main()
{
    // read from a file
    // create a input file stream object
    ifstream infile;
    // open the file
    infile.open(&quot;test.txt&quot;);
    // or open the file with ifstream constructor
    // ifstream infile(&quot;test.txt&quot;);
    // check if the file is open
    if(!infile)
    {
        cout &lt;&lt; &quot;Error opening file&quot; &lt;&lt; endl;
        return -1;
    }
    // ...
}
</code></pre>
<hr />
<h3 id="seek-to-a-position-read"><a class="header" href="#seek-to-a-position-read">Seek to a position (Read)</a></h3>
<pre><code class="language-c++">int main()
{
    // ...
    // open the file
    infile.open(&quot;test.txt&quot;);
    // ...
    // seek to the front of the file
    infile.seekg(0, ios::beg);
    // ...
}
</code></pre>
<p><code>test.txt</code>:</p>
<pre><code class="language-text">|Hello World!⏎
&lt;EOF&gt;
</code></pre>
<hr />
<h3 id="read-or-write-data-read"><a class="header" href="#read-or-write-data-read">Read or write data (Read)</a></h3>
<pre><code class="language-c++">int main()
{
    // ...
    // seek to the front of the file
    infile.seekg(0, ios::beg);
    // read the file until the end (.eof() is true)
    while(!infile.eof())
    {
        // read a line
        string line;
        getline(infile, line);
        // print the line
        cout &lt;&lt; line &lt;&lt; endl;
    }
    // ...
}
</code></pre>
<hr />
<p><code>test.txt</code>:</p>
<pre><code class="language-text">Hello World!⏎
|&lt;EOF&gt;
</code></pre>
<p>console:</p>
<pre><code class="language-console">$ ./a.out
Hello World!

$
</code></pre>
<hr />
<h3 id="close-the-file-write-1"><a class="header" href="#close-the-file-write-1">Close the file (Write)</a></h3>
<pre><code class="language-c++">int main()
{
    // ...
    // read the file until the end (.eof() is true)
    while(!infile.eof())
    {
        // read a line
        string line;
        getline(infile, line);
        // print the line
        cout &lt;&lt; line &lt;&lt; endl;
    }
    // close the file
    infile.close();
}
</code></pre>
<hr />
<h3 id="hello-world-read"><a class="header" href="#hello-world-read">Hello World! (Read)</a></h3>
<pre><code class="language-c++">// include iostream &amp; fstream for handle the file object
#include &lt;iostream&gt;
#include &lt;fstream&gt;
// short-cut of std::
using namespace std;

int main()
{
    // read from a file
    // create a input file stream object
    ifstream infile;
    // open the file
    infile.open(&quot;test.txt&quot;);
    // or open the file with ifstream constructor
    // ifstream infile(&quot;test.txt&quot;);
    // check if the file is open
    if(!infile)
    {
        cout &lt;&lt; &quot;Error opening file&quot; &lt;&lt; endl;
        return -1;
    }
</code></pre>
<hr />
<pre><code class="language-c++">    // seek to the front of the file
    infile.seekg(0, ios::beg);
    // read the file until the end (.eof() is true)
    while(!infile.eof())
    {
        // read a line
        string line;
        getline(infile, line);
        // print the line
        cout &lt;&lt; line &lt;&lt; endl;
    }
    // close the file
    infile.close();
}
</code></pre>
<h2 id="open--close-file"><a class="header" href="#open--close-file">Open &amp; Close File</a></h2>
<p>Three ways to open a file:</p>
<ul>
<li>Open a file with <code>ofstream</code> (Write only)</li>
<li>Open a file with <code>ifstream</code> (Read only)</li>
<li>Open a file with <code>fstream</code> (Read &amp; Write)</li>
</ul>
<p>Two functions to open a file:</p>
<ul>
<li>Use constructor <code>fstream(filename, mode)</code></li>
<li>Use function <code>open(filename, mode)</code></li>
</ul>
<p>To close a file:</p>
<ul>
<li>Use function <code>close()</code></li>
<li>Use destructor inplicitly
<ul>
<li>The destructor will be called when the function returns</li>
</ul>
</li>
</ul>
<hr />
<h3 id="open--close-a-file-with-ofstream-write-only"><a class="header" href="#open--close-a-file-with-ofstream-write-only">Open &amp; Close a file with <code>ofstream</code> (Write only)</a></h3>
<pre><code class="language-c++">// include iostream &amp; fstream for handle the file object
#include &lt;iostream&gt;
#include &lt;fstream&gt;
// short-cut of std::
using namespace std;

int main()
{
    // create a output file stream object
    ofstream outfile;
    // open a file with `.open(filename)`
    outfile.open(&quot;test.txt&quot;);
    // close the file
    outfile.close();

    // open a file with constructor `ofstream(filename)`
    ofstream outfile2(&quot;test.txt&quot;);
    // close the file
    outfile2.close();
}
</code></pre>
<hr />
<h3 id="open--close-a-file-with-ifstream-read-only"><a class="header" href="#open--close-a-file-with-ifstream-read-only">Open &amp; Close a file with <code>ifstream</code> (Read only)</a></h3>
<pre><code class="language-c++">// include iostream &amp; fstream for handle the file object
#include &lt;iostream&gt;
#include &lt;fstream&gt;
// short-cut of std::
using namespace std;

int main()
{
    // create a input file stream object
    ifstream infile;
    // open a file with `.open(filename)`
    infile.open(&quot;test.txt&quot;);
    // close the file
    infile.close();

    // open a file with constructor `ifstream(filename)`
    ifstream infile2(&quot;test.txt&quot;);
    // close the file
    infile2.close();
}
</code></pre>
<hr />
<h3 id="open--close-a-file-with-fstream-read--write"><a class="header" href="#open--close-a-file-with-fstream-read--write">Open &amp; Close a file with <code>fstream</code> (Read &amp; Write)</a></h3>
<pre><code class="language-c++">// include iostream &amp; fstream for handle the file object
#include &lt;iostream&gt;
#include &lt;fstream&gt;
// short-cut of std::
using namespace std;

int main()
{
    // create a input file stream object
    fstream file;
    // open a file with `.open(filename)`
    file.open(&quot;test.txt&quot;);
    // close the file
    file.close();

    // open a file with constructor `fstream(filename)`
    fstream file2(&quot;test.txt&quot;);
    // close the file
    file2.close();
}
</code></pre>
<hr />
<h3 id="check-if-the-file-is-open"><a class="header" href="#check-if-the-file-is-open">Check if the file is open</a></h3>
<pre><code class="language-c++">// include iostream &amp; fstream for handle the file object
#include &lt;iostream&gt;
#include &lt;fstream&gt;
// short-cut of std::
using namespace std;

int main()
{
    // create a input file stream object
    fstream file;
    // open a file with `.open(filename)`
    file.open(&quot;test.txt&quot;);
    // check if the file is open
    if(!file)
    {
        cout &lt;&lt; &quot;Error opening file&quot; &lt;&lt; endl;
        return -1;
    }
    // or use `.is_open()`
    if(!file.is_open())
    {
        cout &lt;&lt; &quot;Error opening file&quot; &lt;&lt; endl;
        return -1;
    }
    // do something

    // close the file
    file.close();
}
</code></pre>
<h2 id="read-or-write-or-read--write"><a class="header" href="#read-or-write-or-read--write">Read or Write or Read &amp; Write</a></h2>
<ul>
<li>To read a file only: use <code>ifstream</code> or <code>fstream(filename, ios::in)</code></li>
<li>To write a file only: use <code>ofstream</code> or <code>fstream(filename, ios::out)</code></li>
<li>To read &amp; write a file: use <code>fstream(filename, ios::in | ios::out)</code></li>
</ul>
<p>Note:</p>
<ul>
<li><code>ifstream</code> is used like <code>fstream(filename, ios::in)</code> but not the same</li>
<li><code>ofstream</code> is used like <code>fstream(filename, ios::out)</code> but not the same</li>
</ul>
<hr />
<h3 id="read-a-file-only"><a class="header" href="#read-a-file-only">Read a file only</a></h3>
<pre><code class="language-c++">// include iostream &amp; fstream for handle the file object
#include &lt;iostream&gt;
#include &lt;fstream&gt;
// short-cut of std::
using namespace std;

int main()
{
    // create a input file stream object with `ifstream(filename)`
    ifstream infile(&quot;test.txt&quot;);
    // print the file
    while(!infile.eof())
    {
        // read a line
        string line;
        getline(infile, line);
        // print the line
        cout &lt;&lt; line &lt;&lt; endl;
    }
    infile.close();

    // or use `fstream(filename, ios::in)`
    fstream file;
    // open a file with `.open(filename)`
    file.open(&quot;test.txt&quot;, ios::in);
    // print the file
    while(!file.eof())
    {
        string line;
        getline(file, line);
        cout &lt;&lt; line &lt;&lt; endl;
    }
    // close the file
    file.close();
}
</code></pre>
<hr />
<h3 id="write-a-file-only"><a class="header" href="#write-a-file-only">Write a file only</a></h3>
<pre><code class="language-c++">// include iostream &amp; fstream for handle the file object
#include &lt;iostream&gt;
#include &lt;fstream&gt;
// short-cut of std::
using namespace std;

int main()
{
    // create a output file stream object with `ofstream(filename)`
    ofstream outfile(&quot;test.txt&quot;);
    // write a line
    outfile &lt;&lt; &quot;Hello World!&quot; &lt;&lt; endl;
    // close the file
    outfile.close();

    // or use `fstream(filename, ios::out)`
    fstream file;
    // open a file with `.open(filename)`
    file.open(&quot;test2.txt&quot;, ios::out);
    // write a line
    file &lt;&lt; &quot;Hello World!&quot; &lt;&lt; endl;
    // close the file
    file.close();
}
</code></pre>
<hr />
<h3 id="read--write-a-file"><a class="header" href="#read--write-a-file">Read &amp; Write a file</a></h3>
<pre><code class="language-c++">// include iostream &amp; fstream for handle the file object
#include &lt;iostream&gt;
#include &lt;fstream&gt;
// short-cut of std::
using namespace std;

int main()
{
    // create a input file stream object with `fstream(filename, ios::in | ios::out)`
    // Note: create &quot;test.txt&quot; first
    fstream file(&quot;test.txt&quot;, ios::in | ios::out);
    // write lines
    for( int i = 0; i &lt; 10; i++ )
    {
        file &lt;&lt; &quot;Line &quot; &lt;&lt; i &lt;&lt; endl;
    }
    // seek to the beginning of the file
    file.seekg(0, ios::beg);
    // print the file
    for( int i = 0; i &lt; 10; i++ )
    {
        // read a line
        string line;
        getline(file, line);
        // print the line
        cout &lt;&lt; line &lt;&lt; endl;
    }
    // close the file
    file.close();
}
</code></pre>
<hr />
<h3 id="if-file-not-exist"><a class="header" href="#if-file-not-exist">If file not exist</a></h3>
<p><code>fstream</code>, <code>ifstream</code> and <code>ofstream</code> will handle the file if it not exist.</p>
<ul>
<li>Create new file: <code>ofstream</code>, <code>fstream(filename, ios::out)</code>, <code>fstream(filename, ios::in | ios::out | ios::trunc)</code>, <code>fstream(filename, ios::out | ios::app)</code>
<ul>
<li><code>ios::trunc</code> &amp; <code>ios::app</code> will be disscussed later</li>
</ul>
</li>
<li>Error opening file: <code>ifstream</code>, <code>fstream(filename, ios::in)</code>, <code>fstream(filename, ios::in | ios::out)</code></li>
</ul>
<hr />
<p>Example:</p>
<pre><code class="language-c++">// include iostream &amp; fstream for handle the file object
#include &lt;iostream&gt;
#include &lt;fstream&gt;
// short-cut of std::
using namespace std;

int main()
{
    // open a non-existing file
    ifstream infile(&quot;test.txt&quot;);
    // check if the file is open
    if(!infile)
    {
        cout &lt;&lt; &quot;Error opening file&quot; &lt;&lt; endl;
    }
    // create a new file and open it
    ofstream outfile(&quot;test.txt&quot;);
    // write some text to the file
    outfile &lt;&lt; &quot;Hello World!&quot; &lt;&lt; endl;
    outfile.close();
</code></pre>
<hr />
<pre><code class="language-c++">    // read the file again
    fstream file(&quot;test.txt&quot;);
    // check if the file is open
    if(!file)
    {
        cout &lt;&lt; &quot;Error opening file&quot; &lt;&lt; endl;
    }
    // read the file
    while (!file.eof())
    {
        string line;
        getline(file, line);
        cout &lt;&lt; line &lt;&lt; endl;
    }
    // close the file
    file.close();
}
</code></pre>
<h2 id="text-or-binary"><a class="header" href="#text-or-binary">Text or Binary</a></h2>
<ul>
<li>Text file: save the data in character format</li>
</ul>
<pre><code class="language-text">Name,Grade
John,A
Mary,B
</code></pre>
<ul>
<li>Binary file: save the data with the same format as the computer</li>
</ul>
<pre><code class="language-binary">00000000: ffd8 ffe1 4812 4578 6966 0000 4d4d 002a  ....H.Exif..MM.*
</code></pre>
<p>The file saved JPEG header <code>ffd8</code>, <code>ffe1</code>, and has 18,450 (<code>0x4812</code>) bytes of metadata.
The metadata store EXIF information <code>Exif..MM.*</code> (<code>4578 6966 0000 4d4d 002a</code>).</p>
<hr />
<h3 id="read--write-a-text-file"><a class="header" href="#read--write-a-text-file">Read &amp; Write a text file</a></h3>
<pre><code class="language-c++">// include iostream &amp; fstream for handle the file object
#include &lt;iostream&gt;
#include &lt;fstream&gt;
// short-cut of std::
using namespace std;

int main()
{
    // create a input file stream object with `fstream(filename, ios::in | ios::out)`
    // Note: create &quot;test.txt&quot; first
    fstream file(&quot;test.txt&quot;, ios::in | ios::out);
    // write lines
    for( int i = 0; i &lt; 10; i++ )
    {
        file &lt;&lt; &quot;Line &quot; &lt;&lt; i &lt;&lt; endl;
    }
    // seek to the beginning of the file
    file.seekg(0, ios::beg);
    // print the file
    for( int i = 0; i &lt; 10; i++ )
    {
        // read a line
        string line;
        getline(file, line);
        // print the line
        cout &lt;&lt; line &lt;&lt; endl;
    }
    // close the file
    file.close();
}
</code></pre>
<hr />
<p>Result: <code>test.txt</code></p>
<pre><code class="language-text">Line 0⏎
Line 1⏎
Line 2⏎
Line 3⏎
Line 4⏎
Line 5⏎
Line 6⏎
Line 7⏎
Line 8⏎
Line 9⏎
&lt;EOF&gt;
</code></pre>
<hr />
<h3 id="read--write-a-binary-file"><a class="header" href="#read--write-a-binary-file">Read &amp; Write a binary file</a></h3>
<pre><code class="language-c++">// include iostream &amp; fstream for handle the file object
#include &lt;iostream&gt;
#include &lt;fstream&gt;
// short-cut of std::
using namespace std;

int main()
{
    // create a input file stream object with `fstream(filename, ios::in | ios::out)`
    // Note: create &quot;test.bin&quot; first
    fstream file(&quot;test.bin&quot;, ios::in | ios::out | ios::binary);
    // write lines
    for (int i = 0; i &lt; 10; i++)
    {
        string temp(&quot;Line&quot;);
        // write string to file, we need to use `.c_str()` to convert string to char*
        file.write(temp.c_str(), temp.size());
        // for other data type like int, float, double, etc.
        // we need to convert the data type to char* first
        // use `&amp;` to get the address of the data,
        // use `(char *)` to convert the address to char*,
        // and use `sizeof(type)` to get the size (number of bytes) of the data type
        // then use `.write(data, size)` to write the data to file
        file.write((char *)&amp;i, sizeof(int)); // write int value to file
    }
    file.flush(); // flush the buffer
</code></pre>
<hr />
<pre><code class="language-c++">    // seek to the beginning of the file
    file.seekg(0, ios::beg);
    // print the file
    for (int i = 0; i &lt; 10; i++)
    {
        // read string from file
        char temp[5];
        // because we store &quot;Line&quot; in the file, so we only need to read 4 bytes
        file.read(temp, 4);
        // add '\0' to the end of the string
        temp[4] = '\0';
        // read int from file
        int temp_int;
        // same as write, we need to convert the data type to char* first
        // then use `.read(data, size)` to read the data from file
        file.read((char *)&amp;temp_int, sizeof(int));
        cout &lt;&lt; temp &lt;&lt; &quot; &quot; &lt;&lt; temp_int &lt;&lt; endl;
    }
    // close the file
    file.close();
}
</code></pre>
<hr />
<p>Result: <code>test.bin</code></p>
<pre><code class="language-binary">00000000: 4c69 6e65 0000 0000 4c69 6e65 0100 0000  Line....Line....
00000010: 4c69 6e65 0200 0000 4c69 6e65 0300 0000  Line....Line....
00000020: 4c69 6e65 0400 0000 4c69 6e65 0500 0000  Line....Line....
00000030: 4c69 6e65 0600 0000 4c69 6e65 0700 0000  Line....Line....
00000040: 4c69 6e65 0800 0000 4c69 6e65 0900 0000  Line....Line....
</code></pre>
<h2 id="append-or-overwrite"><a class="header" href="#append-or-overwrite">Append or Overwrite</a></h2>
<p>Two ways to handle a existing file:</p>
<ul>
<li>Append (<code>ios::app</code>): append the data to the end of the file</li>
<li>Overwrite (<code>ios::trunc</code>): overwrite the file</li>
</ul>
<hr />
<h3 id="append-iosapp"><a class="header" href="#append-iosapp">Append (<code>ios::app</code>)</a></h3>
<pre><code class="language-c++">// include iostream &amp; fstream for handle the file object
#include &lt;iostream&gt;
#include &lt;fstream&gt;
// short-cut of std::
using namespace std;

int main()
{
    // create a input file stream object with `fstream(filename, ios::in | ios::out)`
    // Note: create &quot;test.txt&quot; first
    fstream file(&quot;test.txt&quot;, ios::in | ios::out);
    // write lines
    for (int i = 0; i &lt; 10; i++)
    {
        file &lt;&lt; &quot;Line &quot; &lt;&lt; i &lt;&lt; endl;
    }
    // seek to the beginning of the file
    file.seekg(0, ios::beg);
    // print the file
    for (int i = 0; i &lt; 10; i++)
    {
        // read a line
        string line;
        getline(file, line);
        // print the line
        cout &lt;&lt; line &lt;&lt; endl;
    }
    // close the file
    file.close();
</code></pre>
<hr />
<pre><code class="language-c++">    // open again with `ios::app`
    fstream file2(&quot;test.txt&quot;, ios::in | ios::out | ios::app);
    // write a line
    for (int i = 10; i &lt; 20; i++)
    {
        file2 &lt;&lt; &quot;Line &quot; &lt;&lt; i &lt;&lt; endl;
    }
    // seek to the beginning of the file
    file2.seekg(0, ios::beg);
    // print the file
    for (int i = 0; i &lt; 20; i++)
    {
        // read a line
        string line;
        getline(file2, line);
        // print the line
        cout &lt;&lt; line &lt;&lt; endl;
    }
    // close the file
    file2.close();
}
</code></pre>
<hr />
<p>Result: <code>test.txt</code></p>
<pre><code class="language-text">Line 0⏎
Line 1⏎
Line 2⏎
Line 3⏎
Line 4⏎
Line 5⏎
Line 6⏎
Line 7⏎
Line 8⏎
Line 9⏎
Line 10⏎
Line 11⏎
Line 12⏎
Line 13⏎
Line 14⏎
Line 15⏎
Line 16⏎
Line 17⏎
Line 18⏎
Line 19⏎
&lt;EOF&gt;
</code></pre>
<hr />
<h3 id="overwrite-iostrunc"><a class="header" href="#overwrite-iostrunc">Overwrite (<code>ios::trunc</code>)</a></h3>
<pre><code class="language-c++">// include iostream &amp; fstream for handle the file object
#include &lt;iostream&gt;
#include &lt;fstream&gt;
// short-cut of std::
using namespace std;

int main()
{
    // create a input file stream object with `fstream(filename, ios::in | ios::out)`
    // Note: create &quot;test.txt&quot; first
    fstream file(&quot;test.txt&quot;, ios::in | ios::out);
    // write lines
    for (int i = 0; i &lt; 10; i++)
    {
        file &lt;&lt; &quot;Line &quot; &lt;&lt; i &lt;&lt; endl;
    }
    // seek to the beginning of the file
    file.seekg(0, ios::beg);
    // print the file
    for (int i = 0; i &lt; 10; i++)
    {
        // read a line
        string line;
        getline(file, line);
        // print the line
        cout &lt;&lt; line &lt;&lt; endl;
    }
    // close the file
    file.close();
</code></pre>
<hr />
<pre><code class="language-c++">    // open again with `ios::app`
    fstream file2(&quot;test.txt&quot;, ios::in | ios::out | ios::trunc);
    // write a line
    for (int i = 10; i &lt; 20; i++)
    {
        file2 &lt;&lt; &quot;Line &quot; &lt;&lt; i &lt;&lt; endl;
    }
    // seek to the beginning of the file
    file2.seekg(0, ios::beg);
    // print the file
    for (int i = 0; i &lt; 20; i++)
    {
        // read a line
        string line;
        getline(file2, line);
        // print the line
        cout &lt;&lt; line &lt;&lt; endl;
    }
    // close the file
    file2.close();
}
</code></pre>
<hr />
<p>Result: <code>test.txt</code></p>
<pre><code class="language-text">Line 10⏎
Line 11⏎
Line 12⏎
Line 13⏎
Line 14⏎
Line 15⏎
Line 16⏎
Line 17⏎
Line 18⏎
Line 19⏎
&lt;EOF&gt;
</code></pre>
<h2 id="sequantial-or-random-access"><a class="header" href="#sequantial-or-random-access">Sequantial or Random Access</a></h2>
<p>By default, the file is sequantial access.</p>
<p><code>.tellp()</code> and <code>.tellg()</code> can tell the current position of the file.</p>
<pre><code class="language-c++">// include iostream &amp; fstream for handle the file object
#include &lt;iostream&gt;
#include &lt;fstream&gt;
// short-cut of std::
using namespace std;

int main()
{
    // create a input file stream object with `fstream(filename, ios::in | ios::out)`
    // Note: create &quot;test.txt&quot; first
    fstream file(&quot;test.txt&quot;, ios::in | ios::out);
    // write lines
    cout &lt;&lt; file.tellp() &lt;&lt; endl; // print the current position for `&lt;&lt;`
    for (int i = 0; i &lt; 10; i++)
    {
        file &lt;&lt; &quot;Line &quot; &lt;&lt; i &lt;&lt; endl;
        cout &lt;&lt; file.tellp() &lt;&lt; endl;
    }
</code></pre>
<hr />
<pre><code class="language-c++">    // seek to the beginning of the file
    file.seekg(0, ios::beg);
    // print the file
    cout &lt;&lt; file.tellg() &lt;&lt; endl; // print the current position for `&gt;&gt;` and getline()
    for (int i = 0; i &lt; 10; i++)
    {
        // read a line
        string line;
        getline(file, line);
        // print the line
        cout &lt;&lt; file.tellg() &lt;&lt; &quot; &quot; &lt;&lt; line &lt;&lt; endl;
    }
    // close the file
    file.close();
}
</code></pre>
<hr />
<p>Result: terminal</p>
<pre><code class="language-console">0
7
14
21
28
35
42
49
56
63
70
0
7 Line 0
14 Line 1
21 Line 2
28 Line 3
35 Line 4
42 Line 5
49 Line 6
56 Line 7
63 Line 8
70 Line 9
</code></pre>
<hr />
<h3 id="random-access"><a class="header" href="#random-access">Random Access</a></h3>
<p><code>.seekp(pos)</code> and <code>.seekg(pos)</code> can seek to the position of the file.</p>
<p>Three reference position:</p>
<ul>
<li><code>ios::beg</code>: the beginning of the file</li>
<li><code>ios::cur</code>: the current position of the file</li>
<li><code>ios::end</code>: the end of the file</li>
</ul>
<hr />
<pre><code class="language-c++">// include iostream &amp; fstream for handle the file object
#include &lt;iostream&gt;
#include &lt;fstream&gt;
// short-cut of std::
using namespace std;

int main()
{
    // create a input file stream object with `fstream(filename, ios::in | ios::out)`
    // Note: create &quot;test.txt&quot; first
    fstream file(&quot;test.txt&quot;, ios::in | ios::out);
    // write lines
    cout &lt;&lt; file.tellp() &lt;&lt; endl; // print the current position for `&lt;&lt;`
    for (int i = 0; i &lt; 10; i++)
    {
        file &lt;&lt; &quot;Line &quot; &lt;&lt; i &lt;&lt; endl;
        cout &lt;&lt; file.tellp() &lt;&lt; endl;
    }
    // seek to the 5th line from the beginning
    file.seekp(5 * 7, ios::beg);
    cout &lt;&lt; file.tellp() &lt;&lt; endl; // print the current position for `&lt;&lt;`
    for (int i = 15; i &lt; 20; i++)
    {
        file &lt;&lt; &quot;Line &quot; &lt;&lt; i &lt;&lt; endl;
        cout &lt;&lt; file.tellp() &lt;&lt; endl;
    }
</code></pre>
<hr />
<pre><code class="language-c++">    // seek to the beginning of the file
    file.seekg(0, ios::beg);
    // or use `file.seekg(0);`
    // print the file
    cout &lt;&lt; file.tellg() &lt;&lt; endl; // print the current position for `&gt;&gt;` and getline()
    for (int i = 0; i &lt; 10; i++)
    {
        // seek to the 3th-previous line if read th 5th line
        if (i == 5)
        {
            file.seekg(-3 * 7, ios::cur);
        }
        // read a line
        string line;
        getline(file, line);
        // print the line
        cout &lt;&lt; file.tellg() &lt;&lt; &quot; &quot; &lt;&lt; line &lt;&lt; endl;
    }
    // close the file
    file.close();
}
</code></pre>
<hr />
<p>Result: terminal</p>
<pre><code class="language-console">0
7
14
21
28
35
42
49
56
63
70
35
43
51
59
67
75
0
7 Line 0
14 Line 1
21 Line 2
28 Line 3
35 Line 4
21 Line 2
28 Line 3
35 Line 4
43 Line 15
51 Line 16
</code></pre>
<h2 id="summary-of-file-io-101"><a class="header" href="#summary-of-file-io-101">Summary of File I/O 101</a></h2>
<ul>
<li>Open &amp; Close File
<ul>
<li>constructor or <code>.open()</code></li>
</ul>
</li>
<li>Read or Write or Read &amp; Write
<ul>
<li><code>ifstream</code> and <code>ofstream</code></li>
<li><code>ios::in</code> and <code>ios::out</code> in <code>mode</code> argument of <code>fstream</code></li>
</ul>
</li>
<li>Text or Binary
<ul>
<li><code>ios::binary</code> in <code>mode</code> argument</li>
</ul>
</li>
<li>Append or Overwrite
<ul>
<li><code>ios::app</code> and <code>ios::trunc</code> in <code>mode</code> argument</li>
</ul>
</li>
<li>Sequantial or Random Access
<ul>
<li><code>.seekp()</code> and <code>.tellp()</code> for set/get position of <code>&lt;&lt;</code></li>
<li><code>.seekg()</code> and <code>.tellg()</code> for set/get position of <code>&gt;&gt;</code> or <code>getline()</code></li>
</ul>
</li>
</ul>
<hr />
<h3 id="mode-and-file-handeling"><a class="header" href="#mode-and-file-handeling"><code>mode</code> and file handeling</a></h3>
<p>Ref: <a href="https://en.cppreference.com/w/cpp/io/basic_filebuf/open">std::basic_filebuf&lt;CharT,Traits&gt;::open - cppreference.com</a></p>
<table><thead><tr><th align="center"><code>mode</code></th><th align="center">Action if file exists</th><th align="center">Action if file does not exist</th></tr></thead><tbody>
<tr><td align="center"><code>in</code></td><td align="center">Read from start</td><td align="center">Error</td></tr>
<tr><td align="center"><code>out</code>, <code>out\|trunc</code></td><td align="center">Destory contents</td><td align="center">Create new</td></tr>
<tr><td align="center"><code>app</code>, <code>out\|app</code></td><td align="center">Write to end</td><td align="center">Create new</td></tr>
<tr><td align="center"><code>out\|in</code></td><td align="center">Read from start</td><td align="center">Error</td></tr>
<tr><td align="center"><code>out\|in\|trunc</code></td><td align="center">Destory contents</td><td align="center">Create new</td></tr>
<tr><td align="center"><code>out\|in\|app</code>, <code>in\|app</code></td><td align="center">Write to end</td><td align="center">Create new</td></tr>
<tr><td align="center"><code>binray\|in</code></td><td align="center">Read from start</td><td align="center">Error</td></tr>
<tr><td align="center"><code>binray\|out</code>, <code>binray\|out\|trunc</code></td><td align="center">Destory contents</td><td align="center">Create new</td></tr>
<tr><td align="center"><code>binray\|app</code>, <code>binray\|out\|app</code></td><td align="center">Write to end</td><td align="center">Create new</td></tr>
<tr><td align="center"><code>binray\|out\|in</code></td><td align="center">Read from start</td><td align="center">Error</td></tr>
<tr><td align="center"><code>binray\|out\|in\|trunc</code></td><td align="center">Destory contents</td><td align="center">Create new</td></tr>
<tr><td align="center"><code>binray\|out\|in\|app</code>, <code>binray\|in\|app</code></td><td align="center">Write to end</td><td align="center">Create new</td></tr>
</tbody></table>
<h2 id="example-1-big-real-number-in-text-file-a-hreffilelecture13_ex1htmlsourcea"><a class="header" href="#example-1-big-real-number-in-text-file-a-hreffilelecture13_ex1htmlsourcea">Example 1: Big Real Number in Text File [<a href="file/./lecture13_ex1.html">Source</a>]</a></h2>
<p>Ref: <a href="https://stevenokm.github.io/i2p-nthu-math/i2p1/array_vector/lab_7_1.html">Lab 7: 真・大數四則運算 - Introduction to Programming (I)</a></p>
<h2 id="example-2-point--triangle-in-text-file-function-ver-a-hreffilelecture13_ex2htmlsourcea"><a class="header" href="#example-2-point--triangle-in-text-file-function-ver-a-hreffilelecture13_ex2htmlsourcea">Example 2: Point &amp; Triangle in Text File (function ver.) [<a href="file/./lecture13_ex2.html">Source</a>]</a></h2>
<h2 id="example-3-vector--matrix-in-binary-file-function-ver-a-hreffilelecture13_ex3htmlsourcea"><a class="header" href="#example-3-vector--matrix-in-binary-file-function-ver-a-hreffilelecture13_ex3htmlsourcea">Example 3: Vector &amp; Matrix in Binary File (function ver.) [<a href="file/./lecture13_ex3.html">Source</a>]</a></h2>
<h2 id="pratices-6"><a class="header" href="#pratices-6">Pratices</a></h2>
<ul>
<li>Read &amp; Write Point &amp; Triangle in Binary File</li>
<li>Read &amp; Write Vector &amp; Matrix in CSV format
<ul>
<li>Seprator column by <code>,</code></li>
<li>Seprator row by <code>\n</code></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-1-big-real-number-in-text-file"><a class="header" href="#example-1-big-real-number-in-text-file">Example 1: Big Real Number in Text File</a></h1>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main()
{
    char buffer[10001];
    vector&lt;int&gt; a, b, c;
    int n, a_sign = 1, b_sign = 1, c_sign = 1;
    bool zero_start = true;

    ofstream log_file(&quot;log.txt&quot;, ios::out | ios::app);

    cout &lt;&lt; &quot;Big number calculator&quot;
         &lt;&lt; endl
         &lt;&lt; &quot;1) display only&quot;
         &lt;&lt; endl
         &lt;&lt; &quot;2) plus (+)&quot;
         &lt;&lt; endl
         &lt;&lt; &quot;3) minus (-)&quot;
         &lt;&lt; endl
         &lt;&lt; &quot;4) multiplication (*)&quot;
         &lt;&lt; endl
         &lt;&lt; &quot;5) division (/)&quot;
         &lt;&lt; endl
         &lt;&lt; &quot;Please select the operator: &quot;;

    cin &gt;&gt; buffer;
    if (!isdigit(buffer[0]) || buffer[1] != '\0')
    {
        cout &lt;&lt; &quot;Invalid input: &quot; &lt;&lt; buffer &lt;&lt; endl;
        return 0;
    }

    n = buffer[0] - '0';
    switch (n)
    {
    case 1:
        cout &lt;&lt; &quot;You selected: display only&quot; &lt;&lt; endl;
        break;
    case 2:
        cout &lt;&lt; &quot;You selected: +&quot; &lt;&lt; endl;
        break;
    case 3:
        cout &lt;&lt; &quot;You selected: -&quot; &lt;&lt; endl;
        break;
    case 4:
        cout &lt;&lt; &quot;You selected: *&quot; &lt;&lt; endl;
        break;
    case 5:
        cout &lt;&lt; &quot;You selected: /&quot; &lt;&lt; endl;
        break;
    default:
        cout &lt;&lt; &quot;Invalid input: &quot; &lt;&lt; buffer &lt;&lt; endl;
        return 0;
    }

    for (int i = 0; buffer[i] != '\0'; i++)
        buffer[i] = '\0';
    cout &lt;&lt; &quot;Input integer number (a): &quot;;
    cin &gt;&gt; buffer;
    zero_start = true;

    for (int i = 0; buffer[i] != '\0'; i++)
    {
        if (!isdigit(buffer[i]))
        {
            if (i == 0 &amp;&amp; buffer[i] == '-')
            {
                a_sign = -1;
                continue;
            }
            else
            {
                cout &lt;&lt; &quot;Invalid input: &quot; &lt;&lt; buffer &lt;&lt; endl;
                return 0;
            }
        }

        if (buffer[i] == '0' &amp;&amp; zero_start)
            continue;
        else
        {
            a.push_back((int)(buffer[i] - '0'));
            zero_start = false;
        }
    }
    if (a.empty())
    {
        a.push_back(0);
        a_sign = 0;
    }
    reverse(a.begin(), a.end());

    for (int i = 0; buffer[i] != '\0'; i++)
        buffer[i] = '\0';
    cout &lt;&lt; &quot;Input integer number (b): &quot;;
    cin &gt;&gt; buffer;
    zero_start = true;
    for (int i = 0; buffer[i] != '\0'; i++)
    {
        if (!isdigit(buffer[i]))
        {
            if (i == 0 &amp;&amp; buffer[i] == '-')
            {
                b_sign = -1;
                continue;
            }
            else
            {
                cout &lt;&lt; &quot;Invalid input: &quot; &lt;&lt; buffer &lt;&lt; endl;
                return 0;
            }
        }

        if (buffer[i] == '0' &amp;&amp; zero_start)
            continue;
        else
        {
            b.push_back((int)(buffer[i] - '0'));
            zero_start = false;
        }
    }
    if (b.empty())
    {
        if (n == 5)
        {
            cout &lt;&lt; &quot;Invalid input: &quot; &lt;&lt; buffer &lt;&lt; endl;
            return 0;
        }
        b.push_back(0);
        b_sign = 0;
    }
    reverse(b.begin(), b.end());

    cout &lt;&lt; &quot;(a) = &quot; &lt;&lt; (a_sign == -1 ? &quot;-&quot; : &quot;&quot;);
    for (int i = a.size() - 1; i &gt;= 0; i--)
        cout &lt;&lt; a[i];
    cout &lt;&lt; '\n'
         &lt;&lt; &quot;(b) = &quot; &lt;&lt; (b_sign == -1 ? &quot;-&quot; : &quot;&quot;);
    for (int i = b.size() - 1; i &gt;= 0; i--)
        cout &lt;&lt; b[i];
    cout &lt;&lt; endl;
    // write to log file
    log_file &lt;&lt; &quot;(a) = &quot; &lt;&lt; (a_sign == -1 ? &quot;-&quot; : &quot;&quot;);
    for (int i = a.size() - 1; i &gt;= 0; i--)
        log_file &lt;&lt; a[i];
    log_file &lt;&lt; '\n'
             &lt;&lt; &quot;(b) = &quot; &lt;&lt; (b_sign == -1 ? &quot;-&quot; : &quot;&quot;);
    for (int i = b.size() - 1; i &gt;= 0; i--)
        log_file &lt;&lt; b[i];
    log_file &lt;&lt; endl;
    // Initialization Done

    int carry = 0;
    if (n == 1)
    {
        log_file.close();
        return 0; // &quot;Display only&quot;
    }
    // &quot;Display only&quot; Done

    else if (n == 2) // &quot;+&quot;
    {
        for (int i = 0; i &lt; a.size() &amp;&amp; i &lt; b.size(); i++)
        {
            c.push_back((a[i] * a_sign + b[i] * b_sign + carry) % 10);
            carry = (a[i] * a_sign + b[i] * b_sign + carry) / 10;
        }
        if (a.size() &gt; b.size())
        {
            for (int i = b.size(); i &lt; a.size(); i++)
            {
                c.push_back((a[i] * a_sign + carry) % 10);
                carry = (a[i] * a_sign + carry) / 10;
            }
        }
        else
        {
            for (int i = a.size(); i &lt; b.size(); i++)
            {
                c.push_back((b[i] * b_sign + carry) % 10);
                carry = (b[i] * b_sign + carry) / 10;
            }
        }
        c.push_back(carry);

        zero_start = true;
        for (int i = c.size() - 1; i &gt;= 0; i--)
        {
            if (c[i] == 0 &amp;&amp; zero_start)
                c.pop_back();
            else
                break;
        }
        if (c.empty())
            c.push_back(0);

        c_sign = (c[c.size() - 1] &lt; 0 ? -1 : 1);

        for (int i = 0; i &lt; c.size(); i++)
        {
            if (c_sign * c[i] &lt; 0)
            {
                c[i] += (10 * c_sign);
                if (i + 1 &lt; c.size())
                    c[i + 1] += (-1 * c_sign);
                else
                    c.push_back(-1 * c_sign);
            }
            c[i] *= c_sign;
        }

        cout &lt;&lt; &quot;(a) + (b) = &quot; &lt;&lt; (c_sign &lt; 0 ? &quot;-&quot; : &quot;&quot;);
        for (int i = c.size() - 1; i &gt;= 0; i--)
            cout &lt;&lt; c[i];
        cout &lt;&lt; endl;
        // write to log file
        log_file &lt;&lt; &quot;(a) + (b) = &quot; &lt;&lt; (c_sign &lt; 0 ? &quot;-&quot; : &quot;&quot;);
        for (int i = c.size() - 1; i &gt;= 0; i--)
            log_file &lt;&lt; c[i];
        log_file &lt;&lt; endl;
        log_file.close();
        return 0;
    }
    // &quot;+&quot; Done

    else if (n == 3) // &quot;-&quot;
    {
        for (int i = 0; i &lt; a.size() &amp;&amp; i &lt; b.size(); i++)
        {
            c.push_back((a[i] * a_sign - b[i] * b_sign + carry) % 10);
            carry = (a[i] * a_sign - b[i] * b_sign + carry) / 10;
        }
        if (a.size() &gt; b.size())
        {
            for (int i = b.size(); i &lt; a.size(); i++)
            {
                c.push_back((a[i] * a_sign + carry) % 10);
                carry = (a[i] * a_sign + carry) / 10;
            }
        }
        else
        {
            for (int i = a.size(); i &lt; b.size(); i++)
            {
                c.push_back((-b[i] * b_sign + carry) % 10);
                carry = (-b[i] * b_sign + carry) / 10;
            }
        }
        c.push_back(carry);

        zero_start = true;
        for (int i = c.size() - 1; i &gt;= 0; i--)
        {
            if (c[i] == 0 &amp;&amp; zero_start)
                c.pop_back();
            else
                break;
        }
        if (c.empty())
            c.push_back(0);

        c_sign = (c[c.size() - 1] &lt; 0 ? -1 : 1);

        for (int i = 0; i &lt; c.size(); i++)
        {
            if (c_sign * c[i] &lt; 0)
            {
                c[i] += (10 * c_sign);
                if (i + 1 &lt; c.size())
                    c[i + 1] += (-1 * c_sign);
                else
                    c.push_back(-1 * c_sign);
            }
            c[i] *= c_sign;
        }

        cout &lt;&lt; &quot;(a) - (b) = &quot; &lt;&lt; (c_sign &lt; 0 ? &quot;-&quot; : &quot;&quot;);
        for (int i = c.size() - 1; i &gt;= 0; i--)
            cout &lt;&lt; c[i];
        cout &lt;&lt; endl;
        // write to log file
        log_file &lt;&lt; &quot;(a) - (b) = &quot; &lt;&lt; (c_sign &lt; 0 ? &quot;-&quot; : &quot;&quot;);
        for (int i = c.size() - 1; i &gt;= 0; i--)
            log_file &lt;&lt; c[i];
        log_file &lt;&lt; endl;
        log_file.close();
        return 0;
    }
    // &quot;-&quot; Done

    else if (n == 4) // &quot;*&quot;
    {
        c_sign = a_sign * b_sign;
        for (int i = 0; i &lt; b.size(); i++)
        {
            for (int j = 0; j &lt; a.size(); j++)
            {
                if (i + j &gt;= c.size())
                    c.push_back(a[j] * b[i]);
                else
                    c[i + j] += a[j] * b[i];
            }
        }
        for (int i = 0; i &lt; c.size(); i++)
        {
            carry += c[i];
            c[i] = carry % 10;
            carry /= 10;
        }
        c.push_back(carry);

        zero_start = true;
        for (int i = c.size() - 1; i &gt;= 0; i--)
        {
            if (c[i] == 0 &amp;&amp; zero_start)
                c.pop_back();
            else
                break;
        }
        if (c.empty())
            c.push_back(0);

        cout &lt;&lt; &quot;(a) * (b) = &quot; &lt;&lt; (c_sign &lt; 0 ? &quot;-&quot; : &quot;&quot;);
        for (int i = c.size() - 1; i &gt;= 0; i--)
            cout &lt;&lt; c[i];
        cout &lt;&lt; endl;
        // write to log file
        log_file &lt;&lt; &quot;(a) * (b) = &quot; &lt;&lt; (c_sign &lt; 0 ? &quot;-&quot; : &quot;&quot;);
        for (int i = c.size() - 1; i &gt;= 0; i--)
            log_file &lt;&lt; c[i];
        log_file &lt;&lt; endl;
        log_file.close();
        return 0;
    }
    // &quot;*&quot; Done

    else if (n == 5) // &quot;/&quot;
    {
        c_sign = a_sign * b_sign;
        c.push_back(0);

        while (a.size() &gt;= b.size())
        {
            for (int i = 0; i &lt; b.size(); i++)
            {
                carry += a[i] - b[i] + 10;
                a[i] = carry % 10;
                carry = carry / 10 - 1;
            }

            for (int i = b.size(); i &lt; a.size(); i++)
            {
                if (carry == 0)
                    break;
                carry += a[i] + 10;
                a[i] = carry % 10;
                carry = carry / 10 - 1;
            }
            a.push_back(carry);

            zero_start = true;
            for (int i = a.size() - 1; i &gt;= 0; i--)
            {
                if (a[i] == 0 &amp;&amp; zero_start)
                    a.pop_back();
                else
                    break;
            }
            if (a.empty())
                a.push_back(0);

            if (a[a.size() - 1] &gt;= 0)
                c[0]++;
            else
                break;
        }

        cout &lt;&lt; &quot;(a) / (b) = &quot; &lt;&lt; (c_sign &lt; 0 ? &quot;-&quot; : &quot;&quot;) &lt;&lt; c[0] &lt;&lt; endl;
        // write to log file
        log_file &lt;&lt; &quot;(a) / (b) = &quot; &lt;&lt; (c_sign &lt; 0 ? &quot;-&quot; : &quot;&quot;) &lt;&lt; c[0] &lt;&lt; endl;
        log_file.close();
        return 0;
    }
    // &quot;/&quot; Done

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-2-point--triangle-in-text-file-function-ver"><a class="header" href="#example-2-point--triangle-in-text-file-function-ver">Example 2: Point &amp; Triangle in Text File (function ver.)</a></h1>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;

class Triangle_2D; // forward declaration

class Point_2D // the class name
// we use first upper case letter to indicate a class
{
private: // private data members &amp; member functions
    // Data members
    // we use `m_` to indicate a data member

    // record the x coordinate
    double m_x;
    // record the y coordinate
    double m_y;

    // Member functions
    // we use `_` to indicate a member function

    // check if the point is valid
    void _check_validity();

public: // public member functions
    // Constructor

    // Constructor &amp; Default constructor
    // initialize data members, with default values
    // accessable to const object by default
    Point_2D(const double &amp;arg_x = 0, const double &amp;arg_y = 0);

    // Copy constructor
    // copy the data members from the given object
    // accessable to const object by default
    Point_2D(const Point_2D &amp;arg_point);

    // Destructor
    ~Point_2D() // destructor
    {
        // do nothing, because we don't
        // have any dynamic memory
    }

    // Member functions
    // we use lower case letter to indicate a member function
    // also, we just define the function declaration
    // and leave the definition to the end of the class

    // modify the x and y coordinate
    // we use `arg_` to indicate the arguments
    // and re-write with setter
    void set_x(const double &amp;arg_x);
    void set_y(const double &amp;arg_y);
    void set(const double &amp;arg_x, const double &amp;arg_y);
    // get the x coordinate and y coordinate
    // accessable to const object
    double get_x() const;
    double get_y() const;
    // // compare two points
    bool operator==(const Point_2D &amp;arg_point) const;
    bool operator!=(const Point_2D &amp;arg_point) const;
    bool operator&lt;(const Point_2D &amp;arg_point) const;
    bool operator&gt;(const Point_2D &amp;arg_point) const;
    bool operator&lt;=(const Point_2D &amp;arg_point) const;
    bool operator&gt;=(const Point_2D &amp;arg_point) const;
    // assign the point with another point
    Point_2D &amp;operator=(const Point_2D &amp;arg_point);

    // friend class
    friend class Triangle_2D;
    // friend function
    // print the x and y coordinate in format (x, y)
    // accessable to const object
    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;arg_os, const Point_2D &amp;arg_point);
    // read the coordinate of a point from the input, format: (x, y) and ignore space
    friend std::istream &amp;operator&gt;&gt;(std::istream &amp;arg_is, Point_2D &amp;arg_point);
};

// Triangle_2D class declaration
class Triangle_2D
{
private:
    // define three points of the Triangle_2D
    // in array of Point_2D format
    Point_2D m_point[3];

    // check &amp; correct the Triangle_2D points to counterclockwise order
    void _check_points();

public:
    // Constructor
    Triangle_2D(const double &amp;arg_x0 = 0.0, const double &amp;arg_y0 = 0.0,
                const double &amp;arg_x1 = 0.0, const double &amp;arg_y1 = 0.0,
                const double &amp;arg_x2 = 0.0, const double &amp;arg_y2 = 0.0);

    // Copy constructor
    Triangle_2D(const Triangle_2D &amp;arg_triangle);

    // Destructor
    ~Triangle_2D()
    {
        // do nothing
    }

    // modify the three points of the Triangle_2D
    void set_points(const double &amp;arg_x0, const double &amp;arg_y0,
                    const double &amp;arg_x1, const double &amp;arg_y1,
                    const double &amp;arg_x2, const double &amp;arg_y2);
    void set_point1(const double &amp;arg_x0, const double &amp;arg_y0);
    void set_point2(const double &amp;arg_x1, const double &amp;arg_y1);
    void set_point3(const double &amp;arg_x2, const double &amp;arg_y2);
    void set_x0(const double &amp;arg_x0);
    void set_y0(const double &amp;arg_y0);
    void set_x1(const double &amp;arg_x1);
    void set_y1(const double &amp;arg_y1);
    void set_x2(const double &amp;arg_x2);
    void set_y2(const double &amp;arg_y2);
    // get the three points of the Triangle_2D
    double get_x0() const;
    double get_y0() const;
    double get_x1() const;
    double get_y1() const;
    double get_x2() const;
    double get_y2() const;

    // calculate the area of the Triangle_2D
    double area();

    // print the Triangle_2D
    // format: ((x0, y0), (x1, y1), (x2, y2))
    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;arg_os, const Triangle_2D &amp;arg_tri);
    // read the coordinate of a point from the input,
    // format: ((x0, y0), (x1, y1), (x2, y2)) and ignore space
    friend std::istream &amp;operator&gt;&gt;(std::istream &amp;arg_is, Triangle_2D &amp;arg_tri);
};

// function definition

// check if the point is valid
void Point_2D::_check_validity()
{
    // check if the x coordinate is valid
    if (m_x &lt; 0)
    {
        // if not, set it to 0
        m_x = 0;
    }
    // check if the y coordinate is valid
    if (m_y &lt; 0)
    {
        // if not, set it to 0
        m_y = 0;
    }
}
// Constructor &amp; Default constructor
// initialize data members, with default values
Point_2D::Point_2D(const double &amp;arg_x, const double &amp;arg_y)
    // use `: var_name1(arg_var_name1), var_name2(arg_var_name2)`
    // to initialize data members
    : m_x(arg_x),
      m_y(arg_y)
{
    // check if the point is valid
    _check_validity();
}

// Copy constructor
// copy the data members from the given object
Point_2D::Point_2D(const Point_2D &amp;arg_point)
    : m_x(arg_point.m_x),
      m_y(arg_point.m_y)
{
    // check if the point is valid
    _check_validity();
}

// modify the x and y coordinate
// we use `arg_` to indicate the arguments
// and re-write with setter
void Point_2D::set_x(const double &amp;arg_x)
{
    m_x = arg_x;
    // check if the point is valid
    _check_validity();
}
void Point_2D::set_y(const double &amp;arg_y)
{
    m_y = arg_y;
    // check if the point is valid
    _check_validity();
}
void Point_2D::set(const double &amp;arg_x, const double &amp;arg_y)
{
    m_x = arg_x;
    m_y = arg_y;
    // check if the point is valid
    _check_validity();
}

// get the x coordinate and y coordinate
// accessable to const object
double Point_2D::get_x() const
{
    return m_x;
}
double Point_2D::get_y() const
{
    return m_y;
}

// // compare two points
bool Point_2D::operator==(const Point_2D &amp;arg_point) const
{
    // if the x and y coordinates are equal,
    // return true
    return (m_x == arg_point.m_x &amp;&amp; m_y == arg_point.m_y);
}
bool Point_2D::operator!=(const Point_2D &amp;arg_point) const
{
    return !(*this == arg_point);
}
bool Point_2D::operator&lt;(const Point_2D &amp;arg_point) const
{
    // if the x coordinate is smaller than the other point,
    // return true
    if (m_x &lt; arg_point.m_x)
    {
        return true;
    }
    // if the x coordinate is equal to the other point,
    // check if the y coordinate is smaller than the other point
    else if (m_x == arg_point.m_x)
    {
        // if the y coordinate is smaller, return true
        if (m_y &lt; arg_point.m_y)
        {
            return true;
        }
        // if the y coordinate is equal to the other point,
        // return false
        else if (m_y == arg_point.m_y)
        {
            return false;
        }
        // if the y coordinate is larger, return false
        else
        {
            return false;
        }
    }
    // if the x coordinate is larger, return false
    else
    {
        return false;
    }
}
bool Point_2D::operator&gt;(const Point_2D &amp;arg_point) const
{
    return !(*this &lt; arg_point || *this == arg_point);
}
bool Point_2D::operator&lt;=(const Point_2D &amp;arg_point) const
{
    return (*this &lt; arg_point || *this == arg_point);
}
bool Point_2D::operator&gt;=(const Point_2D &amp;arg_point) const
{
    return !(*this &lt; arg_point);
}
// assign the point with another point
Point_2D &amp;Point_2D::operator=(const Point_2D &amp;arg_point)
{
    // check if the point is valid
    _check_validity();
    // assign the x and y coordinate
    m_x = arg_point.m_x;
    m_y = arg_point.m_y;
    // check if the point is valid
    _check_validity();
    return *this;
}

// print the point in the format (x, y)
std::ostream &amp;operator&lt;&lt;(std::ostream &amp;arg_os, const Point_2D &amp;arg_point)
{
    arg_os &lt;&lt; &quot;(&quot; &lt;&lt; arg_point.m_x &lt;&lt; &quot;, &quot; &lt;&lt; arg_point.m_y &lt;&lt; &quot;)&quot;;
    return arg_os;
}

// read the coordinate of a point from the input, format: (x, y) and ignore space
std::istream &amp;operator&gt;&gt;(std::istream &amp;arg_is, Point_2D &amp;arg_point)
{
    string str_x, str_y, temp;

    if (getline(arg_is, temp, '(')) // ignore the first '('
    {
        if (getline(arg_is, str_x, ','))
        {
            if (getline(arg_is, str_y, ')'))
            {
                arg_point.m_x = stod(str_x);
                arg_point.m_y = stod(str_y);
            }
        }
    }

    // check if the point is valid
    arg_point._check_validity();

    return arg_is;
}

// Triangle_2D class implementation

// check &amp; correct the Triangle_2D points to counterclockwise order
void Triangle_2D::_check_points()
{
    // sort the points in ascending order
    for (int i = 0; i &lt; 3; i++)
    {
        for (int j = i + 1; j &lt; 3; j++)
        {
            if (m_point[i] &gt; m_point[j])
            {
                // swap the points
                Point_2D temp = m_point[i];
                m_point[i] = m_point[j];
                m_point[j] = temp;
            }
        }
    }

    // if the area is negative, swap the points
    if (area() &lt; 0.0)
    {
        Point_2D temp = m_point[0];
        m_point[0] = m_point[1];
        m_point[1] = temp;
    }
}

// Constructor
Triangle_2D::Triangle_2D(const double &amp;arg_x0, const double &amp;arg_y0,
                         const double &amp;arg_x1, const double &amp;arg_y1,
                         const double &amp;arg_x2, const double &amp;arg_y2)
    : m_point{Point_2D(arg_x0, arg_y0),
              Point_2D(arg_x1, arg_y1),
              Point_2D(arg_x2, arg_y2)} // init the array with {}
{
    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}

// Copy constructor
Triangle_2D::Triangle_2D(const Triangle_2D &amp;arg_triangle)
    : m_point{Point_2D(arg_triangle.m_point[0]),
              Point_2D(arg_triangle.m_point[1]),
              Point_2D(arg_triangle.m_point[2])} // init the array with {}
{
}

// set the three points of the Triangle_2D
void Triangle_2D::set_points(const double &amp;arg_x0, const double &amp;arg_y0,
                             const double &amp;arg_x1, const double &amp;arg_y1,
                             const double &amp;arg_x2, const double &amp;arg_y2)
{
    m_point[0].set(arg_x0, arg_y0);
    m_point[1].set(arg_x1, arg_y1);
    m_point[2].set(arg_x2, arg_y2);

    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}
void Triangle_2D::set_point1(const double &amp;arg_x0, const double &amp;arg_y0)
{
    m_point[0].set(arg_x0, arg_y0);

    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}
void Triangle_2D::set_point2(const double &amp;arg_x1, const double &amp;arg_y1)
{
    m_point[1].set(arg_x1, arg_y1);

    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}
void Triangle_2D::set_point3(const double &amp;arg_x2, const double &amp;arg_y2)
{
    m_point[2].set(arg_x2, arg_y2);

    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}
void Triangle_2D::set_x0(const double &amp;arg_x0)
{
    m_point[0].m_x = arg_x0;

    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}
void Triangle_2D::set_y0(const double &amp;arg_y0)
{
    m_point[0].m_y = arg_y0;

    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}
void Triangle_2D::set_x1(const double &amp;arg_x1)
{
    m_point[1].m_x = arg_x1;

    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}
void Triangle_2D::set_y1(const double &amp;arg_y1)
{
    m_point[1].m_y = arg_y1;

    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}
void Triangle_2D::set_x2(const double &amp;arg_x2)
{
    m_point[2].m_x = arg_x2;

    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}
void Triangle_2D::set_y2(const double &amp;arg_y2)
{
    m_point[2].m_y = arg_y2;

    // check &amp; correct the Triangle_2D points to counterclockwise order
    _check_points();
}

// get the three points of the Triangle_2D
double Triangle_2D::get_x0() const
{
    return m_point[0].m_x;
}
double Triangle_2D::get_y0() const
{
    return m_point[0].m_y;
}
double Triangle_2D::get_x1() const
{
    return m_point[1].m_x;
}
double Triangle_2D::get_y1() const
{
    return m_point[1].m_y;
}
double Triangle_2D::get_x2() const
{
    return m_point[2].m_x;
}
double Triangle_2D::get_y2() const
{
    return m_point[2].m_y;
}

// calculate the area of the Triangle_2D
double Triangle_2D::area()
{
    // calculate the area of the Triangle_2D
    return (m_point[0].m_x * m_point[1].m_y +
            m_point[1].m_x * m_point[2].m_y +
            m_point[2].m_x * m_point[0].m_y -
            m_point[0].m_x * m_point[2].m_y -
            m_point[1].m_x * m_point[0].m_y -
            m_point[2].m_x * m_point[1].m_y) /
           2.0;
}

// print the Triangle_2D
// format: ((x0, y0), (x1, y1), (x2, y2))
std::ostream &amp;operator&lt;&lt;(std::ostream &amp;arg_os, const Triangle_2D &amp;arg_tri)
{
    arg_os &lt;&lt; &quot;(&quot;;
    for (int i = 0; i &lt; 3; i++)
    {
        arg_os &lt;&lt; arg_tri.m_point[i];
        if (i &lt; 2)
            arg_os &lt;&lt; &quot;, &quot;;
    }
    arg_os &lt;&lt; &quot;)&quot;;
    return arg_os;
}
// read the coordinate of a point from the input,
// format: ((x0, y0), (x1, y1), (x2, y2)) and ignore space
std::istream &amp;operator&gt;&gt;(std::istream &amp;arg_is, Triangle_2D &amp;arg_tri)
{
    string temp;
    if (getline(arg_is, temp, '(')) // ignore the first '('
    {
        for (int i = 0; i &lt; 3; i++)
        {
            arg_is &gt;&gt; arg_tri.m_point[i];
            if (i &lt; 2)
            {
                getline(arg_is, temp, ','); // ignore the ','
            }
        }
        getline(arg_is, temp, ')'); // ignore the last ')'
    }

    // check &amp; correct the Triangle_2D points to counterclockwise order
    arg_tri._check_points();

    return arg_is;
}

// main function

int main()
{
    Triangle_2D t(1, 1, 2, 2, 0, 3);
    cout &lt;&lt; t &lt;&lt; endl;
    cout &lt;&lt; &quot;Area: &quot; &lt;&lt; t.area() &lt;&lt; endl;

    ofstream t_file(&quot;triangle.txt&quot;, ios::out | ios::trunc);
    // reuse the `&lt;&lt;` operator to write the Triangle_2D to the file
    t_file &lt;&lt; t &lt;&lt; endl;
    t_file.close();

    // read the Triangle_2D from the file
    ifstream t_file_in(&quot;triangle.txt&quot;, ios::in);
    Triangle_2D t_in;
    t_file_in &gt;&gt; t_in;
    cout &lt;&lt; t_in &lt;&lt; endl;
    cout &lt;&lt; &quot;Area: &quot; &lt;&lt; t_in.area() &lt;&lt; endl;
    t_file_in.close();

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-3-vector--matrix-in-binary-file-function-ver"><a class="header" href="#example-3-vector--matrix-in-binary-file-function-ver">Example 3: Vector &amp; Matrix in Binary File (function ver.)</a></h1>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;cmath&gt;

using namespace std;

class Vector_3D; // forward declaration

class Point_3D // represents a point in 3D space
{
private:
    // record the x coordinate
    double m_x;
    // record the y coordinate
    double m_y;
    // record the z coordinate
    double m_z;

public:
    Point_3D(const double &amp;arg_x = 0, const double &amp;arg_y = 0,
             const double &amp;arg_z = 0);
    Point_3D(const Point_3D &amp;arg_point);

    // Destructor
    ~Point_3D() // destructor
    {
        // do nothing, because we don't
        // have any dynamic memory
    }

    // modify the x, y and z coordinate
    void set_x(const double &amp;arg_x);
    void set_y(const double &amp;arg_y);
    void set_z(const double &amp;arg_z);
    void set(const double &amp;arg_x, const double &amp;arg_y, const double &amp;arg_z);
    // get the x, y and z coordinate
    double get_x() const;
    double get_y() const;
    double get_z() const;

    // calculate the distance between two points
    // in form of a vector
    Vector_3D operator-(const Point_3D &amp;arg_point) const;

    // friend class
    friend class Vector_3D;
    // print the x and y coordinate in format (x, y, z)
    // accessable to const object
    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;arg_os, const Point_3D &amp;arg_point);
    // read the coordinate of a point from the input,
    // format: (x, y, z) and ignore space
    friend std::istream &amp;operator&gt;&gt;(std::istream &amp;arg_is, Point_3D &amp;arg_point);
};

// Vector_3D class declaration
class Vector_3D
{
private:
    // define the three factor of the basis vectors
    // on the x, y, z axes
    double m_x, m_y, m_z;

public:
    // Constructor
    Vector_3D(const double &amp;arg_x = 0.0, const double &amp;arg_y = 0.0,
              const double &amp;arg_z = 0.0);
    Vector_3D(const Point_3D &amp;arg_point1, const Point_3D &amp;arg_point2);

    // Copy constructor
    Vector_3D(const Vector_3D &amp;arg_vector);

    // Destructor
    ~Vector_3D()
    {
        // do nothing
    }

    // set the three factor of the basis vectors
    void set_vector(const double &amp;arg_x, const double &amp;arg_y,
                    const double &amp;arg_z);
    void set_vector(const Point_3D &amp;arg_point1, const Point_3D &amp;arg_point2);
    void set_x(const double &amp;arg_x);
    void set_y(const double &amp;arg_y);
    void set_z(const double &amp;arg_z);
    // get the three factor of the basis vectors
    double get_x() const;
    double get_y() const;
    double get_z() const;

    // assign operator
    Vector_3D &amp;operator=(const Vector_3D &amp;arg_vector);

    // calculate the length of the Vector_3D
    double length();
    // calculate the dot product of two vectors
    int dot(const Vector_3D &amp;);
    // calculate the cross product of two vectors
    Vector_3D cross(const Vector_3D &amp;);

    // print the Vector_3D in format (x, y, z)
    // accessable to const object
    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;arg_os,
                                    const Vector_3D &amp;arg_point);
    // read the factors of a vector from the input,
    // format: (x, y, z) and ignore space
    friend std::istream &amp;operator&gt;&gt;(std::istream &amp;arg_is,
                                    Vector_3D &amp;arg_point);
    // write the Vector_3D in binary format
    friend void write_vector_binary(std::ofstream &amp;arg_ofs,
                                    const Vector_3D &amp;arg_vector);
    // read the Vector_3D in binary format
    friend void read_vector_binary(std::ifstream &amp;arg_ifs,
                                   Vector_3D &amp;arg_vector);
};

// Point_3D class implementation

// Constructor &amp; Default constructor
// initialize data members, with default values
Point_3D::Point_3D(const double &amp;arg_x, const double &amp;arg_y,
                   const double &amp;arg_z)
    : m_x(arg_x),
      m_y(arg_y),
      m_z(arg_z)
{
}

// Copy constructor
// copy the data members from the given object
Point_3D::Point_3D(const Point_3D &amp;arg_point)
    : m_x(arg_point.m_x),
      m_y(arg_point.m_y),
      m_z(arg_point.m_z)
{
}

// modify the x and y coordinate
// we use `arg_` to indicate the arguments
// and re-write with setter
void Point_3D::set_x(const double &amp;arg_x)
{
    m_x = arg_x;
}
void Point_3D::set_y(const double &amp;arg_y)
{
    m_y = arg_y;
}
void Point_3D::set(const double &amp;arg_x, const double &amp;arg_y,
                   const double &amp;arg_z)
{
    m_x = arg_x;
    m_y = arg_y;
    m_z = arg_z;
}

// get the x coordinate and y coordinate
// accessable to const object
double Point_3D::get_x() const
{
    return m_x;
}
double Point_3D::get_y() const
{
    return m_y;
}
double Point_3D::get_z() const
{
    return m_z;
}

// calculate the distance between two points
// in form of a vector
Vector_3D Point_3D::operator-(const Point_3D &amp;arg_point) const
{
    return Vector_3D(*this, arg_point);
}

// print the point in the format (x, y, z)
std::ostream &amp;operator&lt;&lt;(std::ostream &amp;arg_os, const Point_3D &amp;arg_point)
{
    arg_os &lt;&lt; &quot;(&quot; &lt;&lt; arg_point.m_x &lt;&lt; &quot;, &quot; &lt;&lt; arg_point.m_y
           &lt;&lt; &quot;, &quot; &lt;&lt; arg_point.m_z &lt;&lt; &quot;)&quot;;
    return arg_os;
}

// read the coordinate of a point from the input,
// format: (x, y, z) and ignore space
std::istream &amp;operator&gt;&gt;(std::istream &amp;arg_is, Point_3D &amp;arg_point)
{
    string str_x, str_y, str_z, temp;

    if (getline(arg_is, temp, '(')) // ignore the first '('
    {
        if (getline(arg_is, str_x, ','))
        {
            if (getline(arg_is, str_y, ','))
            {
                if (getline(arg_is, str_z, ')'))
                {
                    arg_point.m_x = stod(str_x);
                    arg_point.m_y = stod(str_y);
                    arg_point.m_z = stod(str_z);
                }
            }
        }
    }
    return arg_is;
}

// Vector_3D class implementation

// Constructor
Vector_3D::Vector_3D(const double &amp;arg_x, const double &amp;arg_y,
                     const double &amp;arg_z)
    : m_x(arg_x), m_y(arg_y), m_z(arg_z)
{
}

Vector_3D::Vector_3D(const Point_3D &amp;arg_point1, const Point_3D &amp;arg_point2)
    : m_x(arg_point2.m_x - arg_point1.m_x),
      m_y(arg_point2.m_y - arg_point1.m_y),
      m_z(arg_point2.m_z - arg_point1.m_z)
{
}

// Copy constructor
Vector_3D::Vector_3D(const Vector_3D &amp;arg_vector)
    : m_x(arg_vector.m_x), m_y(arg_vector.m_y), m_z(arg_vector.m_z)
{
}

// set the three factor of the basis vectors
void Vector_3D::set_vector(const double &amp;arg_x, const double &amp;arg_y,
                           const double &amp;arg_z)
{
    m_x = arg_x;
    m_y = arg_y;
    m_z = arg_z;
}
void Vector_3D::set_vector(const Point_3D &amp;arg_point1,
                           const Point_3D &amp;arg_point2)
{
    m_x = arg_point2.m_x - arg_point1.m_x;
    m_y = arg_point2.m_y - arg_point1.m_y;
    m_z = arg_point2.m_z - arg_point1.m_z;
}
void Vector_3D::set_x(const double &amp;arg_x)
{
    m_x = arg_x;
}
void Vector_3D::set_y(const double &amp;arg_y)
{
    m_y = arg_y;
}
void Vector_3D::set_z(const double &amp;arg_z)
{
    m_z = arg_z;
}
// get the three factor of the basis vectors
double Vector_3D::get_x() const
{
    return m_x;
}
double Vector_3D::get_y() const
{
    return m_y;
}
double Vector_3D::get_z() const
{
    return m_z;
}

// assign operator
Vector_3D &amp;Vector_3D::operator=(const Vector_3D &amp;arg_vector)
{
    m_x = arg_vector.m_x;
    m_y = arg_vector.m_y;
    m_z = arg_vector.m_z;
    return *this;
}

// calculate the length of the Vector_3D
double Vector_3D::length()
{
    // calculate the length of the Vector_3D
    return sqrt(m_x * m_x + m_y * m_y + m_z * m_z);
}

// calculate the dot product of two vectors
int Vector_3D::dot(const Vector_3D &amp;arg_v)
{
    // calculate the dot product of two vectors
    return m_x * arg_v.m_x + m_y * arg_v.m_y + m_z * arg_v.m_z;
}

// calculate the cross product of two vectors
Vector_3D Vector_3D::cross(const Vector_3D &amp;arg_v)
{
    // calculate the cross product of two vectors
    Vector_3D v;
    v.m_x = m_y * arg_v.m_z - m_z * arg_v.m_y;
    v.m_y = m_z * arg_v.m_x - m_x * arg_v.m_z;
    v.m_z = m_x * arg_v.m_y - m_y * arg_v.m_x;
    return v;
}

// print the point in the format (x, y, z)
std::ostream &amp;operator&lt;&lt;(std::ostream &amp;arg_os, const Vector_3D &amp;arg_vector)
{
    arg_os &lt;&lt; &quot;(&quot; &lt;&lt; arg_vector.m_x &lt;&lt; &quot;, &quot; &lt;&lt; arg_vector.m_y
           &lt;&lt; &quot;, &quot; &lt;&lt; arg_vector.m_z &lt;&lt; &quot;)&quot;;
    return arg_os;
}

// read the factors of a vector from the input,
// format: (x, y, z) and ignore space
std::istream &amp;operator&gt;&gt;(std::istream &amp;arg_is, Vector_3D &amp;arg_vector)
{
    string str_x, str_y, str_z, temp;

    if (getline(arg_is, temp, '(')) // ignore the first '('
    {
        if (getline(arg_is, str_x, ','))
        {
            if (getline(arg_is, str_y, ','))
            {
                if (getline(arg_is, str_z, ')'))
                {
                    arg_vector.m_x = stod(str_x);
                    arg_vector.m_y = stod(str_y);
                    arg_vector.m_z = stod(str_z);
                }
            }
        }
    }
    return arg_is;
}

// write the vector to the file in binary format
void write_vector_binary(std::ofstream &amp;arg_ofs, const Vector_3D &amp;arg_vector)
{
    arg_ofs.write((char *)&amp;arg_vector.m_x, sizeof(double));
    arg_ofs.write((char *)&amp;arg_vector.m_y, sizeof(double));
    arg_ofs.write((char *)&amp;arg_vector.m_z, sizeof(double));
}

// read the vector from the file in binary format
void read_vector_binary(std::ifstream &amp;arg_ifs, Vector_3D &amp;arg_vector)
{
    arg_ifs.read((char *)&amp;arg_vector.m_x, sizeof(double));
    arg_ifs.read((char *)&amp;arg_vector.m_y, sizeof(double));
    arg_ifs.read((char *)&amp;arg_vector.m_z, sizeof(double));
}

// main function

int main()
{
    Vector_3D v1(1, 2, 3);
    Vector_3D v2(4, 5, 6);

    cout &lt;&lt; &quot;v1 = &quot; &lt;&lt; v1 &lt;&lt; endl;
    cout &lt;&lt; &quot;v2 = &quot; &lt;&lt; v2 &lt;&lt; endl;

    // save the vector to the file in binary format
    ofstream ofs(&quot;vector.bin&quot;, ios::binary | ios::trunc);
    write_vector_binary(ofs, v1);
    write_vector_binary(ofs, v2);
    ofs.close();

    // read the vector from the file in binary format
    ifstream ifs(&quot;vector.bin&quot;, ios::binary);
    Vector_3D v3, v4;
    read_vector_binary(ifs, v3);
    read_vector_binary(ifs, v4);

    cout &lt;&lt; &quot;v3 = &quot; &lt;&lt; v3 &lt;&lt; endl;
    cout &lt;&lt; &quot;v4 = &quot; &lt;&lt; v4 &lt;&lt; endl;

    return 0;
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
                
    </body>
</html>
